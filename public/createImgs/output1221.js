(function webpackUniversalModuleDefinition(root, factory) {
	if (typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if (typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for (var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function () {
	return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
				/******/
}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
				/******/
};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
			/******/
}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
				/******/
}
			/******/
};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
				/******/
}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
			/******/
};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
			/******/
};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
			/******/
};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Main.ts");
		/******/
})
/************************************************************************/
/******/({

/***/ "./libs/adapter/XMLHttpRequest.js":
/*!****************************************!*\
  !*** ./libs/adapter/XMLHttpRequest.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function () { return $XMLHttpRequest; });
/* harmony import */ var _libs_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/EventTarget.js */ "./libs/adapter/libs/EventTarget.js");
/* harmony import */ var _libs_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/base64-arraybuffer */ "./libs/adapter/libs/base64-arraybuffer.js");



				const _requestHeader = new WeakMap();
				const _responseHeader = new WeakMap();
				const _requestTask = new WeakMap();

				function _triggerEvent(type, event = {}) {
					event.target = event.target || this;

					if (typeof this[`on${type}`] === 'function') {
						this[`on${type}`].call(this, event);
					}
				}

				function _changeReadyState(readyState, event = {}) {
					this.readyState = readyState;

					event.readyState = readyState;

					_triggerEvent.call(this, 'readystatechange', event);
				}

				function _isRelativePath(url) {
					return !/^(http|https|ftp|myfile):\/\/.*/i.test(url);
				}

				class $XMLHttpRequest extends _libs_EventTarget_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
					constructor() {
						super();

						/*
						 * TODO 这一批事件应该是在 XMLHttpRequestEventTarget.prototype 上面的
						 */
						this.onabort = null;
						this.onerror = null;
						this.onload = null;
						this.onloadstart = null;
						this.onprogress = null;
						this.ontimeout = null;
						this.onloadend = null;

						this.onreadystatechange = null;
						this.readyState = 0;
						this.response = null;
						this.responseText = null;
						this.responseType = 'text';
						this.dataType = 'arraybuffer';
						this.responseXML = null;
						this.status = 0;
						this.statusText = '';
						this.upload = {};
						this.withCredentials = false;

						_requestHeader.set(this, {
							'content-type': 'application/x-www-form-urlencoded',
						});
						_responseHeader.set(this, {});
					}

					abort() {
						const myRequestTask = _requestTask.get(this);

						if (myRequestTask) {
							myRequestTask.abort();
						}
					}

					getAllResponseHeaders() {
						const responseHeader = _responseHeader.get(this);

						return Object.keys(responseHeader)
							.map(header => {
								return `${header}: ${responseHeader[header]}`;
							})
							.join('\n');
					}

					getResponseHeader(header) {
						return _responseHeader.get(this)[header];
					}

					open(method, url) {
						this._method = method;
						this._url = url;
						_changeReadyState.call(this, $XMLHttpRequest.OPENED);
					}

					overrideMimeType() { }

					async send(data = '') {
						if (this.readyState !== $XMLHttpRequest.OPENED) {
							throw new Error(
								"Failed to execute 'send' on 'XMLHttpRequest': The object's state must be OPENED.",
							);
						} else {
							let url = this._url;
							const header = _requestHeader.get(this);
							const responseType = this.responseType;
							const dataType = this.dataType;

							const relative = _isRelativePath(url);
							let encoding;

							if (responseType === 'arraybuffer') {
								// encoding = 'binary'
							} else {
								encoding = 'utf8';
							}

							delete this.response;
							this.response = null;

							const onSuccess = ({ data, statusCode, header }) => {
								if (responseType === 'arraybuffer') {//&& typeof data === "string" 
									data = Object(_libs_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__["decode"])(data);
								}


								statusCode = statusCode === undefined ? 200 : statusCode;
								if (typeof data !== 'string' && !(data instanceof ArrayBuffer)) {
									try {
										data = JSON.stringify(data);
									} catch (e) { }
								}

								this.status = statusCode;
								if (header) {
									_responseHeader.set(this, header);
								}
								_triggerEvent.call(this, 'loadstart');
								_changeReadyState.call(this, $XMLHttpRequest.HEADERS_RECEIVED);
								_changeReadyState.call(this, $XMLHttpRequest.LOADING);

								this.response = data;

								if (data instanceof ArrayBuffer) {
									Object.defineProperty(this, 'responseText', {
										enumerable: true,
										configurable: true,
										get: function () {
											throw 'InvalidStateError : responseType is ' + this.responseType;
										},
									});
								} else {
									this.responseText = data;
								}
								_changeReadyState.call(this, $XMLHttpRequest.DONE);
								_triggerEvent.call(this, 'load'); // 会去调用onload
								_triggerEvent.call(this, 'loadend'); // 会去调用onloadend
							};

							const onFail = ({ errorMessage }) => {
								// TODO 规范错误
								// my.alert({content: JSON.stringify(errorMessage)})

								if (errorMessage.indexOf('abort') !== -1) {
									_triggerEvent.call(this, 'abort');
								} else {
									_triggerEvent.call(this, 'error', {
										message: errorMessage,
									});
								}
								_triggerEvent.call(this, 'loadend');

								if (relative) {
									// 用户即使没监听error事件, 也给出相应的警告
									console.warn(errorMessage);
								}
							};

							if (relative) {
								const fs = my.getFileSystemManager();

								var options = {
									filePath: url,
									success: onSuccess,
									fail: onFail,
								};
								// if (encoding) {
								// options["encoding"] = encoding;
								// }
								fs.access({
									path: url,
									success: res => {
										console.log('文件存在', res);
									},
									fail: err => {
										console.log('err:', err);
									},
								});
								fs.readFile(options);
								return;
							}

							if ($XMLHttpRequest.URLModifier) url = await $XMLHttpRequest.URLModifier(url);
							// const sdkVersion = my.SDKVersion.split(".").map(Number);
							my.downloadFile({
								url,
								data,
								success: ({ apFilePath }) => {
									const fs = my.getFileSystemManager();
									console.log('success', url, responseType)
									fs.readFile({
										filePath: apFilePath,
										encoding: responseType === 'arraybuffer' ? 'base64' : 'utf8',
										// encoding: responseType === 'text'?'utf8':(sdkVersion[sdkVersion.length-1]<10?'base64':undefined),
										// encoding: 'arraybuffer', // 不写encoding默认ArrayBuffer
										success: onSuccess,
										fail: onFail,
									});
								},
								fail: onFail,
							});

							// my.request({
							//   data,
							//   url: url,
							//   method: this._method,
							//   header: header,
							//   dataType: dataType,
							//   responseType: responseType,
							//   success: onSuccess,
							//   fail: onFail,
							// });
						}
					}

					setRequestHeader(header, value) {
						const myHeader = _requestHeader.get(this);

						myHeader[header] = value;
						_requestHeader.set(this, myHeader);
					}

					addEventListener(type, listener) {
						if (typeof listener !== 'function') {
							return;
						}

						this['on' + type] = (event = {}) => {
							event.target = event.target || this;
							listener.call(this, event);
						};
					}

					removeEventListener(type, listener) {
						if (this['on' + type] === listener) {
							this['on' + type] = null;
						}
					}
				}

				// TODO 没法模拟 HEADERS_RECEIVED 和 LOADING 两个状态
				$XMLHttpRequest.UNSEND = 0;
				$XMLHttpRequest.OPENED = 1;
				$XMLHttpRequest.HEADERS_RECEIVED = 2;
				$XMLHttpRequest.LOADING = 3;
				$XMLHttpRequest.DONE = 4;

				/***/
}),

/***/ "./libs/adapter/adapter.js":
/*!*********************************!*\
  !*** ./libs/adapter/adapter.js ***!
  \*********************************/
/*! exports provided: TaobaoPlatform */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TaobaoPlatform", function () { return TaobaoPlatform; });
/* harmony import */ var _libs_URL__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./libs/URL */ "./libs/adapter/libs/URL.js");
/* harmony import */ var _libs_Blob__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./libs/Blob */ "./libs/adapter/libs/Blob.js");
/* harmony import */ var _libs_atob__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./libs/atob */ "./libs/adapter/libs/atob.js");
/* harmony import */ var _libs_EventTarget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./libs/EventTarget */ "./libs/adapter/libs/EventTarget.js");
/* harmony import */ var _XMLHttpRequest_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./XMLHttpRequest.js */ "./libs/adapter/XMLHttpRequest.js");
/* harmony import */ var _libs_copyProperties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./libs/copyProperties */ "./libs/adapter/libs/copyProperties.js");
/* harmony import */ var _libs_DOMParser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./libs/DOMParser */ "./libs/adapter/libs/DOMParser.js");
/* harmony import */ var _libs_TextDecoder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./libs/TextDecoder */ "./libs/adapter/libs/TextDecoder.js");









				function OffscreenCanvas() {
					return my.createOffscreenCanvas();
				}

				const radianToDegree = 180 / Math.PI;

				class TaobaoPlatform {
					constructor(canvas, width, height) {
						const systemInfo = my.getSystemInfoSync();

						this.canvas = canvas;
						this.canvasW = width === undefined ? canvas.width : width;
						this.canvasH = height === undefined ? canvas.height : height;

						this.document = {
							createElementNS(_, type) {
								if (type === 'canvas') return canvas;
								if (type === 'img') {
									const img = canvas.createImage();
									img.addEventListener = (name, cb) =>
										(img[`on${name}`] = cb.bind(img));
									img.removeEventListener = (name, cb) => (img[`on${name}`] = null);
									return img;
								}
							},
						};

						this.window = {
							innerWidth: systemInfo.windowWidth,
							innerHeight: systemInfo.windowHeight,
							devicePixelRatio: systemInfo.pixelRatio,

							DOMParser: _libs_DOMParser__WEBPACK_IMPORTED_MODULE_6__["$DOMParser"],
							TextDecoder: _libs_TextDecoder__WEBPACK_IMPORTED_MODULE_7__["$TextDecoder"],
							URL: new _libs_URL__WEBPACK_IMPORTED_MODULE_0__["default"](),
							AudioContext: function () { },
							requestAnimationFrame: cb => this.canvas.requestAnimationFrame ? this.canvas.cancelAnimationFrame(cb) : requestAnimationFrame(cb),
							cancelAnimationFrame: cb => this.canvas.cancelAnimationFrame ? this.canvas.cancelAnimationFrame(cb) : cancelAnimationFrame(cb),

							DeviceOrientationEvent: {
								requestPermission() {
									return Promise.resolve('granted');
								},
							},
						};

						[this.document, this.window, this.canvas].forEach(i => {
							const old = i.__proto__;
							i.__proto__ = {};
							i.__proto__.__proto__ = old;
							Object(_libs_copyProperties__WEBPACK_IMPORTED_MODULE_5__["default"])(i.__proto__, _libs_EventTarget__WEBPACK_IMPORTED_MODULE_3__["default"].prototype);
						});

						this.patchCanvas();

						this.onDeviceMotionChange = e => {
							this.window.dispatchEvent({
								type: 'deviceorientation',
								alpha: e.alpha * radianToDegree,
								beta: -e.beta * radianToDegree,
								gamma: e.gamma * radianToDegree,
							});
						};

						// this.canvas.ownerDocument = this.document;
					}

					patchCanvas() {
						Object.defineProperty(this.canvas, 'style', {
							get() {
								return {
									width: this.width + 'px',
									height: this.height + 'px',
								};
							},
						});

						Object.defineProperty(this.canvas, 'clientHeight', {
							get() {
								return this.canvasH || this.height;
							},
						});

						Object.defineProperty(this.canvas, 'clientWidth', {
							get() {
								return this.canvasW || this.width;
							},
						});
					}

					setWebGLExtensions() {
						return {
							EXT_blend_minmax: null,
						};
					}

					getGlobals() {
						return {
							atob: _libs_atob__WEBPACK_IMPORTED_MODULE_2__["default"],
							Blob: _libs_Blob__WEBPACK_IMPORTED_MODULE_1__["default"],
							window: this.window,
							document: this.document,
							HTMLCanvasElement: undefined,
							XMLHttpRequest: _XMLHttpRequest_js__WEBPACK_IMPORTED_MODULE_4__["default"],
							OffscreenCanvas: OffscreenCanvas,
							createImageBitmap: undefined,
						};
					}

					enableDeviceOrientation() {
						my.onDeviceMotionChange(this.onDeviceMotionChange);
					}

					disableDeviceOrientation() {
						my.offDeviceMotionChange(this.onDeviceMotionChange);
					}

					dispatchTouchEvent(e = {}) {
						// console.log(e.type.toLowerCase());
						const target = Object.assign({}, this);
						let changedTouches = []
						if (e.changedTouches) {
							changedTouches = e.changedTouches
						} else {
							changedTouches = e.touches
						}
						// console.log("changedTouches", changedTouches);
						const event = {
							changedTouches: changedTouches.map(touch => new _libs_EventTarget__WEBPACK_IMPORTED_MODULE_3__["Touch"](touch)),
							touches: e.touches.map(touch => new _libs_EventTarget__WEBPACK_IMPORTED_MODULE_3__["Touch"](touch)),
							targetTouches: Array.prototype.slice.call(
								e.touches.map(touch => new _libs_EventTarget__WEBPACK_IMPORTED_MODULE_3__["Touch"](touch)),
							),
							timeStamp: e.timeStamp,
							target: target,
							currentTarget: target,
							type: e.type.toLowerCase(),
							cancelBubble: false,
							cancelable: false,
						};

						this.canvas.dispatchEvent(event);

						if (changedTouches.length) {
							const touch = changedTouches[0];
							const pointerEvent = {
								pageX: touch.x,
								pageY: touch.y,
								pointerId: touch.identifier,
								type: {
									touchstart: 'pointerdown',
									touchmove: 'pointermove',
									touchend: 'pointerup',
								}[e.type.toLowerCase()],
								pointerType: 'touch',
							};
							// console.log(pointerEvent.type,e.type);
							this.canvas.dispatchEvent(pointerEvent);
						}
					}

					setURLModifier(fn) {
						_XMLHttpRequest_js__WEBPACK_IMPORTED_MODULE_4__["default"].URLModifier = fn;
					}

					dispose() {
						this.disableDeviceOrientation();
						this.onDeviceMotionChange = null;
						this.document = null;
						this.window = null;
						this.canvas = null;
					}
				}


				/***/
}),

/***/ "./libs/adapter/libs/Blob.js":
/*!***********************************!*\
  !*** ./libs/adapter/libs/Blob.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function () { return Blob; });


				class Blob {
					constructor(parts, options) {
						this.parts = parts;
						this.options = options;

						// 目前仅适配如下
						// var blob = new Blob([bufferView], { type: source.mimeType });
						// sourceURI = URL.createObjectURL(blob);

						// var base64 = ArrayBufferToBase64(bufferView);
						// var url = `data:${options.type};base64,${base64}`;
					}
				}

				/***/
}),

/***/ "./libs/adapter/libs/DOMParser.js":
/*!****************************************!*\
  !*** ./libs/adapter/libs/DOMParser.js ***!
  \****************************************/
/*! exports provided: $DOMParser */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$DOMParser", function () { return $DOMParser; });
/* harmony import */ var _xml_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./xml-parser */ "./libs/adapter/libs/xml-parser.js");


				function walkTree(node, processer) {
					processer(node);
					node.children.forEach(i => walkTree(i, processer));
				}

				class $DOMParser {
					parseFromString(str) {
						const xml = Object(_xml_parser__WEBPACK_IMPORTED_MODULE_0__["default"])(str);

						const nodeBase = {
							hasAttribute(key) {
								return this.attributes[key] !== undefined;
							},
							getAttribute(key) {
								return this.attributes[key];
							},
							getElementsByTagName(tag) {
								// 看了dae的文件结构，xml的节点不算庞大，所以还能接受
								const result = [];
								this.childNodes.forEach(i =>
									walkTree(i, node => tag === node.name && result.push(node)),
								);
								return result;
							},
						};

						// patch xml
						walkTree(xml.root, node => {
							node.nodeType = 1;
							node.nodeName = node.name;
							node.style = new Proxy(
								(node.attributes.style || '').split(';').reduce((acc, curr) => {
									if (curr) {
										let [key, value] = curr.split(':');
										acc[key.trim()] = value.trim();
									}
									return acc;
								}, {}),
								{
									get(target, key) {
										return target[key] || '';
									},
								},
							);
							node.textContent = node.content;
							node.childNodes = node.children;
							node.__proto__ = nodeBase;
						});

						const out = {
							documentElement: xml.root,
							childNodes: [xml.root],
						};

						out.__proto__ = nodeBase;

						return out;
					}
				}

				/***/
}),

/***/ "./libs/adapter/libs/EventTarget.js":
/*!******************************************!*\
  !*** ./libs/adapter/libs/EventTarget.js ***!
  \******************************************/
/*! exports provided: Touch, default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Touch", function () { return Touch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function () { return EventTarget; });
				const _events = new WeakMap();

				class Touch {
					constructor(touch) {
						// CanvasTouch{identifier, x, y}
						// Touch{identifier, pageX, pageY, clientX, clientY, force}
						this.identifier = touch.identifier;

						this.force = touch.force === undefined ? 1 : touch.force;
						this.pageX = touch.pageX === undefined ? touch.x : touch.pageX;
						this.pageY = touch.pageY === undefined ? touch.y : touch.pageY;
						this.clientX = touch.clientX === undefined ? touch.x : touch.clientX;
						this.clientY = touch.clientY === undefined ? touch.y : touch.clientY;

						this.screenX = this.pageX;
						this.screenY = this.pageY;
					}
				}

				class EventTarget {
					constructor() {
						_events.set(this, {});
					}

					addEventListener(type, listener, options = {}) {
						let events = _events.get(this);

						if (!events) {
							events = {};
							_events.set(this, events);
						}
						if (!events[type]) {
							events[type] = [];
						}
						events[type].push(listener);

						if (options.capture) {
							// console.warn('EventTarget.addEventListener: options.capture is not implemented.')
						}
						if (options.once) {
							// console.warn('EventTarget.addEventListener: options.once is not implemented.')
						}
						if (options.passive) {
							// console.warn('EventTarget.addEventListener: options.passive is not implemented.')
						}
					}

					removeEventListener(type, listener) {
						const events = _events.get(this);

						if (events) {
							const listeners = events[type];

							if (listeners && listeners.length > 0) {
								for (let i = listeners.length; i--; i > 0) {
									if (listeners[i] === listener) {
										listeners.splice(i, 1);
										break;
									}
								}
							}
						}
					}

					dispatchEvent(event = {}) {
						if (typeof event.preventDefault !== 'function') {
							event.preventDefault = () => { };
						}
						if (typeof event.stopPropagation !== 'function') {
							event.stopPropagation = () => { };
						}

						const events = _events.get(this)

						if (events) {
							const listeners = events[event.type];

							if (listeners) {
								for (let i = 0; i < listeners.length; i++) {
									listeners[i](event);
								}
							}
						}
					}

					releasePointerCapture() { }
					setPointerCapture() { }
				}

				/***/
}),

/***/ "./libs/adapter/libs/TextDecoder.js":
/*!******************************************!*\
  !*** ./libs/adapter/libs/TextDecoder.js ***!
  \******************************************/
/*! exports provided: $TextDecoder */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "$TextDecoder", function () { return $TextDecoder; });
				class $TextDecoder {
					/**
					 * 不支持 UTF-8 code points 大于 1 字节
					 * @see https://stackoverflow.com/questions/17191945/conversion-between-utf-8-arraybuffer-and-string
					 * @param {Uint8Array|ArrayBuffer} uint8Array
					 */
					decode(uint8Array) {
						if (uint8Array instanceof ArrayBuffer)
							uint8Array = new Uint8Array(uint8Array);

						// from LoaderUtils.js
						let s = '';

						// Implicitly assumes little-endian.
						for (let i = 0, il = uint8Array.length; i < il; i++)
							s += String.fromCharCode(uint8Array[i]);

						try {
							// merges multi-byte utf-8 characters.
							return decodeURIComponent(escape(s));
						} catch (e) {
							// see #16358
							return s;
						}
						// return String.fromCharCode.apply(null, uint8Array);
					}
				}

				/***/
}),

/***/ "./libs/adapter/libs/URL.js":
/*!**********************************!*\
  !*** ./libs/adapter/libs/URL.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function () { return $URL; });
/* harmony import */ var _Blob__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Blob */ "./libs/adapter/libs/Blob.js");
/* harmony import */ var _base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64-arraybuffer */ "./libs/adapter/libs/base64-arraybuffer.js");



				class $URL {
					createObjectURL(obj) {
						if (obj instanceof _Blob__WEBPACK_IMPORTED_MODULE_0__["default"]) {
							// TODO: use wasm to improve decode performance
							// 经测试主要耗时在于字符串拼接，使用assemblyscript的字符串拼接比js拼接慢非常多

							// 组长找到更好的方式，使用wx.fileSystemManager写入临时文件来获取url，但是需要手动管理临时文件

							// const t = Date.now();
							const base64 = Object(_base64_arraybuffer__WEBPACK_IMPORTED_MODULE_1__["encode"])(obj.parts[0]);
							const url = `data:${obj.options.type};base64,${base64}`;
							// console.log('createObjectURL', Date.now() - t);
							return url;
						}

						return '';
					}

					revokeObjectURL() { }
				}

				/***/
}),

/***/ "./libs/adapter/libs/atob.js":
/*!***********************************!*\
  !*** ./libs/adapter/libs/atob.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function () { return atob; });
				/**
				 * Implementation of atob() according to the HTML and Infra specs, except that
				 * instead of throwing INVALID_CHARACTER_ERR we return null.
				 */
				function atob(data) {
					// Web IDL requires DOMStrings to just be converted using ECMAScript
					// ToString, which in our case amounts to using a template literal.
					data = `${data}`;
					// "Remove all ASCII whitespace from data."
					data = data.replace(/[ \t\n\f\r]/g, '');
					// "If data's length divides by 4 leaving no remainder, then: if data ends
					// with one or two U+003D (=) code points, then remove them from data."
					if (data.length % 4 === 0) {
						data = data.replace(/==?$/, '');
					}
					// "If data's length divides by 4 leaving a remainder of 1, then return
					// failure."
					//
					// "If data contains a code point that is not one of
					//
					// U+002B (+)
					// U+002F (/)
					// ASCII alphanumeric
					//
					// then return failure."
					if (data.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(data)) {
						return null;
					}
					// "Let output be an empty byte sequence."
					let output = '';
					// "Let buffer be an empty buffer that can have bits appended to it."
					//
					// We append bits via left-shift and or.  accumulatedBits is used to track
					// when we've gotten to 24 bits.
					let buffer = 0;
					let accumulatedBits = 0;
					// "Let position be a position variable for data, initially pointing at the
					// start of data."
					//
					// "While position does not point past the end of data:"
					for (let i = 0; i < data.length; i++) {
						// "Find the code point pointed to by position in the second column of
						// Table 1: The Base 64 Alphabet of RFC 4648. Let n be the number given in
						// the first cell of the same row.
						//
						// "Append to buffer the six bits corresponding to n, most significant bit
						// first."
						//
						// atobLookup() implements the table from RFC 4648.
						buffer <<= 6;
						buffer |= atobLookup(data[i]);
						accumulatedBits += 6;
						// "If buffer has accumulated 24 bits, interpret them as three 8-bit
						// big-endian numbers. Append three bytes with values equal to those
						// numbers to output, in the same order, and then empty buffer."
						if (accumulatedBits === 24) {
							output += String.fromCharCode((buffer & 0xff0000) >> 16);
							output += String.fromCharCode((buffer & 0xff00) >> 8);
							output += String.fromCharCode(buffer & 0xff);
							buffer = accumulatedBits = 0;
						}
						// "Advance position by 1."
					}
					// "If buffer is not empty, it contains either 12 or 18 bits. If it contains
					// 12 bits, then discard the last four and interpret the remaining eight as
					// an 8-bit big-endian number. If it contains 18 bits, then discard the last
					// two and interpret the remaining 16 as two 8-bit big-endian numbers. Append
					// the one or two bytes with values equal to those one or two numbers to
					// output, in the same order."
					if (accumulatedBits === 12) {
						buffer >>= 4;
						output += String.fromCharCode(buffer);
					} else if (accumulatedBits === 18) {
						buffer >>= 2;
						output += String.fromCharCode((buffer & 0xff00) >> 8);
						output += String.fromCharCode(buffer & 0xff);
					}
					// "Return output."
					return output;
				}
				/**
				 * A lookup table for atob(), which converts an ASCII character to the
				 * corresponding six-bit number.
				 */

				const keystr =
					'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

				function atobLookup(chr) {
					const index = keystr.indexOf(chr);
					// Throw exception if character is not in the lookup string; should not be hit in tests
					return index < 0 ? undefined : index;
				}

				/***/
}),

/***/ "./libs/adapter/libs/base64-arraybuffer.js":
/*!*************************************************!*\
  !*** ./libs/adapter/libs/base64-arraybuffer.js ***!
  \*************************************************/
/*! exports provided: encode, decode */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function () { return encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function () { return decode; });
				/*
				 * base64-arraybuffer
				 * https://github.com/niklasvh/base64-arraybuffer
				 *
				 * Copyright (c) 2012 Niklas von Hertzen
				 * Licensed under the MIT license.
				 */

				var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

				// Use a lookup table to find the index.
				var lookup = new Uint8Array(256);
				for (var i = 0; i < chars.length; i++) {
					lookup[chars.charCodeAt(i)] = i;
				}

				// 快一点
				function encode(arrayBuffer) {
					var base64 = '';

					var bytes = new Uint8Array(arrayBuffer);
					var byteLength = bytes.byteLength;
					var byteRemainder = byteLength % 3;
					var mainLength = byteLength - byteRemainder;

					var a, b, c, d;
					var chunk;

					// Main loop deals with bytes in chunks of 3
					for (var i = 0; i < mainLength; i = i + 3) {
						// Combine the three bytes into a single integer
						chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

						// Use bitmasks to extract 6-bit segments from the triplet
						a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
						b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
						c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
						d = chunk & 63; // 63       = 2^6 - 1

						// Convert the raw binary segments to the appropriate ASCII encoding
						base64 += chars[a] + chars[b] + chars[c] + chars[d];
					}

					// Deal with the remaining bytes and padding
					if (byteRemainder == 1) {
						chunk = bytes[mainLength];

						a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

						// Set the 4 least significant bits to zero
						b = (chunk & 3) << 4; // 3   = 2^2 - 1

						base64 += chars[a] + chars[b] + '==';
					} else if (byteRemainder == 2) {
						chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

						a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
						b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4

						// Set the 2 least significant bits to zero
						c = (chunk & 15) << 2; // 15    = 2^4 - 1

						base64 += chars[a] + chars[b] + chars[c] + '=';
					}

					return base64;
				}

				function decode(base64) {
					var bufferLength = base64.length * 0.75,
						len = base64.length,
						i,
						p = 0,
						encoded1,
						encoded2,
						encoded3,
						encoded4;

					if (base64[base64.length - 1] === '=') {
						bufferLength--;
						if (base64[base64.length - 2] === '=') {
							bufferLength--;
						}
					}

					var arraybuffer = new ArrayBuffer(bufferLength),
						bytes = new Uint8Array(arraybuffer);

					for (i = 0; i < len; i += 4) {
						encoded1 = lookup[base64.charCodeAt(i)];
						encoded2 = lookup[base64.charCodeAt(i + 1)];
						encoded3 = lookup[base64.charCodeAt(i + 2)];
						encoded4 = lookup[base64.charCodeAt(i + 3)];

						// TODO 小程序时切换成下面代码
						bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
						bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
						bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);

						// TODO 小部件时切换成下面代码
						// if(bytes[p]!==undefined) bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
						// if(bytes[p]!==undefined) bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
						// if(bytes[p]!==undefined) bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);

					}

					return arraybuffer;
				}

				/***/
}),

/***/ "./libs/adapter/libs/copyProperties.js":
/*!*********************************************!*\
  !*** ./libs/adapter/libs/copyProperties.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function () { return copyProperties; });


				function copyProperties(target, source) {
					for (let key of Object.getOwnPropertyNames(source)) {
						if (key !== 'constructor' && key !== 'prototype' && key !== 'name') {
							let desc = Object.getOwnPropertyDescriptor(source, key);
							Object.defineProperty(target, key, desc);
						}
					}
				}

				/***/
}),

/***/ "./libs/adapter/libs/xml-parser.js":
/*!*****************************************!*\
  !*** ./libs/adapter/libs/xml-parser.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
				/**
				 * Module dependencies.
				 */

				/**
				 * Expose `parse`.
				 */

				/**
				 * Parse the given string of `xml`.
				 *
				 * @param {String} xml
				 * @return {Object}
				 * @api public
				 */

				function parse(xml) {
					xml = xml.trim();

					// strip comments
					xml = xml.replace(/<!--[\s\S]*?-->/g, '');

					return document();

					/**
					 * XML document.
					 */

					function document() {
						return {
							declaration: declaration(),
							root: tag(),
						};
					}

					/**
					 * Declaration.
					 */

					function declaration() {
						const m = match(/^<\?xml\s*/);
						if (!m) return;

						// tag
						const node = {
							attributes: {},
						};

						// attributes
						while (!(eos() || is('?>'))) {
							const attr = attribute();
							if (!attr) return node;
							node.attributes[attr.name] = attr.value;
						}

						match(/\?>\s*/);

						// remove DOCTYPE
						// <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" 
						//      "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
						match(/<!DOCTYPE[^>]*>\s/);

						return node;
					}

					/**
					 * Tag.
					 */

					function tag() {
						const m = match(/^<([\w-:.]+)\s*/);
						if (!m) return;

						// name
						const node = {
							name: m[1],
							attributes: {},
							children: [],
						};

						// attributes
						while (!(eos() || is('>') || is('?>') || is('/>'))) {
							const attr = attribute();
							if (!attr) return node;
							node.attributes[attr.name] = attr.value;
						}

						// self closing tag
						if (match(/^\s*\/>\s*/)) {
							return node;
						}

						match(/\??>\s*/);

						// @ts-ignore content
						node.content = content();

						// children
						let child;
						while ((child = tag())) {
							node.children.push(child);
						}

						// closing
						match(/^<\/[\w-:.]+>\s*/);

						return node;
					}

					/**
					 * Text content.
					 */

					function content() {
						const m = match(/^([^<]*)/);
						if (m) return m[1];
						return '';
					}

					/**
					 * Attribute.
					 */

					function attribute() {
						const m = match(/([\w:-]+)\s*=\s*("[^"]*"|'[^']*'|\w+)\s*/);
						if (!m) return;
						return { name: m[1], value: strip(m[2]) };
					}

					/**
					 * Strip quotes from `val`.
					 */

					function strip(val) {
						return val.replace(/^['"]|['"]$/g, '');
					}

					/**
					 * Match `re` and advance the string.
					 */

					function match(re) {
						const m = xml.match(re);
						if (!m) return;
						xml = xml.slice(m[0].length);
						return m;
					}

					/**
					 * End-of-source.
					 */

					function eos() {
						return xml.length == 0;
					}

					/**
					 * Check for `prefix`.
					 */

					function is(prefix) {
						return xml.indexOf(prefix) == 0;
					}
				}

/* harmony default export */ __webpack_exports__["default"] = (parse);

				/***/
}),

/***/ "./libs/three/animation/AnimationAction.js":
/*!*************************************************!*\
  !*** ./libs/three/animation/AnimationAction.js ***!
  \*************************************************/
/*! exports provided: AnimationAction */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationAction", function () { return AnimationAction; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");



				class AnimationAction {

					constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {

						this._mixer = mixer;
						this._clip = clip;
						this._localRoot = localRoot;
						this.blendMode = blendMode;

						const tracks = clip.tracks,
							nTracks = tracks.length,
							interpolants = new Array(nTracks);

						const interpolantSettings = {
							endingStart: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"],
							endingEnd: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"]
						};

						for (let i = 0; i !== nTracks; ++i) {

							const interpolant = tracks[i].createInterpolant(null);
							interpolants[i] = interpolant;
							interpolant.settings = interpolantSettings;

						}

						this._interpolantSettings = interpolantSettings;

						this._interpolants = interpolants; // bound by the mixer

						// inside: PropertyMixer (managed by the mixer)
						this._propertyBindings = new Array(nTracks);

						this._cacheIndex = null; // for the memory manager
						this._byClipCacheIndex = null; // for the memory manager

						this._timeScaleInterpolant = null;
						this._weightInterpolant = null;

						this.loop = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopRepeat"];
						this._loopCount = - 1;

						// global mixer time when the action is to be started
						// it's set back to 'null' upon start of the action
						this._startTime = null;

						// scaled local time of the action
						// gets clamped or wrapped to 0..clip.duration according to loop
						this.time = 0;

						this.timeScale = 1;
						this._effectiveTimeScale = 1;

						this.weight = 1;
						this._effectiveWeight = 1;

						this.repetitions = Infinity; // no. of repetitions when looping

						this.paused = false; // true -> zero effective time scale
						this.enabled = true; // false -> zero effective weight

						this.clampWhenFinished = false;// keep feeding the last frame?

						this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
						this.zeroSlopeAtEnd = true;// clips for start, loop and end

					}

					// State & Scheduling

					play() {

						this._mixer._activateAction(this);

						return this;

					}

					stop() {

						this._mixer._deactivateAction(this);

						return this.reset();

					}

					reset() {

						this.paused = false;
						this.enabled = true;

						this.time = 0; // restart clip
						this._loopCount = - 1;// forget previous loops
						this._startTime = null;// forget scheduling

						return this.stopFading().stopWarping();

					}

					isRunning() {

						return this.enabled && !this.paused && this.timeScale !== 0 &&
							this._startTime === null && this._mixer._isActiveAction(this);

					}

					// return true when play has been called
					isScheduled() {

						return this._mixer._isActiveAction(this);

					}

					startAt(time) {

						this._startTime = time;

						return this;

					}

					setLoop(mode, repetitions) {

						this.loop = mode;
						this.repetitions = repetitions;

						return this;

					}

					// Weight

					// set the weight stopping any scheduled fading
					// although .enabled = false yields an effective weight of zero, this
					// method does *not* change .enabled, because it would be confusing
					setEffectiveWeight(weight) {

						this.weight = weight;

						// note: same logic as when updated at runtime
						this._effectiveWeight = this.enabled ? weight : 0;

						return this.stopFading();

					}

					// return the weight considering fading and .enabled
					getEffectiveWeight() {

						return this._effectiveWeight;

					}

					fadeIn(duration) {

						return this._scheduleFading(duration, 0, 1);

					}

					fadeOut(duration) {

						return this._scheduleFading(duration, 1, 0);

					}

					crossFadeFrom(fadeOutAction, duration, warp) {

						fadeOutAction.fadeOut(duration);
						this.fadeIn(duration);

						if (warp) {

							const fadeInDuration = this._clip.duration,
								fadeOutDuration = fadeOutAction._clip.duration,

								startEndRatio = fadeOutDuration / fadeInDuration,
								endStartRatio = fadeInDuration / fadeOutDuration;

							fadeOutAction.warp(1.0, startEndRatio, duration);
							this.warp(endStartRatio, 1.0, duration);

						}

						return this;

					}

					crossFadeTo(fadeInAction, duration, warp) {

						return fadeInAction.crossFadeFrom(this, duration, warp);

					}

					stopFading() {

						const weightInterpolant = this._weightInterpolant;

						if (weightInterpolant !== null) {

							this._weightInterpolant = null;
							this._mixer._takeBackControlInterpolant(weightInterpolant);

						}

						return this;

					}

					// Time Scale Control

					// set the time scale stopping any scheduled warping
					// although .paused = true yields an effective time scale of zero, this
					// method does *not* change .paused, because it would be confusing
					setEffectiveTimeScale(timeScale) {

						this.timeScale = timeScale;
						this._effectiveTimeScale = this.paused ? 0 : timeScale;

						return this.stopWarping();

					}

					// return the time scale considering warping and .paused
					getEffectiveTimeScale() {

						return this._effectiveTimeScale;

					}

					setDuration(duration) {

						this.timeScale = this._clip.duration / duration;

						return this.stopWarping();

					}

					syncWith(action) {

						this.time = action.time;
						this.timeScale = action.timeScale;

						return this.stopWarping();

					}

					halt(duration) {

						return this.warp(this._effectiveTimeScale, 0, duration);

					}

					warp(startTimeScale, endTimeScale, duration) {

						const mixer = this._mixer,
							now = mixer.time,
							timeScale = this.timeScale;

						let interpolant = this._timeScaleInterpolant;

						if (interpolant === null) {

							interpolant = mixer._lendControlInterpolant();
							this._timeScaleInterpolant = interpolant;

						}

						const times = interpolant.parameterPositions,
							values = interpolant.sampleValues;

						times[0] = now;
						times[1] = now + duration;

						values[0] = startTimeScale / timeScale;
						values[1] = endTimeScale / timeScale;

						return this;

					}

					stopWarping() {

						const timeScaleInterpolant = this._timeScaleInterpolant;

						if (timeScaleInterpolant !== null) {

							this._timeScaleInterpolant = null;
							this._mixer._takeBackControlInterpolant(timeScaleInterpolant);

						}

						return this;

					}

					// Object Accessors

					getMixer() {

						return this._mixer;

					}

					getClip() {

						return this._clip;

					}

					getRoot() {

						return this._localRoot || this._mixer._root;

					}

					// Interna

					_update(time, deltaTime, timeDirection, accuIndex) {

						// called by the mixer

						if (!this.enabled) {

							// call ._updateWeight() to update ._effectiveWeight

							this._updateWeight(time);
							return;

						}

						const startTime = this._startTime;

						if (startTime !== null) {

							// check for scheduled start of action

							const timeRunning = (time - startTime) * timeDirection;
							if (timeRunning < 0 || timeDirection === 0) {

								return; // yet to come / don't decide when delta = 0

							}

							// start

							this._startTime = null; // unschedule
							deltaTime = timeDirection * timeRunning;

						}

						// apply time scale and advance time

						deltaTime *= this._updateTimeScale(time);
						const clipTime = this._updateTime(deltaTime);

						// note: _updateTime may disable the action resulting in
						// an effective weight of 0

						const weight = this._updateWeight(time);

						if (weight > 0) {

							const interpolants = this._interpolants;
							const propertyMixers = this._propertyBindings;

							switch (this.blendMode) {

								case _constants_js__WEBPACK_IMPORTED_MODULE_0__["AdditiveAnimationBlendMode"]:

									for (let j = 0, m = interpolants.length; j !== m; ++j) {

										interpolants[j].evaluate(clipTime);
										propertyMixers[j].accumulateAdditive(weight);

									}

									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalAnimationBlendMode"]:
								default:

									for (let j = 0, m = interpolants.length; j !== m; ++j) {

										interpolants[j].evaluate(clipTime);
										propertyMixers[j].accumulate(accuIndex, weight);

									}

							}

						}

					}

					_updateWeight(time) {

						let weight = 0;

						if (this.enabled) {

							weight = this.weight;
							const interpolant = this._weightInterpolant;

							if (interpolant !== null) {

								const interpolantValue = interpolant.evaluate(time)[0];

								weight *= interpolantValue;

								if (time > interpolant.parameterPositions[1]) {

									this.stopFading();

									if (interpolantValue === 0) {

										// faded out, disable
										this.enabled = false;

									}

								}

							}

						}

						this._effectiveWeight = weight;
						return weight;

					}

					_updateTimeScale(time) {

						let timeScale = 0;

						if (!this.paused) {

							timeScale = this.timeScale;

							const interpolant = this._timeScaleInterpolant;

							if (interpolant !== null) {

								const interpolantValue = interpolant.evaluate(time)[0];

								timeScale *= interpolantValue;

								if (time > interpolant.parameterPositions[1]) {

									this.stopWarping();

									if (timeScale === 0) {

										// motion has halted, pause
										this.paused = true;

									} else {

										// warp done - apply final time scale
										this.timeScale = timeScale;

									}

								}

							}

						}

						this._effectiveTimeScale = timeScale;
						return timeScale;

					}

					_updateTime(deltaTime) {

						const duration = this._clip.duration;
						const loop = this.loop;

						let time = this.time + deltaTime;
						let loopCount = this._loopCount;

						const pingPong = (loop === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopPingPong"]);

						if (deltaTime === 0) {

							if (loopCount === - 1) return time;

							return (pingPong && (loopCount & 1) === 1) ? duration - time : time;

						}

						if (loop === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LoopOnce"]) {

							if (loopCount === - 1) {

								// just started

								this._loopCount = 0;
								this._setEndings(true, true, false);

							}

							handle_stop: {

								if (time >= duration) {

									time = duration;

								} else if (time < 0) {

									time = 0;

								} else {

									this.time = time;

									break handle_stop;

								}

								if (this.clampWhenFinished) this.paused = true;
								else this.enabled = false;

								this.time = time;

								this._mixer.dispatchEvent({
									type: 'finished', action: this,
									direction: deltaTime < 0 ? - 1 : 1
								});

							}

						} else { // repetitive Repeat or PingPong

							if (loopCount === - 1) {

								// just started

								if (deltaTime >= 0) {

									loopCount = 0;

									this._setEndings(true, this.repetitions === 0, pingPong);

								} else {

									// when looping in reverse direction, the initial
									// transition through zero counts as a repetition,
									// so leave loopCount at -1

									this._setEndings(this.repetitions === 0, true, pingPong);

								}

							}

							if (time >= duration || time < 0) {

								// wrap around

								const loopDelta = Math.floor(time / duration); // signed
								time -= duration * loopDelta;

								loopCount += Math.abs(loopDelta);

								const pending = this.repetitions - loopCount;

								if (pending <= 0) {

									// have to stop (switch state, clamp time, fire event)

									if (this.clampWhenFinished) this.paused = true;
									else this.enabled = false;

									time = deltaTime > 0 ? duration : 0;

									this.time = time;

									this._mixer.dispatchEvent({
										type: 'finished', action: this,
										direction: deltaTime > 0 ? 1 : - 1
									});

								} else {

									// keep running

									if (pending === 1) {

										// entering the last round

										const atStart = deltaTime < 0;
										this._setEndings(atStart, !atStart, pingPong);

									} else {

										this._setEndings(false, false, pingPong);

									}

									this._loopCount = loopCount;

									this.time = time;

									this._mixer.dispatchEvent({
										type: 'loop', action: this, loopDelta: loopDelta
									});

								}

							} else {

								this.time = time;

							}

							if (pingPong && (loopCount & 1) === 1) {

								// invert time for the "pong round"

								return duration - time;

							}

						}

						return time;

					}

					_setEndings(atStart, atEnd, pingPong) {

						const settings = this._interpolantSettings;

						if (pingPong) {

							settings.endingStart = _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"];
							settings.endingEnd = _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"];

						} else {

							// assuming for LoopOnce atStart == atEnd == true

							if (atStart) {

								settings.endingStart = this.zeroSlopeAtStart ? _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"] : _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"];

							} else {

								settings.endingStart = _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"];

							}

							if (atEnd) {

								settings.endingEnd = this.zeroSlopeAtEnd ? _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"] : _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"];

							} else {

								settings.endingEnd = _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"];

							}

						}

					}

					_scheduleFading(duration, weightNow, weightThen) {

						const mixer = this._mixer, now = mixer.time;
						let interpolant = this._weightInterpolant;

						if (interpolant === null) {

							interpolant = mixer._lendControlInterpolant();
							this._weightInterpolant = interpolant;

						}

						const times = interpolant.parameterPositions,
							values = interpolant.sampleValues;

						times[0] = now;
						values[0] = weightNow;
						times[1] = now + duration;
						values[1] = weightThen;

						return this;

					}

				}





				/***/
}),

/***/ "./libs/three/animation/AnimationClip.js":
/*!***********************************************!*\
  !*** ./libs/three/animation/AnimationClip.js ***!
  \***********************************************/
/*! exports provided: AnimationClip */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function () { return AnimationClip; });
/* harmony import */ var _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationUtils.js */ "./libs/three/animation/AnimationUtils.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyframeTrack.js */ "./libs/three/animation/KeyframeTrack.js");
/* harmony import */ var _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tracks/BooleanKeyframeTrack.js */ "./libs/three/animation/tracks/BooleanKeyframeTrack.js");
/* harmony import */ var _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tracks/ColorKeyframeTrack.js */ "./libs/three/animation/tracks/ColorKeyframeTrack.js");
/* harmony import */ var _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tracks/NumberKeyframeTrack.js */ "./libs/three/animation/tracks/NumberKeyframeTrack.js");
/* harmony import */ var _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tracks/QuaternionKeyframeTrack.js */ "./libs/three/animation/tracks/QuaternionKeyframeTrack.js");
/* harmony import */ var _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tracks/StringKeyframeTrack.js */ "./libs/three/animation/tracks/StringKeyframeTrack.js");
/* harmony import */ var _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tracks/VectorKeyframeTrack.js */ "./libs/three/animation/tracks/VectorKeyframeTrack.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");











				class AnimationClip {

					constructor(name, duration = - 1, tracks, blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_9__["NormalAnimationBlendMode"]) {

						this.name = name;
						this.tracks = tracks;
						this.duration = duration;
						this.blendMode = blendMode;

						this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_8__["generateUUID"]();

						// this means it should figure out its duration by scanning the tracks
						if (this.duration < 0) {

							this.resetDuration();

						}

					}


					static parse(json) {

						const tracks = [],
							jsonTracks = json.tracks,
							frameTime = 1.0 / (json.fps || 1.0);

						for (let i = 0, n = jsonTracks.length; i !== n; ++i) {

							tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));

						}

						const clip = new this(json.name, json.duration, tracks, json.blendMode);
						clip.uuid = json.uuid;

						return clip;

					}

					static toJSON(clip) {

						const tracks = [],
							clipTracks = clip.tracks;

						const json = {

							'name': clip.name,
							'duration': clip.duration,
							'tracks': tracks,
							'uuid': clip.uuid,
							'blendMode': clip.blendMode

						};

						for (let i = 0, n = clipTracks.length; i !== n; ++i) {

							tracks.push(_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__["KeyframeTrack"].toJSON(clipTracks[i]));

						}

						return json;

					}

					static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {

						const numMorphTargets = morphTargetSequence.length;
						const tracks = [];

						for (let i = 0; i < numMorphTargets; i++) {

							let times = [];
							let values = [];

							times.push(
								(i + numMorphTargets - 1) % numMorphTargets,
								i,
								(i + 1) % numMorphTargets);

							values.push(0, 1, 0);

							const order = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].getKeyframeOrder(times);
							times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].sortedArray(times, 1, order);
							values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].sortedArray(values, 1, order);

							// if there is a key at the first frame, duplicate it as the
							// last frame as well for perfect loop.
							if (!noLoop && times[0] === 0) {

								times.push(numMorphTargets);
								values.push(values[0]);

							}

							tracks.push(
								new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__["NumberKeyframeTrack"](
									'.morphTargetInfluences[' + morphTargetSequence[i].name + ']',
									times, values
								).scale(1.0 / fps));

						}

						return new this(name, - 1, tracks);

					}

					static findByName(objectOrClipArray, name) {

						let clipArray = objectOrClipArray;

						if (!Array.isArray(objectOrClipArray)) {

							const o = objectOrClipArray;
							clipArray = o.geometry && o.geometry.animations || o.animations;

						}

						for (let i = 0; i < clipArray.length; i++) {

							if (clipArray[i].name === name) {

								return clipArray[i];

							}

						}

						return null;

					}

					static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {

						const animationToMorphTargets = {};

						// tested with https://regex101.com/ on trick sequences
						// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
						const pattern = /^([\w-]*?)([\d]+)$/;

						// sort morph target names into animation groups based
						// patterns like Walk_001, Walk_002, Run_001, Run_002
						for (let i = 0, il = morphTargets.length; i < il; i++) {

							const morphTarget = morphTargets[i];
							const parts = morphTarget.name.match(pattern);

							if (parts && parts.length > 1) {

								const name = parts[1];

								let animationMorphTargets = animationToMorphTargets[name];

								if (!animationMorphTargets) {

									animationToMorphTargets[name] = animationMorphTargets = [];

								}

								animationMorphTargets.push(morphTarget);

							}

						}

						const clips = [];

						for (const name in animationToMorphTargets) {

							clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));

						}

						return clips;

					}

					// parse the animation.hierarchy format
					static parseAnimation(animation, bones) {

						if (!animation) {

							console.error('THREE.AnimationClip: No animation in JSONLoader data.');
							return null;

						}

						const addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {

							// only return track if there are actually keys.
							if (animationKeys.length !== 0) {

								const times = [];
								const values = [];

								_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].flattenJSON(animationKeys, times, values, propertyName);

								// empty keys are filtered out, so check again
								if (times.length !== 0) {

									destTracks.push(new trackType(trackName, times, values));

								}

							}

						};

						const tracks = [];

						const clipName = animation.name || 'default';
						const fps = animation.fps || 30;
						const blendMode = animation.blendMode;

						// automatic length determination in AnimationClip.
						let duration = animation.length || - 1;

						const hierarchyTracks = animation.hierarchy || [];

						for (let h = 0; h < hierarchyTracks.length; h++) {

							const animationKeys = hierarchyTracks[h].keys;

							// skip empty tracks
							if (!animationKeys || animationKeys.length === 0) continue;

							// process morph targets
							if (animationKeys[0].morphTargets) {

								// figure out all morph targets used in this track
								const morphTargetNames = {};

								let k;

								for (k = 0; k < animationKeys.length; k++) {

									if (animationKeys[k].morphTargets) {

										for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {

											morphTargetNames[animationKeys[k].morphTargets[m]] = - 1;

										}

									}

								}

								// create a track for each morph target with all zero
								// morphTargetInfluences except for the keys in which
								// the morphTarget is named.
								for (const morphTargetName in morphTargetNames) {

									const times = [];
									const values = [];

									for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {

										const animationKey = animationKeys[k];

										times.push(animationKey.time);
										values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0);

									}

									tracks.push(new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__["NumberKeyframeTrack"]('.morphTargetInfluence[' + morphTargetName + ']', times, values));

								}

								duration = morphTargetNames.length * (fps || 1.0);

							} else {

								// ...assume skeletal animation

								const boneName = '.bones[' + bones[h].name + ']';

								addNonemptyTrack(
									_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__["VectorKeyframeTrack"], boneName + '.position',
									animationKeys, 'pos', tracks);

								addNonemptyTrack(
									_tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__["QuaternionKeyframeTrack"], boneName + '.quaternion',
									animationKeys, 'rot', tracks);

								addNonemptyTrack(
									_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__["VectorKeyframeTrack"], boneName + '.scale',
									animationKeys, 'scl', tracks);

							}

						}

						if (tracks.length === 0) {

							return null;

						}

						const clip = new this(clipName, duration, tracks, blendMode);

						return clip;

					}

					resetDuration() {

						const tracks = this.tracks;
						let duration = 0;

						for (let i = 0, n = tracks.length; i !== n; ++i) {

							const track = this.tracks[i];

							duration = Math.max(duration, track.times[track.times.length - 1]);

						}

						this.duration = duration;

						return this;

					}

					trim() {

						for (let i = 0; i < this.tracks.length; i++) {

							this.tracks[i].trim(0, this.duration);

						}

						return this;

					}

					validate() {

						let valid = true;

						for (let i = 0; i < this.tracks.length; i++) {

							valid = valid && this.tracks[i].validate();

						}

						return valid;

					}

					optimize() {

						for (let i = 0; i < this.tracks.length; i++) {

							this.tracks[i].optimize();

						}

						return this;

					}

					clone() {

						const tracks = [];

						for (let i = 0; i < this.tracks.length; i++) {

							tracks.push(this.tracks[i].clone());

						}

						return new this.constructor(this.name, this.duration, tracks, this.blendMode);

					}

					toJSON() {

						return this.constructor.toJSON(this);

					}

				}

				function getTrackTypeForValueTypeName(typeName) {

					switch (typeName.toLowerCase()) {

						case 'scalar':
						case 'double':
						case 'float':
						case 'number':
						case 'integer':

							return _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__["NumberKeyframeTrack"];

						case 'vector':
						case 'vector2':
						case 'vector3':
						case 'vector4':

							return _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__["VectorKeyframeTrack"];

						case 'color':

							return _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__["ColorKeyframeTrack"];

						case 'quaternion':

							return _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__["QuaternionKeyframeTrack"];

						case 'bool':
						case 'boolean':

							return _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__["BooleanKeyframeTrack"];

						case 'string':

							return _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__["StringKeyframeTrack"];

					}

					throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);

				}

				function parseKeyframeTrack(json) {

					if (json.type === undefined) {

						throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');

					}

					const trackType = getTrackTypeForValueTypeName(json.type);

					if (json.times === undefined) {

						const times = [], values = [];

						_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__["AnimationUtils"].flattenJSON(json.keys, times, values, 'value');

						json.times = times;
						json.values = values;

					}

					// derived classes can define a static parse method
					if (trackType.parse !== undefined) {

						return trackType.parse(json);

					} else {

						// by default, we assume a constructor compatible with the base
						return new trackType(json.name, json.times, json.values, json.interpolation);

					}

				}




				/***/
}),

/***/ "./libs/three/animation/AnimationMixer.js":
/*!************************************************!*\
  !*** ./libs/three/animation/AnimationMixer.js ***!
  \************************************************/
/*! exports provided: AnimationMixer */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function () { return AnimationMixer; });
/* harmony import */ var _AnimationAction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationAction.js */ "./libs/three/animation/AnimationAction.js");
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/EventDispatcher.js */ "./libs/three/core/EventDispatcher.js");
/* harmony import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/interpolants/LinearInterpolant.js */ "./libs/three/math/interpolants/LinearInterpolant.js");
/* harmony import */ var _PropertyBinding_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PropertyBinding.js */ "./libs/three/animation/PropertyBinding.js");
/* harmony import */ var _PropertyMixer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./PropertyMixer.js */ "./libs/three/animation/PropertyMixer.js");
/* harmony import */ var _AnimationClip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AnimationClip.js */ "./libs/three/animation/AnimationClip.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");








				class AnimationMixer extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_1__["EventDispatcher"] {

					constructor(root) {

						super();

						this._root = root;
						this._initMemoryManager();
						this._accuIndex = 0;
						this.time = 0;
						this.timeScale = 1.0;

					}

					_bindAction(action, prototypeAction) {

						const root = action._localRoot || this._root,
							tracks = action._clip.tracks,
							nTracks = tracks.length,
							bindings = action._propertyBindings,
							interpolants = action._interpolants,
							rootUuid = root.uuid,
							bindingsByRoot = this._bindingsByRootAndName;

						let bindingsByName = bindingsByRoot[rootUuid];

						if (bindingsByName === undefined) {

							bindingsByName = {};
							bindingsByRoot[rootUuid] = bindingsByName;

						}

						for (let i = 0; i !== nTracks; ++i) {

							const track = tracks[i],
								trackName = track.name;

							let binding = bindingsByName[trackName];

							if (binding !== undefined) {

								bindings[i] = binding;

							} else {

								binding = bindings[i];

								if (binding !== undefined) {

									// existing binding, make sure the cache knows

									if (binding._cacheIndex === null) {

										++binding.referenceCount;
										this._addInactiveBinding(binding, rootUuid, trackName);

									}

									continue;

								}

								const path = prototypeAction && prototypeAction.
									_propertyBindings[i].binding.parsedPath;

								binding = new _PropertyMixer_js__WEBPACK_IMPORTED_MODULE_4__["PropertyMixer"](
									_PropertyBinding_js__WEBPACK_IMPORTED_MODULE_3__["PropertyBinding"].create(root, trackName, path),
									track.ValueTypeName, track.getValueSize());

								++binding.referenceCount;
								this._addInactiveBinding(binding, rootUuid, trackName);

								bindings[i] = binding;

							}

							interpolants[i].resultBuffer = binding.buffer;

						}

					}

					_activateAction(action) {

						if (!this._isActiveAction(action)) {

							if (action._cacheIndex === null) {

								// this action has been forgotten by the cache, but the user
								// appears to be still using it -> rebind

								const rootUuid = (action._localRoot || this._root).uuid,
									clipUuid = action._clip.uuid,
									actionsForClip = this._actionsByClip[clipUuid];

								this._bindAction(action,
									actionsForClip && actionsForClip.knownActions[0]);

								this._addInactiveAction(action, clipUuid, rootUuid);

							}

							const bindings = action._propertyBindings;

							// increment reference counts / sort out state
							for (let i = 0, n = bindings.length; i !== n; ++i) {

								const binding = bindings[i];

								if (binding.useCount++ === 0) {

									this._lendBinding(binding);
									binding.saveOriginalState();

								}

							}

							this._lendAction(action);

						}

					}

					_deactivateAction(action) {

						if (this._isActiveAction(action)) {

							const bindings = action._propertyBindings;

							// decrement reference counts / sort out state
							for (let i = 0, n = bindings.length; i !== n; ++i) {

								const binding = bindings[i];

								if (--binding.useCount === 0) {

									binding.restoreOriginalState();
									this._takeBackBinding(binding);

								}

							}

							this._takeBackAction(action);

						}

					}

					// Memory manager

					_initMemoryManager() {

						this._actions = []; // 'nActiveActions' followed by inactive ones
						this._nActiveActions = 0;

						this._actionsByClip = {};
						// inside:
						// {
						// 	knownActions: Array< AnimationAction > - used as prototypes
						// 	actionByRoot: AnimationAction - lookup
						// }


						this._bindings = []; // 'nActiveBindings' followed by inactive ones
						this._nActiveBindings = 0;

						this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


						this._controlInterpolants = []; // same game as above
						this._nActiveControlInterpolants = 0;

						const scope = this;

						this.stats = {

							actions: {
								get total() {

									return scope._actions.length;

								},
								get inUse() {

									return scope._nActiveActions;

								}
							},
							bindings: {
								get total() {

									return scope._bindings.length;

								},
								get inUse() {

									return scope._nActiveBindings;

								}
							},
							controlInterpolants: {
								get total() {

									return scope._controlInterpolants.length;

								},
								get inUse() {

									return scope._nActiveControlInterpolants;

								}
							}

						};

					}

					// Memory management for AnimationAction objects

					_isActiveAction(action) {

						const index = action._cacheIndex;
						return index !== null && index < this._nActiveActions;

					}

					_addInactiveAction(action, clipUuid, rootUuid) {

						const actions = this._actions,
							actionsByClip = this._actionsByClip;

						let actionsForClip = actionsByClip[clipUuid];

						if (actionsForClip === undefined) {

							actionsForClip = {

								knownActions: [action],
								actionByRoot: {}

							};

							action._byClipCacheIndex = 0;

							actionsByClip[clipUuid] = actionsForClip;

						} else {

							const knownActions = actionsForClip.knownActions;

							action._byClipCacheIndex = knownActions.length;
							knownActions.push(action);

						}

						action._cacheIndex = actions.length;
						actions.push(action);

						actionsForClip.actionByRoot[rootUuid] = action;

					}

					_removeInactiveAction(action) {

						const actions = this._actions,
							lastInactiveAction = actions[actions.length - 1],
							cacheIndex = action._cacheIndex;

						lastInactiveAction._cacheIndex = cacheIndex;
						actions[cacheIndex] = lastInactiveAction;
						actions.pop();

						action._cacheIndex = null;


						const clipUuid = action._clip.uuid,
							actionsByClip = this._actionsByClip,
							actionsForClip = actionsByClip[clipUuid],
							knownActionsForClip = actionsForClip.knownActions,

							lastKnownAction =
								knownActionsForClip[knownActionsForClip.length - 1],

							byClipCacheIndex = action._byClipCacheIndex;

						lastKnownAction._byClipCacheIndex = byClipCacheIndex;
						knownActionsForClip[byClipCacheIndex] = lastKnownAction;
						knownActionsForClip.pop();

						action._byClipCacheIndex = null;


						const actionByRoot = actionsForClip.actionByRoot,
							rootUuid = (action._localRoot || this._root).uuid;

						delete actionByRoot[rootUuid];

						if (knownActionsForClip.length === 0) {

							delete actionsByClip[clipUuid];

						}

						this._removeInactiveBindingsForAction(action);

					}

					_removeInactiveBindingsForAction(action) {

						const bindings = action._propertyBindings;

						for (let i = 0, n = bindings.length; i !== n; ++i) {

							const binding = bindings[i];

							if (--binding.referenceCount === 0) {

								this._removeInactiveBinding(binding);

							}

						}

					}

					_lendAction(action) {

						// [ active actions |  inactive actions  ]
						// [  active actions >| inactive actions ]
						//                 s        a
						//                  <-swap->
						//                 a        s

						const actions = this._actions,
							prevIndex = action._cacheIndex,

							lastActiveIndex = this._nActiveActions++,

							firstInactiveAction = actions[lastActiveIndex];

						action._cacheIndex = lastActiveIndex;
						actions[lastActiveIndex] = action;

						firstInactiveAction._cacheIndex = prevIndex;
						actions[prevIndex] = firstInactiveAction;

					}

					_takeBackAction(action) {

						// [  active actions  | inactive actions ]
						// [ active actions |< inactive actions  ]
						//        a        s
						//         <-swap->
						//        s        a

						const actions = this._actions,
							prevIndex = action._cacheIndex,

							firstInactiveIndex = --this._nActiveActions,

							lastActiveAction = actions[firstInactiveIndex];

						action._cacheIndex = firstInactiveIndex;
						actions[firstInactiveIndex] = action;

						lastActiveAction._cacheIndex = prevIndex;
						actions[prevIndex] = lastActiveAction;

					}

					// Memory management for PropertyMixer objects

					_addInactiveBinding(binding, rootUuid, trackName) {

						const bindingsByRoot = this._bindingsByRootAndName,
							bindings = this._bindings;

						let bindingByName = bindingsByRoot[rootUuid];

						if (bindingByName === undefined) {

							bindingByName = {};
							bindingsByRoot[rootUuid] = bindingByName;

						}

						bindingByName[trackName] = binding;

						binding._cacheIndex = bindings.length;
						bindings.push(binding);

					}

					_removeInactiveBinding(binding) {

						const bindings = this._bindings,
							propBinding = binding.binding,
							rootUuid = propBinding.rootNode.uuid,
							trackName = propBinding.path,
							bindingsByRoot = this._bindingsByRootAndName,
							bindingByName = bindingsByRoot[rootUuid],

							lastInactiveBinding = bindings[bindings.length - 1],
							cacheIndex = binding._cacheIndex;

						lastInactiveBinding._cacheIndex = cacheIndex;
						bindings[cacheIndex] = lastInactiveBinding;
						bindings.pop();

						delete bindingByName[trackName];

						if (Object.keys(bindingByName).length === 0) {

							delete bindingsByRoot[rootUuid];

						}

					}

					_lendBinding(binding) {

						const bindings = this._bindings,
							prevIndex = binding._cacheIndex,

							lastActiveIndex = this._nActiveBindings++,

							firstInactiveBinding = bindings[lastActiveIndex];

						binding._cacheIndex = lastActiveIndex;
						bindings[lastActiveIndex] = binding;

						firstInactiveBinding._cacheIndex = prevIndex;
						bindings[prevIndex] = firstInactiveBinding;

					}

					_takeBackBinding(binding) {

						const bindings = this._bindings,
							prevIndex = binding._cacheIndex,

							firstInactiveIndex = --this._nActiveBindings,

							lastActiveBinding = bindings[firstInactiveIndex];

						binding._cacheIndex = firstInactiveIndex;
						bindings[firstInactiveIndex] = binding;

						lastActiveBinding._cacheIndex = prevIndex;
						bindings[prevIndex] = lastActiveBinding;

					}


					// Memory management of Interpolants for weight and time scale

					_lendControlInterpolant() {

						const interpolants = this._controlInterpolants,
							lastActiveIndex = this._nActiveControlInterpolants++;

						let interpolant = interpolants[lastActiveIndex];

						if (interpolant === undefined) {

							interpolant = new _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__["LinearInterpolant"](
								new Float32Array(2), new Float32Array(2),
								1, this._controlInterpolantsResultBuffer);

							interpolant.__cacheIndex = lastActiveIndex;
							interpolants[lastActiveIndex] = interpolant;

						}

						return interpolant;

					}

					_takeBackControlInterpolant(interpolant) {

						const interpolants = this._controlInterpolants,
							prevIndex = interpolant.__cacheIndex,

							firstInactiveIndex = --this._nActiveControlInterpolants,

							lastActiveInterpolant = interpolants[firstInactiveIndex];

						interpolant.__cacheIndex = firstInactiveIndex;
						interpolants[firstInactiveIndex] = interpolant;

						lastActiveInterpolant.__cacheIndex = prevIndex;
						interpolants[prevIndex] = lastActiveInterpolant;

					}

					// return an action for a clip optionally using a custom root target
					// object (this method allocates a lot of dynamic memory in case a
					// previously unknown clip/root combination is specified)
					clipAction(clip, optionalRoot = undefined, blendMode = undefined) {

						const root = optionalRoot || this._root,
							rootUuid = root.uuid;

						let clipObject = typeof clip === 'string' ? _AnimationClip_js__WEBPACK_IMPORTED_MODULE_5__["AnimationClip"].findByName(root, clip) : clip;

						const clipUuid = clipObject !== null ? clipObject.uuid : clip;

						const actionsForClip = this._actionsByClip[clipUuid];
						let prototypeAction = null;

						if (blendMode === undefined) {

							if (clipObject !== null) {

								blendMode = clipObject.blendMode;

							} else {

								blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_6__["NormalAnimationBlendMode"];

							}

						}

						if (actionsForClip !== undefined) {

							const existingAction = actionsForClip.actionByRoot[rootUuid];

							if (existingAction !== undefined && existingAction.blendMode === blendMode) {

								return existingAction;

							}

							// we know the clip, so we don't have to parse all
							// the bindings again but can just copy
							prototypeAction = actionsForClip.knownActions[0];

							// also, take the clip from the prototype action
							if (clipObject === null)
								clipObject = prototypeAction._clip;

						}

						// clip must be known when specified via string
						if (clipObject === null) return null;

						// allocate all resources required to run it
						const newAction = new _AnimationAction_js__WEBPACK_IMPORTED_MODULE_0__["AnimationAction"](this, clipObject, optionalRoot, blendMode);

						this._bindAction(newAction, prototypeAction);

						// and make the action known to the memory manager
						this._addInactiveAction(newAction, clipUuid, rootUuid);

						return newAction;

					}

					// get an existing action
					existingAction(clip, optionalRoot) {

						const root = optionalRoot || this._root,
							rootUuid = root.uuid,

							clipObject = typeof clip === 'string' ?
								_AnimationClip_js__WEBPACK_IMPORTED_MODULE_5__["AnimationClip"].findByName(root, clip) : clip,

							clipUuid = clipObject ? clipObject.uuid : clip,

							actionsForClip = this._actionsByClip[clipUuid];

						if (actionsForClip !== undefined) {

							return actionsForClip.actionByRoot[rootUuid] || null;

						}

						return null;

					}

					// deactivates all previously scheduled actions
					stopAllAction() {

						const actions = this._actions,
							nActions = this._nActiveActions;

						for (let i = nActions - 1; i >= 0; --i) {

							actions[i].stop();

						}

						return this;

					}

					// advance the time and update apply the animation
					update(deltaTime) {

						deltaTime *= this.timeScale;

						const actions = this._actions,
							nActions = this._nActiveActions,

							time = this.time += deltaTime,
							timeDirection = Math.sign(deltaTime),

							accuIndex = this._accuIndex ^= 1;

						// run active actions

						for (let i = 0; i !== nActions; ++i) {

							const action = actions[i];

							action._update(time, deltaTime, timeDirection, accuIndex);

						}

						// update scene graph

						const bindings = this._bindings,
							nBindings = this._nActiveBindings;

						for (let i = 0; i !== nBindings; ++i) {

							bindings[i].apply(accuIndex);

						}

						return this;

					}

					// Allows you to seek to a specific time in an animation.
					setTime(timeInSeconds) {

						this.time = 0; // Zero out time attribute for AnimationMixer object;
						for (let i = 0; i < this._actions.length; i++) {

							this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.

						}

						return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.

					}

					// return this mixer's root target object
					getRoot() {

						return this._root;

					}

					// free all resources specific to a particular clip
					uncacheClip(clip) {

						const actions = this._actions,
							clipUuid = clip.uuid,
							actionsByClip = this._actionsByClip,
							actionsForClip = actionsByClip[clipUuid];

						if (actionsForClip !== undefined) {

							// note: just calling _removeInactiveAction would mess up the
							// iteration state and also require updating the state we can
							// just throw away

							const actionsToRemove = actionsForClip.knownActions;

							for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {

								const action = actionsToRemove[i];

								this._deactivateAction(action);

								const cacheIndex = action._cacheIndex,
									lastInactiveAction = actions[actions.length - 1];

								action._cacheIndex = null;
								action._byClipCacheIndex = null;

								lastInactiveAction._cacheIndex = cacheIndex;
								actions[cacheIndex] = lastInactiveAction;
								actions.pop();

								this._removeInactiveBindingsForAction(action);

							}

							delete actionsByClip[clipUuid];

						}

					}

					// free all resources specific to a particular root target object
					uncacheRoot(root) {

						const rootUuid = root.uuid,
							actionsByClip = this._actionsByClip;

						for (const clipUuid in actionsByClip) {

							const actionByRoot = actionsByClip[clipUuid].actionByRoot,
								action = actionByRoot[rootUuid];

							if (action !== undefined) {

								this._deactivateAction(action);
								this._removeInactiveAction(action);

							}

						}

						const bindingsByRoot = this._bindingsByRootAndName,
							bindingByName = bindingsByRoot[rootUuid];

						if (bindingByName !== undefined) {

							for (const trackName in bindingByName) {

								const binding = bindingByName[trackName];
								binding.restoreOriginalState();
								this._removeInactiveBinding(binding);

							}

						}

					}

					// remove a targeted clip from the cache
					uncacheAction(clip, optionalRoot) {

						const action = this.existingAction(clip, optionalRoot);

						if (action !== null) {

							this._deactivateAction(action);
							this._removeInactiveAction(action);

						}

					}

				}

				AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);




				/***/
}),

/***/ "./libs/three/animation/AnimationUtils.js":
/*!************************************************!*\
  !*** ./libs/three/animation/AnimationUtils.js ***!
  \************************************************/
/*! exports provided: AnimationUtils */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function () { return AnimationUtils; });
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Quaternion.js */ "./libs/three/math/Quaternion.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");



				const AnimationUtils = {

					// same as Array.prototype.slice, but also works on typed arrays
					arraySlice: function (array, from, to) {

						if (AnimationUtils.isTypedArray(array)) {

							// in ios9 array.subarray(from, undefined) will return empty array
							// but array.subarray(from) or array.subarray(from, len) is correct
							return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));

						}

						return array.slice(from, to);

					},

					// converts an array to a specific type
					convertArray: function (array, type, forceClone) {

						if (!array || // let 'undefined' and 'null' pass
							!forceClone && array.constructor === type) return array;

						if (typeof type.BYTES_PER_ELEMENT === 'number') {

							return new type(array); // create typed array

						}

						return Array.prototype.slice.call(array); // create Array

					},

					isTypedArray: function (object) {

						return ArrayBuffer.isView(object) &&
							!(object instanceof DataView);

					},

					// returns an array by which times and values can be sorted
					getKeyframeOrder: function (times) {

						function compareTime(i, j) {

							return times[i] - times[j];

						}

						const n = times.length;
						const result = new Array(n);
						for (let i = 0; i !== n; ++i) result[i] = i;

						result.sort(compareTime);

						return result;

					},

					// uses the array previously returned by 'getKeyframeOrder' to sort data
					sortedArray: function (values, stride, order) {

						const nValues = values.length;
						const result = new values.constructor(nValues);

						for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {

							const srcOffset = order[i] * stride;

							for (let j = 0; j !== stride; ++j) {

								result[dstOffset++] = values[srcOffset + j];

							}

						}

						return result;

					},

					// function for parsing AOS keyframe formats
					flattenJSON: function (jsonKeys, times, values, valuePropertyName) {

						let i = 1, key = jsonKeys[0];

						while (key !== undefined && key[valuePropertyName] === undefined) {

							key = jsonKeys[i++];

						}

						if (key === undefined) return; // no data

						let value = key[valuePropertyName];
						if (value === undefined) return; // no data

						if (Array.isArray(value)) {

							do {

								value = key[valuePropertyName];

								if (value !== undefined) {

									times.push(key.time);
									values.push.apply(values, value); // push all elements

								}

								key = jsonKeys[i++];

							} while (key !== undefined);

						} else if (value.toArray !== undefined) {

							// ...assume THREE.Math-ish

							do {

								value = key[valuePropertyName];

								if (value !== undefined) {

									times.push(key.time);
									value.toArray(values, values.length);

								}

								key = jsonKeys[i++];

							} while (key !== undefined);

						} else {

							// otherwise push as-is

							do {

								value = key[valuePropertyName];

								if (value !== undefined) {

									times.push(key.time);
									values.push(value);

								}

								key = jsonKeys[i++];

							} while (key !== undefined);

						}

					},

					subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {

						const clip = sourceClip.clone();

						clip.name = name;

						const tracks = [];

						for (let i = 0; i < clip.tracks.length; ++i) {

							const track = clip.tracks[i];
							const valueSize = track.getValueSize();

							const times = [];
							const values = [];

							for (let j = 0; j < track.times.length; ++j) {

								const frame = track.times[j] * fps;

								if (frame < startFrame || frame >= endFrame) continue;

								times.push(track.times[j]);

								for (let k = 0; k < valueSize; ++k) {

									values.push(track.values[j * valueSize + k]);

								}

							}

							if (times.length === 0) continue;

							track.times = AnimationUtils.convertArray(times, track.times.constructor);
							track.values = AnimationUtils.convertArray(values, track.values.constructor);

							tracks.push(track);

						}

						clip.tracks = tracks;

						// find minimum .times value across all tracks in the trimmed clip

						let minStartTime = Infinity;

						for (let i = 0; i < clip.tracks.length; ++i) {

							if (minStartTime > clip.tracks[i].times[0]) {

								minStartTime = clip.tracks[i].times[0];

							}

						}

						// shift all tracks such that clip begins at t=0

						for (let i = 0; i < clip.tracks.length; ++i) {

							clip.tracks[i].shift(- 1 * minStartTime);

						}

						clip.resetDuration();

						return clip;

					},

					makeClipAdditive: function (targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {

						if (fps <= 0) fps = 30;

						const numTracks = referenceClip.tracks.length;
						const referenceTime = referenceFrame / fps;

						// Make each track's values relative to the values at the reference frame
						for (let i = 0; i < numTracks; ++i) {

							const referenceTrack = referenceClip.tracks[i];
							const referenceTrackType = referenceTrack.ValueTypeName;

							// Skip this track if it's non-numeric
							if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;

							// Find the track in the target clip whose name and type matches the reference track
							const targetTrack = targetClip.tracks.find(function (track) {

								return track.name === referenceTrack.name
									&& track.ValueTypeName === referenceTrackType;

							});

							if (targetTrack === undefined) continue;

							let referenceOffset = 0;
							const referenceValueSize = referenceTrack.getValueSize();

							if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {

								referenceOffset = referenceValueSize / 3;

							}

							let targetOffset = 0;
							const targetValueSize = targetTrack.getValueSize();

							if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {

								targetOffset = targetValueSize / 3;

							}

							const lastIndex = referenceTrack.times.length - 1;
							let referenceValue;

							// Find the value to subtract out of the track
							if (referenceTime <= referenceTrack.times[0]) {

								// Reference frame is earlier than the first keyframe, so just use the first keyframe
								const startIndex = referenceOffset;
								const endIndex = referenceValueSize - referenceOffset;
								referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);

							} else if (referenceTime >= referenceTrack.times[lastIndex]) {

								// Reference frame is after the last keyframe, so just use the last keyframe
								const startIndex = lastIndex * referenceValueSize + referenceOffset;
								const endIndex = startIndex + referenceValueSize - referenceOffset;
								referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);

							} else {

								// Interpolate to the reference value
								const interpolant = referenceTrack.createInterpolant();
								const startIndex = referenceOffset;
								const endIndex = referenceValueSize - referenceOffset;
								interpolant.evaluate(referenceTime);
								referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);

							}

							// Conjugate the quaternion
							if (referenceTrackType === 'quaternion') {

								const referenceQuat = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]().fromArray(referenceValue).normalize().conjugate();
								referenceQuat.toArray(referenceValue);

							}

							// Subtract the reference value from all of the track values

							const numTimes = targetTrack.times.length;
							for (let j = 0; j < numTimes; ++j) {

								const valueStart = j * targetValueSize + targetOffset;

								if (referenceTrackType === 'quaternion') {

									// Multiply the conjugate for quaternion track types
									_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].multiplyQuaternionsFlat(
										targetTrack.values,
										valueStart,
										referenceValue,
										0,
										targetTrack.values,
										valueStart
									);

								} else {

									const valueEnd = targetValueSize - targetOffset * 2;

									// Subtract each value for all other numeric track types
									for (let k = 0; k < valueEnd; ++k) {

										targetTrack.values[valueStart + k] -= referenceValue[k];

									}

								}

							}

						}

						targetClip.blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_1__["AdditiveAnimationBlendMode"];

						return targetClip;

					}

				};




				/***/
}),

/***/ "./libs/three/animation/KeyframeTrack.js":
/*!***********************************************!*\
  !*** ./libs/three/animation/KeyframeTrack.js ***!
  \***********************************************/
/*! exports provided: KeyframeTrack */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function () { return KeyframeTrack; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/interpolants/CubicInterpolant.js */ "./libs/three/math/interpolants/CubicInterpolant.js");
/* harmony import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/interpolants/LinearInterpolant.js */ "./libs/three/math/interpolants/LinearInterpolant.js");
/* harmony import */ var _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/interpolants/DiscreteInterpolant.js */ "./libs/three/math/interpolants/DiscreteInterpolant.js");
/* harmony import */ var _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimationUtils.js */ "./libs/three/animation/AnimationUtils.js");






				class KeyframeTrack {

					constructor(name, times, values, interpolation) {

						if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
						if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);

						this.name = name;

						this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].convertArray(times, this.TimeBufferType);
						this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].convertArray(values, this.ValueBufferType);

						this.setInterpolation(interpolation || this.DefaultInterpolation);

					}

					// Serialization (in static context, because of constructor invocation
					// and automatic invocation of .toJSON):

					static toJSON(track) {

						const trackType = track.constructor;

						let json;

						// derived classes can define a static toJSON method
						if (trackType.toJSON !== this.toJSON) {

							json = trackType.toJSON(track);

						} else {

							// by default, we assume the data can be serialized as-is
							json = {

								'name': track.name,
								'times': _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].convertArray(track.times, Array),
								'values': _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].convertArray(track.values, Array)

							};

							const interpolation = track.getInterpolation();

							if (interpolation !== track.DefaultInterpolation) {

								json.interpolation = interpolation;

							}

						}

						json.type = track.ValueTypeName; // mandatory

						return json;

					}

					InterpolantFactoryMethodDiscrete(result) {

						return new _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_3__["DiscreteInterpolant"](this.times, this.values, this.getValueSize(), result);

					}

					InterpolantFactoryMethodLinear(result) {

						return new _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__["LinearInterpolant"](this.times, this.values, this.getValueSize(), result);

					}

					InterpolantFactoryMethodSmooth(result) {

						return new _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_1__["CubicInterpolant"](this.times, this.values, this.getValueSize(), result);

					}

					setInterpolation(interpolation) {

						let factoryMethod;

						switch (interpolation) {

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"]:

								factoryMethod = this.InterpolantFactoryMethodDiscrete;

								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"]:

								factoryMethod = this.InterpolantFactoryMethodLinear;

								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateSmooth"]:

								factoryMethod = this.InterpolantFactoryMethodSmooth;

								break;

						}

						if (factoryMethod === undefined) {

							const message = 'unsupported interpolation for ' +
								this.ValueTypeName + ' keyframe track named ' + this.name;

							if (this.createInterpolant === undefined) {

								// fall back to default, unless the default itself is messed up
								if (interpolation !== this.DefaultInterpolation) {

									this.setInterpolation(this.DefaultInterpolation);

								} else {

									throw new Error(message); // fatal, in this case

								}

							}

							console.warn('THREE.KeyframeTrack:', message);
							return this;

						}

						this.createInterpolant = factoryMethod;

						return this;

					}

					getInterpolation() {

						switch (this.createInterpolant) {

							case this.InterpolantFactoryMethodDiscrete:

								return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"];

							case this.InterpolantFactoryMethodLinear:

								return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"];

							case this.InterpolantFactoryMethodSmooth:

								return _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateSmooth"];

						}

					}

					getValueSize() {

						return this.values.length / this.times.length;

					}

					// move all keyframes either forwards or backwards in time
					shift(timeOffset) {

						if (timeOffset !== 0.0) {

							const times = this.times;

							for (let i = 0, n = times.length; i !== n; ++i) {

								times[i] += timeOffset;

							}

						}

						return this;

					}

					// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
					scale(timeScale) {

						if (timeScale !== 1.0) {

							const times = this.times;

							for (let i = 0, n = times.length; i !== n; ++i) {

								times[i] *= timeScale;

							}

						}

						return this;

					}

					// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
					// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
					trim(startTime, endTime) {

						const times = this.times,
							nKeys = times.length;

						let from = 0,
							to = nKeys - 1;

						while (from !== nKeys && times[from] < startTime) {

							++from;

						}

						while (to !== - 1 && times[to] > endTime) {

							--to;

						}

						++to; // inclusive -> exclusive bound

						if (from !== 0 || to !== nKeys) {

							// empty tracks are forbidden, so keep at least one keyframe
							if (from >= to) {

								to = Math.max(to, 1);
								from = to - 1;

							}

							const stride = this.getValueSize();
							this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice(times, from, to);
							this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice(this.values, from * stride, to * stride);

						}

						return this;

					}

					// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
					validate() {

						let valid = true;

						const valueSize = this.getValueSize();
						if (valueSize - Math.floor(valueSize) !== 0) {

							console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
							valid = false;

						}

						const times = this.times,
							values = this.values,

							nKeys = times.length;

						if (nKeys === 0) {

							console.error('THREE.KeyframeTrack: Track is empty.', this);
							valid = false;

						}

						let prevTime = null;

						for (let i = 0; i !== nKeys; i++) {

							const currTime = times[i];

							if (typeof currTime === 'number' && isNaN(currTime)) {

								console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
								valid = false;
								break;

							}

							if (prevTime !== null && prevTime > currTime) {

								console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
								valid = false;
								break;

							}

							prevTime = currTime;

						}

						if (values !== undefined) {

							if (_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].isTypedArray(values)) {

								for (let i = 0, n = values.length; i !== n; ++i) {

									const value = values[i];

									if (isNaN(value)) {

										console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
										valid = false;
										break;

									}

								}

							}

						}

						return valid;

					}

					// removes equivalent sequential keys as common in morph target sequences
					// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
					optimize() {

						// times or values may be shared with other tracks, so overwriting is unsafe
						const times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice(this.times),
							values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice(this.values),
							stride = this.getValueSize(),

							smoothInterpolation = this.getInterpolation() === _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateSmooth"],

							lastIndex = times.length - 1;

						let writeIndex = 1;

						for (let i = 1; i < lastIndex; ++i) {

							let keep = false;

							const time = times[i];
							const timeNext = times[i + 1];

							// remove adjacent keyframes scheduled at the same time

							if (time !== timeNext && (i !== 1 || time !== times[0])) {

								if (!smoothInterpolation) {

									// remove unnecessary keyframes same as their neighbors

									const offset = i * stride,
										offsetP = offset - stride,
										offsetN = offset + stride;

									for (let j = 0; j !== stride; ++j) {

										const value = values[offset + j];

										if (value !== values[offsetP + j] ||
											value !== values[offsetN + j]) {

											keep = true;
											break;

										}

									}

								} else {

									keep = true;

								}

							}

							// in-place compaction

							if (keep) {

								if (i !== writeIndex) {

									times[writeIndex] = times[i];

									const readOffset = i * stride,
										writeOffset = writeIndex * stride;

									for (let j = 0; j !== stride; ++j) {

										values[writeOffset + j] = values[readOffset + j];

									}

								}

								++writeIndex;

							}

						}

						// flush last keyframe (compaction looks ahead)

						if (lastIndex > 0) {

							times[writeIndex] = times[lastIndex];

							for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {

								values[writeOffset + j] = values[readOffset + j];

							}

							++writeIndex;

						}

						if (writeIndex !== times.length) {

							this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice(times, 0, writeIndex);
							this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice(values, 0, writeIndex * stride);

						} else {

							this.times = times;
							this.values = values;

						}

						return this;

					}

					clone() {

						const times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice(this.times, 0);
						const values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__["AnimationUtils"].arraySlice(this.values, 0);

						const TypedKeyframeTrack = this.constructor;
						const track = new TypedKeyframeTrack(this.name, times, values);

						// Interpolant argument to constructor is not saved, so copy the factory method directly.
						track.createInterpolant = this.createInterpolant;

						return track;

					}

				}

				KeyframeTrack.prototype.TimeBufferType = Float32Array;
				KeyframeTrack.prototype.ValueBufferType = Float32Array;
				KeyframeTrack.prototype.DefaultInterpolation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"];




				/***/
}),

/***/ "./libs/three/animation/PropertyBinding.js":
/*!*************************************************!*\
  !*** ./libs/three/animation/PropertyBinding.js ***!
  \*************************************************/
/*! exports provided: PropertyBinding */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function () { return PropertyBinding; });
				// Characters [].:/ are reserved for track binding syntax.
				const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
				const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');

				// Attempts to allow node names from any language. ES5's `\w` regexp matches
				// only latin characters, and the unicode \p{L} is not yet supported. So
				// instead, we exclude reserved characters and match everything else.
				const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
				const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';

				// Parent directories, delimited by '/' or ':'. Currently unused, but must
				// be matched to parse the rest of the track name.
				const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);

				// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
				const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);

				// Object on target node, and accessor. May not contain reserved
				// characters. Accessor may contain any character except closing bracket.
				const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);

				// Property and accessor. May not contain reserved characters. Accessor may
				// contain any non-bracket characters.
				const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);

				const _trackRe = new RegExp(''
					+ '^'
					+ _directoryRe
					+ _nodeRe
					+ _objectRe
					+ _propertyRe
					+ '$'
				);

				const _supportedObjectNames = ['material', 'materials', 'bones'];

				class Composite {

					constructor(targetGroup, path, optionalParsedPath) {

						const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);

						this._targetGroup = targetGroup;
						this._bindings = targetGroup.subscribe_(path, parsedPath);

					}

					getValue(array, offset) {

						this.bind(); // bind all binding

						const firstValidIndex = this._targetGroup.nCachedObjects_,
							binding = this._bindings[firstValidIndex];

						// and only call .getValue on the first
						if (binding !== undefined) binding.getValue(array, offset);

					}

					setValue(array, offset) {

						const bindings = this._bindings;

						for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

							bindings[i].setValue(array, offset);

						}

					}

					bind() {

						const bindings = this._bindings;

						for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

							bindings[i].bind();

						}

					}

					unbind() {

						const bindings = this._bindings;

						for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {

							bindings[i].unbind();

						}

					}

				}

				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.
				class PropertyBinding {

					constructor(rootNode, path, parsedPath) {

						this.path = path;
						this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);

						this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;

						this.rootNode = rootNode;

						// initial state of these methods that calls 'bind'
						this.getValue = this._getValue_unbound;
						this.setValue = this._setValue_unbound;

					}


					static create(root, path, parsedPath) {

						if (!(root && root.isAnimationObjectGroup)) {

							return new PropertyBinding(root, path, parsedPath);

						} else {

							return new PropertyBinding.Composite(root, path, parsedPath);

						}

					}

					/**
					 * Replaces spaces with underscores and removes unsupported characters from
					 * node names, to ensure compatibility with parseTrackName().
					 *
					 * @param {string} name Node name to be sanitized.
					 * @return {string}
					 */
					static sanitizeNodeName(name) {

						return name.replace(/\s/g, '_').replace(_reservedRe, '');

					}

					static parseTrackName(trackName) {

						const matches = _trackRe.exec(trackName);

						if (!matches) {

							throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);

						}

						const results = {
							// directoryName: matches[ 1 ], // (tschw) currently unused
							nodeName: matches[2],
							objectName: matches[3],
							objectIndex: matches[4],
							propertyName: matches[5], // required
							propertyIndex: matches[6]
						};

						const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');

						if (lastDot !== undefined && lastDot !== - 1) {

							const objectName = results.nodeName.substring(lastDot + 1);

							// Object names must be checked against an allowlist. Otherwise, there
							// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
							// 'bar' could be the objectName, or part of a nodeName (which can
							// include '.' characters).
							if (_supportedObjectNames.indexOf(objectName) !== - 1) {

								results.nodeName = results.nodeName.substring(0, lastDot);
								results.objectName = objectName;

							}

						}

						if (results.propertyName === null || results.propertyName.length === 0) {

							throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);

						}

						return results;

					}

					static findNode(root, nodeName) {

						if (!nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid) {

							return root;

						}

						// search into skeleton bones.
						if (root.skeleton) {

							const bone = root.skeleton.getBoneByName(nodeName);

							if (bone !== undefined) {

								return bone;

							}

						}

						// search into node subtree.
						if (root.children) {

							const searchNodeSubtree = function (children) {

								for (let i = 0; i < children.length; i++) {

									const childNode = children[i];

									if (childNode.name === nodeName || childNode.uuid === nodeName) {

										return childNode;

									}

									const result = searchNodeSubtree(childNode.children);

									if (result) return result;

								}

								return null;

							};

							const subTreeNode = searchNodeSubtree(root.children);

							if (subTreeNode) {

								return subTreeNode;

							}

						}

						return null;

					}

					// these are used to "bind" a nonexistent property
					_getValue_unavailable() { }
					_setValue_unavailable() { }

					// Getters

					_getValue_direct(buffer, offset) {

						buffer[offset] = this.targetObject[this.propertyName];

					}

					_getValue_array(buffer, offset) {

						const source = this.resolvedProperty;

						for (let i = 0, n = source.length; i !== n; ++i) {

							buffer[offset++] = source[i];

						}

					}

					_getValue_arrayElement(buffer, offset) {

						buffer[offset] = this.resolvedProperty[this.propertyIndex];

					}

					_getValue_toArray(buffer, offset) {

						this.resolvedProperty.toArray(buffer, offset);

					}

					// Direct

					_setValue_direct(buffer, offset) {

						this.targetObject[this.propertyName] = buffer[offset];

					}

					_setValue_direct_setNeedsUpdate(buffer, offset) {

						this.targetObject[this.propertyName] = buffer[offset];
						this.targetObject.needsUpdate = true;

					}

					_setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {

						this.targetObject[this.propertyName] = buffer[offset];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

					// EntireArray

					_setValue_array(buffer, offset) {

						const dest = this.resolvedProperty;

						for (let i = 0, n = dest.length; i !== n; ++i) {

							dest[i] = buffer[offset++];

						}

					}

					_setValue_array_setNeedsUpdate(buffer, offset) {

						const dest = this.resolvedProperty;

						for (let i = 0, n = dest.length; i !== n; ++i) {

							dest[i] = buffer[offset++];

						}

						this.targetObject.needsUpdate = true;

					}

					_setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {

						const dest = this.resolvedProperty;

						for (let i = 0, n = dest.length; i !== n; ++i) {

							dest[i] = buffer[offset++];

						}

						this.targetObject.matrixWorldNeedsUpdate = true;

					}

					// ArrayElement

					_setValue_arrayElement(buffer, offset) {

						this.resolvedProperty[this.propertyIndex] = buffer[offset];

					}

					_setValue_arrayElement_setNeedsUpdate(buffer, offset) {

						this.resolvedProperty[this.propertyIndex] = buffer[offset];
						this.targetObject.needsUpdate = true;

					}

					_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {

						this.resolvedProperty[this.propertyIndex] = buffer[offset];
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

					// HasToFromArray

					_setValue_fromArray(buffer, offset) {

						this.resolvedProperty.fromArray(buffer, offset);

					}

					_setValue_fromArray_setNeedsUpdate(buffer, offset) {

						this.resolvedProperty.fromArray(buffer, offset);
						this.targetObject.needsUpdate = true;

					}

					_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {

						this.resolvedProperty.fromArray(buffer, offset);
						this.targetObject.matrixWorldNeedsUpdate = true;

					}

					_getValue_unbound(targetArray, offset) {

						this.bind();
						this.getValue(targetArray, offset);

					}

					_setValue_unbound(sourceArray, offset) {

						this.bind();
						this.setValue(sourceArray, offset);

					}

					// create getter / setter pair for a property in the scene graph
					bind() {

						let targetObject = this.node;
						const parsedPath = this.parsedPath;

						const objectName = parsedPath.objectName;
						const propertyName = parsedPath.propertyName;
						let propertyIndex = parsedPath.propertyIndex;

						if (!targetObject) {

							targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;

							this.node = targetObject;

						}

						// set fail state so we can just 'return' on error
						this.getValue = this._getValue_unavailable;
						this.setValue = this._setValue_unavailable;

						// ensure there is a value node
						if (!targetObject) {

							console.error('THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.');
							return;

						}

						if (objectName) {

							let objectIndex = parsedPath.objectIndex;

							// special cases were we need to reach deeper into the hierarchy to get the face materials....
							switch (objectName) {

								case 'materials':

									if (!targetObject.material) {

										console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
										return;

									}

									if (!targetObject.material.materials) {

										console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
										return;

									}

									targetObject = targetObject.material.materials;

									break;

								case 'bones':

									if (!targetObject.skeleton) {

										console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
										return;

									}

									// potential future optimization: skip this if propertyIndex is already an integer
									// and convert the integer string to a true integer.

									targetObject = targetObject.skeleton.bones;

									// support resolving morphTarget names into indices.
									for (let i = 0; i < targetObject.length; i++) {

										if (targetObject[i].name === objectIndex) {

											objectIndex = i;
											break;

										}

									}

									break;

								default:

									if (targetObject[objectName] === undefined) {

										console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
										return;

									}

									targetObject = targetObject[objectName];

							}


							if (objectIndex !== undefined) {

								if (targetObject[objectIndex] === undefined) {

									console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
									return;

								}

								targetObject = targetObject[objectIndex];

							}

						}

						// resolve property
						const nodeProperty = targetObject[propertyName];

						if (nodeProperty === undefined) {

							const nodeName = parsedPath.nodeName;

							console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
								'.' + propertyName + ' but it wasn\'t found.', targetObject);
							return;

						}

						// determine versioning scheme
						let versioning = this.Versioning.None;

						this.targetObject = targetObject;

						if (targetObject.needsUpdate !== undefined) { // material

							versioning = this.Versioning.NeedsUpdate;

						} else if (targetObject.matrixWorldNeedsUpdate !== undefined) { // node transform

							versioning = this.Versioning.MatrixWorldNeedsUpdate;

						}

						// determine how the property gets bound
						let bindingType = this.BindingType.Direct;

						if (propertyIndex !== undefined) {

							// access a sub element of the property array (only primitives are supported right now)

							if (propertyName === 'morphTargetInfluences') {

								// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

								// support resolving morphTarget names into indices.
								if (!targetObject.geometry) {

									console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
									return;

								}

								if (targetObject.geometry.isBufferGeometry) {

									if (!targetObject.geometry.morphAttributes) {

										console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
										return;

									}

									if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {

										propertyIndex = targetObject.morphTargetDictionary[propertyIndex];

									}


								} else {

									console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this);
									return;

								}

							}

							bindingType = this.BindingType.ArrayElement;

							this.resolvedProperty = nodeProperty;
							this.propertyIndex = propertyIndex;

						} else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {

							// must use copy for Object3D.Euler/Quaternion

							bindingType = this.BindingType.HasFromToArray;

							this.resolvedProperty = nodeProperty;

						} else if (Array.isArray(nodeProperty)) {

							bindingType = this.BindingType.EntireArray;

							this.resolvedProperty = nodeProperty;

						} else {

							this.propertyName = propertyName;

						}

						// select getter / setter
						this.getValue = this.GetterByBindingType[bindingType];
						this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];

					}

					unbind() {

						this.node = null;

						// back to the prototype version of getValue / setValue
						// note: avoiding to mutate the shape of 'this' via 'delete'
						this.getValue = this._getValue_unbound;
						this.setValue = this._setValue_unbound;

					}

				}

				PropertyBinding.Composite = Composite;

				PropertyBinding.prototype.BindingType = {
					Direct: 0,
					EntireArray: 1,
					ArrayElement: 2,
					HasFromToArray: 3
				};

				PropertyBinding.prototype.Versioning = {
					None: 0,
					NeedsUpdate: 1,
					MatrixWorldNeedsUpdate: 2
				};

				PropertyBinding.prototype.GetterByBindingType = [

					PropertyBinding.prototype._getValue_direct,
					PropertyBinding.prototype._getValue_array,
					PropertyBinding.prototype._getValue_arrayElement,
					PropertyBinding.prototype._getValue_toArray,

				];

				PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

					[
						// Direct
						PropertyBinding.prototype._setValue_direct,
						PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
						PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

					], [

						// EntireArray

						PropertyBinding.prototype._setValue_array,
						PropertyBinding.prototype._setValue_array_setNeedsUpdate,
						PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

					], [

						// ArrayElement
						PropertyBinding.prototype._setValue_arrayElement,
						PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
						PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

					], [

						// HasToFromArray
						PropertyBinding.prototype._setValue_fromArray,
						PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
						PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

					]

				];





				/***/
}),

/***/ "./libs/three/animation/PropertyMixer.js":
/*!***********************************************!*\
  !*** ./libs/three/animation/PropertyMixer.js ***!
  \***********************************************/
/*! exports provided: PropertyMixer */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function () { return PropertyMixer; });
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Quaternion.js */ "./libs/three/math/Quaternion.js");


				class PropertyMixer {

					constructor(binding, typeName, valueSize) {

						this.binding = binding;
						this.valueSize = valueSize;

						let mixFunction,
							mixFunctionAdditive,
							setIdentity;

						// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
						//
						// interpolators can use .buffer as their .result
						// the data then goes to 'incoming'
						//
						// 'accu0' and 'accu1' are used frame-interleaved for
						// the cumulative result and are compared to detect
						// changes
						//
						// 'orig' stores the original state of the property
						//
						// 'add' is used for additive cumulative results
						//
						// 'work' is optional and is only present for quaternion types. It is used
						// to store intermediate quaternion multiplication results

						switch (typeName) {

							case 'quaternion':
								mixFunction = this._slerp;
								mixFunctionAdditive = this._slerpAdditive;
								setIdentity = this._setAdditiveIdentityQuaternion;

								this.buffer = new Float64Array(valueSize * 6);
								this._workIndex = 5;
								break;

							case 'string':
							case 'bool':
								mixFunction = this._select;

								// Use the regular mix function and for additive on these types,
								// additive is not relevant for non-numeric types
								mixFunctionAdditive = this._select;

								setIdentity = this._setAdditiveIdentityOther;

								this.buffer = new Array(valueSize * 5);
								break;

							default:
								mixFunction = this._lerp;
								mixFunctionAdditive = this._lerpAdditive;
								setIdentity = this._setAdditiveIdentityNumeric;

								this.buffer = new Float64Array(valueSize * 5);

						}

						this._mixBufferRegion = mixFunction;
						this._mixBufferRegionAdditive = mixFunctionAdditive;
						this._setIdentity = setIdentity;
						this._origIndex = 3;
						this._addIndex = 4;

						this.cumulativeWeight = 0;
						this.cumulativeWeightAdditive = 0;

						this.useCount = 0;
						this.referenceCount = 0;

					}

					// accumulate data in the 'incoming' region into 'accu<i>'
					accumulate(accuIndex, weight) {

						// note: happily accumulating nothing when weight = 0, the caller knows
						// the weight and shouldn't have made the call in the first place

						const buffer = this.buffer,
							stride = this.valueSize,
							offset = accuIndex * stride + stride;

						let currentWeight = this.cumulativeWeight;

						if (currentWeight === 0) {

							// accuN := incoming * weight

							for (let i = 0; i !== stride; ++i) {

								buffer[offset + i] = buffer[i];

							}

							currentWeight = weight;

						} else {

							// accuN := accuN + incoming * weight

							currentWeight += weight;
							const mix = weight / currentWeight;
							this._mixBufferRegion(buffer, offset, 0, mix, stride);

						}

						this.cumulativeWeight = currentWeight;

					}

					// accumulate data in the 'incoming' region into 'add'
					accumulateAdditive(weight) {

						const buffer = this.buffer,
							stride = this.valueSize,
							offset = stride * this._addIndex;

						if (this.cumulativeWeightAdditive === 0) {

							// add = identity

							this._setIdentity();

						}

						// add := add + incoming * weight

						this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
						this.cumulativeWeightAdditive += weight;

					}

					// apply the state of 'accu<i>' to the binding when accus differ
					apply(accuIndex) {

						const stride = this.valueSize,
							buffer = this.buffer,
							offset = accuIndex * stride + stride,

							weight = this.cumulativeWeight,
							weightAdditive = this.cumulativeWeightAdditive,

							binding = this.binding;

						this.cumulativeWeight = 0;
						this.cumulativeWeightAdditive = 0;

						if (weight < 1) {

							// accuN := accuN + original * ( 1 - cumulativeWeight )

							const originalValueOffset = stride * this._origIndex;

							this._mixBufferRegion(
								buffer, offset, originalValueOffset, 1 - weight, stride);

						}

						if (weightAdditive > 0) {

							// accuN := accuN + additive accuN

							this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);

						}

						for (let i = stride, e = stride + stride; i !== e; ++i) {

							if (buffer[i] !== buffer[i + stride]) {

								// value has changed -> update scene graph

								binding.setValue(buffer, offset);
								break;

							}

						}

					}

					// remember the state of the bound property and copy it to both accus
					saveOriginalState() {

						const binding = this.binding;

						const buffer = this.buffer,
							stride = this.valueSize,

							originalValueOffset = stride * this._origIndex;

						binding.getValue(buffer, originalValueOffset);

						// accu[0..1] := orig -- initially detect changes against the original
						for (let i = stride, e = originalValueOffset; i !== e; ++i) {

							buffer[i] = buffer[originalValueOffset + (i % stride)];

						}

						// Add to identity for additive
						this._setIdentity();

						this.cumulativeWeight = 0;
						this.cumulativeWeightAdditive = 0;

					}

					// apply the state previously taken via 'saveOriginalState' to the binding
					restoreOriginalState() {

						const originalValueOffset = this.valueSize * 3;
						this.binding.setValue(this.buffer, originalValueOffset);

					}

					_setAdditiveIdentityNumeric() {

						const startIndex = this._addIndex * this.valueSize;
						const endIndex = startIndex + this.valueSize;

						for (let i = startIndex; i < endIndex; i++) {

							this.buffer[i] = 0;

						}

					}

					_setAdditiveIdentityQuaternion() {

						this._setAdditiveIdentityNumeric();
						this.buffer[this._addIndex * this.valueSize + 3] = 1;

					}

					_setAdditiveIdentityOther() {

						const startIndex = this._origIndex * this.valueSize;
						const targetIndex = this._addIndex * this.valueSize;

						for (let i = 0; i < this.valueSize; i++) {

							this.buffer[targetIndex + i] = this.buffer[startIndex + i];

						}

					}


					// mix functions

					_select(buffer, dstOffset, srcOffset, t, stride) {

						if (t >= 0.5) {

							for (let i = 0; i !== stride; ++i) {

								buffer[dstOffset + i] = buffer[srcOffset + i];

							}

						}

					}

					_slerp(buffer, dstOffset, srcOffset, t) {

						_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);

					}

					_slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {

						const workOffset = this._workIndex * stride;

						// Store result in intermediate buffer offset
						_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);

						// Slerp to the intermediate result
						_math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"].slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);

					}

					_lerp(buffer, dstOffset, srcOffset, t, stride) {

						const s = 1 - t;

						for (let i = 0; i !== stride; ++i) {

							const j = dstOffset + i;

							buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;

						}

					}

					_lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {

						for (let i = 0; i !== stride; ++i) {

							const j = dstOffset + i;

							buffer[j] = buffer[j] + buffer[srcOffset + i] * t;

						}

					}

				}





				/***/
}),

/***/ "./libs/three/animation/tracks/BooleanKeyframeTrack.js":
/*!*************************************************************!*\
  !*** ./libs/three/animation/tracks/BooleanKeyframeTrack.js ***!
  \*************************************************************/
/*! exports provided: BooleanKeyframeTrack */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function () { return BooleanKeyframeTrack; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./libs/three/animation/KeyframeTrack.js");



				/**
				 * A Track of Boolean keyframe values.
				 */
				class BooleanKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__["KeyframeTrack"] { }

				BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
				BooleanKeyframeTrack.prototype.ValueBufferType = Array;
				BooleanKeyframeTrack.prototype.DefaultInterpolation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"];
				BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
				BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

				// Note: Actually this track could have a optimized / compressed
				// representation of a single value and a custom interpolant that
				// computes "firstValue ^ isOdd( index )".




				/***/
}),

/***/ "./libs/three/animation/tracks/ColorKeyframeTrack.js":
/*!***********************************************************!*\
  !*** ./libs/three/animation/tracks/ColorKeyframeTrack.js ***!
  \***********************************************************/
/*! exports provided: ColorKeyframeTrack */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function () { return ColorKeyframeTrack; });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./libs/three/animation/KeyframeTrack.js");


				/**
				 * A Track of keyframe values that represent color.
				 */
				class ColorKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__["KeyframeTrack"] { }

				ColorKeyframeTrack.prototype.ValueTypeName = 'color';
				// ValueBufferType is inherited
				// DefaultInterpolation is inherited

				// Note: Very basic implementation and nothing special yet.
				// However, this is the place for color space parameterization.




				/***/
}),

/***/ "./libs/three/animation/tracks/NumberKeyframeTrack.js":
/*!************************************************************!*\
  !*** ./libs/three/animation/tracks/NumberKeyframeTrack.js ***!
  \************************************************************/
/*! exports provided: NumberKeyframeTrack */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function () { return NumberKeyframeTrack; });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./libs/three/animation/KeyframeTrack.js");


				/**
				 * A Track of numeric keyframe values.
				 */
				class NumberKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__["KeyframeTrack"] { }

				NumberKeyframeTrack.prototype.ValueTypeName = 'number';
				// ValueBufferType is inherited
				// DefaultInterpolation is inherited




				/***/
}),

/***/ "./libs/three/animation/tracks/QuaternionKeyframeTrack.js":
/*!****************************************************************!*\
  !*** ./libs/three/animation/tracks/QuaternionKeyframeTrack.js ***!
  \****************************************************************/
/*! exports provided: QuaternionKeyframeTrack */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function () { return QuaternionKeyframeTrack; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./libs/three/animation/KeyframeTrack.js");
/* harmony import */ var _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/interpolants/QuaternionLinearInterpolant.js */ "./libs/three/math/interpolants/QuaternionLinearInterpolant.js");




				/**
				 * A Track of quaternion keyframe values.
				 */
				class QuaternionKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__["KeyframeTrack"] {

					InterpolantFactoryMethodLinear(result) {

						return new _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__["QuaternionLinearInterpolant"](this.times, this.values, this.getValueSize(), result);

					}

				}

				QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
				// ValueBufferType is inherited
				QuaternionKeyframeTrack.prototype.DefaultInterpolation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"];
				QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;




				/***/
}),

/***/ "./libs/three/animation/tracks/StringKeyframeTrack.js":
/*!************************************************************!*\
  !*** ./libs/three/animation/tracks/StringKeyframeTrack.js ***!
  \************************************************************/
/*! exports provided: StringKeyframeTrack */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function () { return StringKeyframeTrack; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./libs/three/animation/KeyframeTrack.js");



				/**
				 * A Track that interpolates Strings
				 */
				class StringKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__["KeyframeTrack"] { }

				StringKeyframeTrack.prototype.ValueTypeName = 'string';
				StringKeyframeTrack.prototype.ValueBufferType = Array;
				StringKeyframeTrack.prototype.DefaultInterpolation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"];
				StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
				StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;




				/***/
}),

/***/ "./libs/three/animation/tracks/VectorKeyframeTrack.js":
/*!************************************************************!*\
  !*** ./libs/three/animation/tracks/VectorKeyframeTrack.js ***!
  \************************************************************/
/*! exports provided: VectorKeyframeTrack */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function () { return VectorKeyframeTrack; });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./libs/three/animation/KeyframeTrack.js");


				/**
				 * A Track of vectored keyframe values.
				 */
				class VectorKeyframeTrack extends _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__["KeyframeTrack"] { }

				VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
				// ValueBufferType is inherited
				// DefaultInterpolation is inherited




				/***/
}),

/***/ "./libs/three/cameras/Camera.js":
/*!**************************************!*\
  !*** ./libs/three/cameras/Camera.js ***!
  \**************************************/
/*! exports provided: Camera */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function () { return Camera; });
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");



				class Camera extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_1__["Object3D"] {

					constructor() {

						super();

						this.type = 'Camera';

						this.matrixWorldInverse = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

						this.projectionMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
						this.projectionMatrixInverse = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

					}

					copy(source, recursive) {

						super.copy(source, recursive);

						this.matrixWorldInverse.copy(source.matrixWorldInverse);

						this.projectionMatrix.copy(source.projectionMatrix);
						this.projectionMatrixInverse.copy(source.projectionMatrixInverse);

						return this;

					}

					getWorldDirection(target) {

						this.updateWorldMatrix(true, false);

						const e = this.matrixWorld.elements;

						return target.set(- e[8], - e[9], - e[10]).normalize();

					}

					updateMatrixWorld(force) {

						super.updateMatrixWorld(force);

						this.matrixWorldInverse.copy(this.matrixWorld).invert();

					}

					updateWorldMatrix(updateParents, updateChildren) {

						super.updateWorldMatrix(updateParents, updateChildren);

						this.matrixWorldInverse.copy(this.matrixWorld).invert();

					}

					clone() {

						return new this.constructor().copy(this);

					}

				}

				Camera.prototype.isCamera = true;




				/***/
}),

/***/ "./libs/three/cameras/CubeCamera.js":
/*!******************************************!*\
  !*** ./libs/three/cameras/CubeCamera.js ***!
  \******************************************/
/*! exports provided: CubeCamera */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function () { return CubeCamera; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PerspectiveCamera.js */ "./libs/three/cameras/PerspectiveCamera.js");




				const fov = 90, aspect = 1;

				class CubeCamera extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {

					constructor(near, far, renderTarget) {

						super();

						this.type = 'CubeCamera';

						if (renderTarget.isWebGLCubeRenderTarget !== true) {

							console.error('THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.');
							return;

						}

						this.renderTarget = renderTarget;

						const cameraPX = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"](fov, aspect, near, far);
						cameraPX.layers = this.layers;
						cameraPX.up.set(0, - 1, 0);
						cameraPX.lookAt(new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](1, 0, 0));
						this.add(cameraPX);

						const cameraNX = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"](fov, aspect, near, far);
						cameraNX.layers = this.layers;
						cameraNX.up.set(0, - 1, 0);
						cameraNX.lookAt(new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](- 1, 0, 0));
						this.add(cameraNX);

						const cameraPY = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"](fov, aspect, near, far);
						cameraPY.layers = this.layers;
						cameraPY.up.set(0, 0, 1);
						cameraPY.lookAt(new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, 1, 0));
						this.add(cameraPY);

						const cameraNY = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"](fov, aspect, near, far);
						cameraNY.layers = this.layers;
						cameraNY.up.set(0, 0, - 1);
						cameraNY.lookAt(new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, - 1, 0));
						this.add(cameraNY);

						const cameraPZ = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"](fov, aspect, near, far);
						cameraPZ.layers = this.layers;
						cameraPZ.up.set(0, - 1, 0);
						cameraPZ.lookAt(new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, 0, 1));
						this.add(cameraPZ);

						const cameraNZ = new _PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"](fov, aspect, near, far);
						cameraNZ.layers = this.layers;
						cameraNZ.up.set(0, - 1, 0);
						cameraNZ.lookAt(new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, 0, - 1));
						this.add(cameraNZ);

					}

					update(renderer, scene) {

						if (this.parent === null) this.updateMatrixWorld();

						const renderTarget = this.renderTarget;

						const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;

						const currentXrEnabled = renderer.xr.enabled;
						const currentRenderTarget = renderer.getRenderTarget();

						renderer.xr.enabled = false;

						const generateMipmaps = renderTarget.texture.generateMipmaps;

						renderTarget.texture.generateMipmaps = false;

						renderer.setRenderTarget(renderTarget, 0);
						renderer.render(scene, cameraPX);

						renderer.setRenderTarget(renderTarget, 1);
						renderer.render(scene, cameraNX);

						renderer.setRenderTarget(renderTarget, 2);
						renderer.render(scene, cameraPY);

						renderer.setRenderTarget(renderTarget, 3);
						renderer.render(scene, cameraNY);

						renderer.setRenderTarget(renderTarget, 4);
						renderer.render(scene, cameraPZ);

						renderTarget.texture.generateMipmaps = generateMipmaps;

						renderer.setRenderTarget(renderTarget, 5);
						renderer.render(scene, cameraNZ);

						renderer.setRenderTarget(currentRenderTarget);

						renderer.xr.enabled = currentXrEnabled;

					}

				}




				/***/
}),

/***/ "./libs/three/cameras/OrthographicCamera.js":
/*!**************************************************!*\
  !*** ./libs/three/cameras/OrthographicCamera.js ***!
  \**************************************************/
/*! exports provided: OrthographicCamera */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function () { return OrthographicCamera; });
/* harmony import */ var _Camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera.js */ "./libs/three/cameras/Camera.js");


				class OrthographicCamera extends _Camera_js__WEBPACK_IMPORTED_MODULE_0__["Camera"] {

					constructor(left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000) {

						super();

						this.type = 'OrthographicCamera';

						this.zoom = 1;
						this.view = null;

						this.left = left;
						this.right = right;
						this.top = top;
						this.bottom = bottom;

						this.near = near;
						this.far = far;

						this.updateProjectionMatrix();

					}

					copy(source, recursive) {

						super.copy(source, recursive);

						this.left = source.left;
						this.right = source.right;
						this.top = source.top;
						this.bottom = source.bottom;
						this.near = source.near;
						this.far = source.far;

						this.zoom = source.zoom;
						this.view = source.view === null ? null : Object.assign({}, source.view);

						return this;

					}

					setViewOffset(fullWidth, fullHeight, x, y, width, height) {

						if (this.view === null) {

							this.view = {
								enabled: true,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1
							};

						}

						this.view.enabled = true;
						this.view.fullWidth = fullWidth;
						this.view.fullHeight = fullHeight;
						this.view.offsetX = x;
						this.view.offsetY = y;
						this.view.width = width;
						this.view.height = height;

						this.updateProjectionMatrix();

					}

					clearViewOffset() {

						if (this.view !== null) {

							this.view.enabled = false;

						}

						this.updateProjectionMatrix();

					}

					updateProjectionMatrix() {

						const dx = (this.right - this.left) / (2 * this.zoom);
						const dy = (this.top - this.bottom) / (2 * this.zoom);
						const cx = (this.right + this.left) / 2;
						const cy = (this.top + this.bottom) / 2;

						let left = cx - dx;
						let right = cx + dx;
						let top = cy + dy;
						let bottom = cy - dy;

						if (this.view !== null && this.view.enabled) {

							const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
							const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;

							left += scaleW * this.view.offsetX;
							right = left + scaleW * this.view.width;
							top -= scaleH * this.view.offsetY;
							bottom = top - scaleH * this.view.height;

						}

						this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);

						this.projectionMatrixInverse.copy(this.projectionMatrix).invert();

					}

					toJSON(meta) {

						const data = super.toJSON(meta);

						data.object.zoom = this.zoom;
						data.object.left = this.left;
						data.object.right = this.right;
						data.object.top = this.top;
						data.object.bottom = this.bottom;
						data.object.near = this.near;
						data.object.far = this.far;

						if (this.view !== null) data.object.view = Object.assign({}, this.view);

						return data;

					}

				}

				OrthographicCamera.prototype.isOrthographicCamera = true;




				/***/
}),

/***/ "./libs/three/cameras/PerspectiveCamera.js":
/*!*************************************************!*\
  !*** ./libs/three/cameras/PerspectiveCamera.js ***!
  \*************************************************/
/*! exports provided: PerspectiveCamera */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function () { return PerspectiveCamera; });
/* harmony import */ var _Camera_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Camera.js */ "./libs/three/cameras/Camera.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");



				class PerspectiveCamera extends _Camera_js__WEBPACK_IMPORTED_MODULE_0__["Camera"] {

					constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {

						super();

						this.type = 'PerspectiveCamera';

						this.fov = fov;
						this.zoom = 1;

						this.near = near;
						this.far = far;
						this.focus = 10;

						this.aspect = aspect;
						this.view = null;

						this.filmGauge = 35;	// width of the film (default in millimeters)
						this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

						this.updateProjectionMatrix();

					}

					copy(source, recursive) {

						super.copy(source, recursive);

						this.fov = source.fov;
						this.zoom = source.zoom;

						this.near = source.near;
						this.far = source.far;
						this.focus = source.focus;

						this.aspect = source.aspect;
						this.view = source.view === null ? null : Object.assign({}, source.view);

						this.filmGauge = source.filmGauge;
						this.filmOffset = source.filmOffset;

						return this;

					}

					/**
					 * Sets the FOV by focal length in respect to the current .filmGauge.
					 *
					 * The default film gauge is 35, so that the focal length can be specified for
					 * a 35mm (full frame) camera.
					 *
					 * Values for focal length and film gauge must have the same unit.
					 */
					setFocalLength(focalLength) {

						/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
						const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

						this.fov = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["RAD2DEG"] * 2 * Math.atan(vExtentSlope);
						this.updateProjectionMatrix();

					}

					/**
					 * Calculates the focal length from the current .fov and .filmGauge.
					 */
					getFocalLength() {

						const vExtentSlope = Math.tan(_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["DEG2RAD"] * 0.5 * this.fov);

						return 0.5 * this.getFilmHeight() / vExtentSlope;

					}

					getEffectiveFOV() {

						return _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["RAD2DEG"] * 2 * Math.atan(
							Math.tan(_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["DEG2RAD"] * 0.5 * this.fov) / this.zoom);

					}

					getFilmWidth() {

						// film not completely covered in portrait format (aspect < 1)
						return this.filmGauge * Math.min(this.aspect, 1);

					}

					getFilmHeight() {

						// film not completely covered in landscape format (aspect > 1)
						return this.filmGauge / Math.max(this.aspect, 1);

					}

					/**
					 * Sets an offset in a larger frustum. This is useful for multi-window or
					 * multi-monitor/multi-machine setups.
					 *
					 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
					 * the monitors are in grid like this
					 *
					 *   +---+---+---+
					 *   | A | B | C |
					 *   +---+---+---+
					 *   | D | E | F |
					 *   +---+---+---+
					 *
					 * then for each monitor you would call it like this
					 *
					 *   const w = 1920;
					 *   const h = 1080;
					 *   const fullWidth = w * 3;
					 *   const fullHeight = h * 2;
					 *
					 *   --A--
					 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
					 *   --B--
					 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
					 *   --C--
					 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
					 *   --D--
					 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
					 *   --E--
					 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
					 *   --F--
					 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
					 *
					 *   Note there is no reason monitors have to be the same size or in a grid.
					 */
					setViewOffset(fullWidth, fullHeight, x, y, width, height) {

						this.aspect = fullWidth / fullHeight;

						if (this.view === null) {

							this.view = {
								enabled: true,
								fullWidth: 1,
								fullHeight: 1,
								offsetX: 0,
								offsetY: 0,
								width: 1,
								height: 1
							};

						}

						this.view.enabled = true;
						this.view.fullWidth = fullWidth;
						this.view.fullHeight = fullHeight;
						this.view.offsetX = x;
						this.view.offsetY = y;
						this.view.width = width;
						this.view.height = height;

						this.updateProjectionMatrix();

					}

					clearViewOffset() {

						if (this.view !== null) {

							this.view.enabled = false;

						}

						this.updateProjectionMatrix();

					}

					updateProjectionMatrix() {

						const near = this.near;
						let top = near * Math.tan(_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["DEG2RAD"] * 0.5 * this.fov) / this.zoom;
						let height = 2 * top;
						let width = this.aspect * height;
						let left = - 0.5 * width;
						const view = this.view;

						if (this.view !== null && this.view.enabled) {

							const fullWidth = view.fullWidth,
								fullHeight = view.fullHeight;

							left += view.offsetX * width / fullWidth;
							top -= view.offsetY * height / fullHeight;
							width *= view.width / fullWidth;
							height *= view.height / fullHeight;

						}

						const skew = this.filmOffset;
						if (skew !== 0) left += near * skew / this.getFilmWidth();

						this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);

						this.projectionMatrixInverse.copy(this.projectionMatrix).invert();

					}

					toJSON(meta) {

						const data = super.toJSON(meta);

						data.object.fov = this.fov;
						data.object.zoom = this.zoom;

						data.object.near = this.near;
						data.object.far = this.far;
						data.object.focus = this.focus;

						data.object.aspect = this.aspect;

						if (this.view !== null) data.object.view = Object.assign({}, this.view);

						data.object.filmGauge = this.filmGauge;
						data.object.filmOffset = this.filmOffset;

						return data;

					}

				}

				PerspectiveCamera.prototype.isPerspectiveCamera = true;




				/***/
}),

/***/ "./libs/three/constants.js":
/*!*********************************!*\
  !*** ./libs/three/constants.js ***!
  \*********************************/
/*! exports provided: REVISION, MOUSE, TOUCH, CullFaceNone, CullFaceBack, CullFaceFront, CullFaceFrontBack, BasicShadowMap, PCFShadowMap, PCFSoftShadowMap, VSMShadowMap, FrontSide, BackSide, DoubleSide, FlatShading, SmoothShading, NoBlending, NormalBlending, AdditiveBlending, SubtractiveBlending, MultiplyBlending, CustomBlending, AddEquation, SubtractEquation, ReverseSubtractEquation, MinEquation, MaxEquation, ZeroFactor, OneFactor, SrcColorFactor, OneMinusSrcColorFactor, SrcAlphaFactor, OneMinusSrcAlphaFactor, DstAlphaFactor, OneMinusDstAlphaFactor, DstColorFactor, OneMinusDstColorFactor, SrcAlphaSaturateFactor, NeverDepth, AlwaysDepth, LessDepth, LessEqualDepth, EqualDepth, GreaterEqualDepth, GreaterDepth, NotEqualDepth, MultiplyOperation, MixOperation, AddOperation, NoToneMapping, LinearToneMapping, ReinhardToneMapping, CineonToneMapping, ACESFilmicToneMapping, CustomToneMapping, UVMapping, CubeReflectionMapping, CubeRefractionMapping, EquirectangularReflectionMapping, EquirectangularRefractionMapping, CubeUVReflectionMapping, CubeUVRefractionMapping, RepeatWrapping, ClampToEdgeWrapping, MirroredRepeatWrapping, NearestFilter, NearestMipmapNearestFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipMapLinearFilter, LinearFilter, LinearMipmapNearestFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipMapLinearFilter, UnsignedByteType, ByteType, ShortType, UnsignedShortType, IntType, UnsignedIntType, FloatType, HalfFloatType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedInt248Type, AlphaFormat, RGBFormat, RGBAFormat, LuminanceFormat, LuminanceAlphaFormat, RGBEFormat, DepthFormat, DepthStencilFormat, RedFormat, RedIntegerFormat, RGFormat, RGIntegerFormat, RGBIntegerFormat, RGBAIntegerFormat, RGB_S3TC_DXT1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGB_PVRTC_4BPPV1_Format, RGB_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_PVRTC_2BPPV1_Format, RGB_ETC1_Format, RGB_ETC2_Format, RGBA_ETC2_EAC_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_10x10_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_BPTC_Format, SRGB8_ALPHA8_ASTC_4x4_Format, SRGB8_ALPHA8_ASTC_5x4_Format, SRGB8_ALPHA8_ASTC_5x5_Format, SRGB8_ALPHA8_ASTC_6x5_Format, SRGB8_ALPHA8_ASTC_6x6_Format, SRGB8_ALPHA8_ASTC_8x5_Format, SRGB8_ALPHA8_ASTC_8x6_Format, SRGB8_ALPHA8_ASTC_8x8_Format, SRGB8_ALPHA8_ASTC_10x5_Format, SRGB8_ALPHA8_ASTC_10x6_Format, SRGB8_ALPHA8_ASTC_10x8_Format, SRGB8_ALPHA8_ASTC_10x10_Format, SRGB8_ALPHA8_ASTC_12x10_Format, SRGB8_ALPHA8_ASTC_12x12_Format, LoopOnce, LoopRepeat, LoopPingPong, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, ZeroCurvatureEnding, ZeroSlopeEnding, WrapAroundEnding, NormalAnimationBlendMode, AdditiveAnimationBlendMode, TrianglesDrawMode, TriangleStripDrawMode, TriangleFanDrawMode, LinearEncoding, sRGBEncoding, GammaEncoding, RGBEEncoding, LogLuvEncoding, RGBM7Encoding, RGBM16Encoding, RGBDEncoding, BasicDepthPacking, RGBADepthPacking, TangentSpaceNormalMap, ObjectSpaceNormalMap, ZeroStencilOp, KeepStencilOp, ReplaceStencilOp, IncrementStencilOp, DecrementStencilOp, IncrementWrapStencilOp, DecrementWrapStencilOp, InvertStencilOp, NeverStencilFunc, LessStencilFunc, EqualStencilFunc, LessEqualStencilFunc, GreaterStencilFunc, NotEqualStencilFunc, GreaterEqualStencilFunc, AlwaysStencilFunc, StaticDrawUsage, DynamicDrawUsage, StreamDrawUsage, StaticReadUsage, DynamicReadUsage, StreamReadUsage, StaticCopyUsage, DynamicCopyUsage, StreamCopyUsage, GLSL1, GLSL3 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function () { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function () { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TOUCH", function () { return TOUCH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function () { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function () { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function () { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function () { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function () { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function () { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function () { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VSMShadowMap", function () { return VSMShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function () { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function () { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function () { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function () { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function () { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function () { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function () { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function () { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function () { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function () { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function () { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function () { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function () { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function () { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function () { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function () { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function () { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function () { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function () { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function () { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function () { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function () { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function () { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function () { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function () { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function () { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function () { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function () { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function () { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function () { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function () { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function () { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function () { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function () { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function () { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function () { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function () { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function () { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function () { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function () { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function () { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function () { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function () { return ACESFilmicToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomToneMapping", function () { return CustomToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function () { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function () { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function () { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function () { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function () { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function () { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function () { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function () { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function () { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function () { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function () { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapNearestFilter", function () { return NearestMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function () { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipmapLinearFilter", function () { return NearestMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function () { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function () { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapNearestFilter", function () { return LinearMipmapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function () { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipmapLinearFilter", function () { return LinearMipmapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function () { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function () { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function () { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function () { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function () { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function () { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function () { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function () { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function () { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function () { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function () { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function () { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function () { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function () { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function () { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function () { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function () { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function () { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function () { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function () { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function () { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function () { return RedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedIntegerFormat", function () { return RedIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGFormat", function () { return RGFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGIntegerFormat", function () { return RGIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBIntegerFormat", function () { return RGBIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAIntegerFormat", function () { return RGBAIntegerFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function () { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function () { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function () { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function () { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function () { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function () { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function () { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function () { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function () { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC2_Format", function () { return RGB_ETC2_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ETC2_EAC_Format", function () { return RGBA_ETC2_EAC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function () { return RGBA_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function () { return RGBA_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function () { return RGBA_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function () { return RGBA_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function () { return RGBA_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function () { return RGBA_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function () { return RGBA_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function () { return RGBA_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function () { return RGBA_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function () { return RGBA_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function () { return RGBA_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function () { return RGBA_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function () { return RGBA_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function () { return RGBA_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_BPTC_Format", function () { return RGBA_BPTC_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_4x4_Format", function () { return SRGB8_ALPHA8_ASTC_4x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x4_Format", function () { return SRGB8_ALPHA8_ASTC_5x4_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_5x5_Format", function () { return SRGB8_ALPHA8_ASTC_5x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x5_Format", function () { return SRGB8_ALPHA8_ASTC_6x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_6x6_Format", function () { return SRGB8_ALPHA8_ASTC_6x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x5_Format", function () { return SRGB8_ALPHA8_ASTC_8x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x6_Format", function () { return SRGB8_ALPHA8_ASTC_8x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_8x8_Format", function () { return SRGB8_ALPHA8_ASTC_8x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x5_Format", function () { return SRGB8_ALPHA8_ASTC_10x5_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x6_Format", function () { return SRGB8_ALPHA8_ASTC_10x6_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x8_Format", function () { return SRGB8_ALPHA8_ASTC_10x8_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_10x10_Format", function () { return SRGB8_ALPHA8_ASTC_10x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x10_Format", function () { return SRGB8_ALPHA8_ASTC_12x10_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SRGB8_ALPHA8_ASTC_12x12_Format", function () { return SRGB8_ALPHA8_ASTC_12x12_Format; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function () { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function () { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function () { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function () { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function () { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function () { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function () { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function () { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function () { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalAnimationBlendMode", function () { return NormalAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveAnimationBlendMode", function () { return AdditiveAnimationBlendMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function () { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function () { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function () { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function () { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function () { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function () { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function () { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function () { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function () { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function () { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function () { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function () { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function () { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function () { return TangentSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function () { return ObjectSpaceNormalMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroStencilOp", function () { return ZeroStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeepStencilOp", function () { return KeepStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReplaceStencilOp", function () { return ReplaceStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementStencilOp", function () { return IncrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementStencilOp", function () { return DecrementStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IncrementWrapStencilOp", function () { return IncrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DecrementWrapStencilOp", function () { return DecrementWrapStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InvertStencilOp", function () { return InvertStencilOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverStencilFunc", function () { return NeverStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessStencilFunc", function () { return LessStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualStencilFunc", function () { return EqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualStencilFunc", function () { return LessEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterStencilFunc", function () { return GreaterStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualStencilFunc", function () { return NotEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualStencilFunc", function () { return GreaterEqualStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysStencilFunc", function () { return AlwaysStencilFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticDrawUsage", function () { return StaticDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicDrawUsage", function () { return DynamicDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamDrawUsage", function () { return StreamDrawUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticReadUsage", function () { return StaticReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicReadUsage", function () { return DynamicReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamReadUsage", function () { return StreamReadUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticCopyUsage", function () { return StaticCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicCopyUsage", function () { return DynamicCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StreamCopyUsage", function () { return StreamCopyUsage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL1", function () { return GLSL1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLSL3", function () { return GLSL3; });
				const REVISION = '134';
				const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
				const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
				const CullFaceNone = 0;
				const CullFaceBack = 1;
				const CullFaceFront = 2;
				const CullFaceFrontBack = 3;
				const BasicShadowMap = 0;
				const PCFShadowMap = 1;
				const PCFSoftShadowMap = 2;
				const VSMShadowMap = 3;
				const FrontSide = 0;
				const BackSide = 1;
				const DoubleSide = 2;
				const FlatShading = 1;
				const SmoothShading = 2;
				const NoBlending = 0;
				const NormalBlending = 1;
				const AdditiveBlending = 2;
				const SubtractiveBlending = 3;
				const MultiplyBlending = 4;
				const CustomBlending = 5;
				const AddEquation = 100;
				const SubtractEquation = 101;
				const ReverseSubtractEquation = 102;
				const MinEquation = 103;
				const MaxEquation = 104;
				const ZeroFactor = 200;
				const OneFactor = 201;
				const SrcColorFactor = 202;
				const OneMinusSrcColorFactor = 203;
				const SrcAlphaFactor = 204;
				const OneMinusSrcAlphaFactor = 205;
				const DstAlphaFactor = 206;
				const OneMinusDstAlphaFactor = 207;
				const DstColorFactor = 208;
				const OneMinusDstColorFactor = 209;
				const SrcAlphaSaturateFactor = 210;
				const NeverDepth = 0;
				const AlwaysDepth = 1;
				const LessDepth = 2;
				const LessEqualDepth = 3;
				const EqualDepth = 4;
				const GreaterEqualDepth = 5;
				const GreaterDepth = 6;
				const NotEqualDepth = 7;
				const MultiplyOperation = 0;
				const MixOperation = 1;
				const AddOperation = 2;
				const NoToneMapping = 0;
				const LinearToneMapping = 1;
				const ReinhardToneMapping = 2;
				const CineonToneMapping = 3;
				const ACESFilmicToneMapping = 4;
				const CustomToneMapping = 5;

				const UVMapping = 300;
				const CubeReflectionMapping = 301;
				const CubeRefractionMapping = 302;
				const EquirectangularReflectionMapping = 303;
				const EquirectangularRefractionMapping = 304;
				const CubeUVReflectionMapping = 306;
				const CubeUVRefractionMapping = 307;
				const RepeatWrapping = 1000;
				const ClampToEdgeWrapping = 1001;
				const MirroredRepeatWrapping = 1002;
				const NearestFilter = 1003;
				const NearestMipmapNearestFilter = 1004;
				const NearestMipMapNearestFilter = 1004;
				const NearestMipmapLinearFilter = 1005;
				const NearestMipMapLinearFilter = 1005;
				const LinearFilter = 1006;
				const LinearMipmapNearestFilter = 1007;
				const LinearMipMapNearestFilter = 1007;
				const LinearMipmapLinearFilter = 1008;
				const LinearMipMapLinearFilter = 1008;
				const UnsignedByteType = 1009;
				const ByteType = 1010;
				const ShortType = 1011;
				const UnsignedShortType = 1012;
				const IntType = 1013;
				const UnsignedIntType = 1014;
				const FloatType = 1015;
				const HalfFloatType = 1016;
				const UnsignedShort4444Type = 1017;
				const UnsignedShort5551Type = 1018;
				const UnsignedShort565Type = 1019;
				const UnsignedInt248Type = 1020;
				const AlphaFormat = 1021;
				const RGBFormat = 1022;
				const RGBAFormat = 1023;
				const LuminanceFormat = 1024;
				const LuminanceAlphaFormat = 1025;
				const RGBEFormat = RGBAFormat;
				const DepthFormat = 1026;
				const DepthStencilFormat = 1027;
				const RedFormat = 1028;
				const RedIntegerFormat = 1029;
				const RGFormat = 1030;
				const RGIntegerFormat = 1031;
				const RGBIntegerFormat = 1032;
				const RGBAIntegerFormat = 1033;

				const RGB_S3TC_DXT1_Format = 33776;
				const RGBA_S3TC_DXT1_Format = 33777;
				const RGBA_S3TC_DXT3_Format = 33778;
				const RGBA_S3TC_DXT5_Format = 33779;
				const RGB_PVRTC_4BPPV1_Format = 35840;
				const RGB_PVRTC_2BPPV1_Format = 35841;
				const RGBA_PVRTC_4BPPV1_Format = 35842;
				const RGBA_PVRTC_2BPPV1_Format = 35843;
				const RGB_ETC1_Format = 36196;
				const RGB_ETC2_Format = 37492;
				const RGBA_ETC2_EAC_Format = 37496;
				const RGBA_ASTC_4x4_Format = 37808;
				const RGBA_ASTC_5x4_Format = 37809;
				const RGBA_ASTC_5x5_Format = 37810;
				const RGBA_ASTC_6x5_Format = 37811;
				const RGBA_ASTC_6x6_Format = 37812;
				const RGBA_ASTC_8x5_Format = 37813;
				const RGBA_ASTC_8x6_Format = 37814;
				const RGBA_ASTC_8x8_Format = 37815;
				const RGBA_ASTC_10x5_Format = 37816;
				const RGBA_ASTC_10x6_Format = 37817;
				const RGBA_ASTC_10x8_Format = 37818;
				const RGBA_ASTC_10x10_Format = 37819;
				const RGBA_ASTC_12x10_Format = 37820;
				const RGBA_ASTC_12x12_Format = 37821;
				const RGBA_BPTC_Format = 36492;
				const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
				const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
				const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
				const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
				const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
				const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
				const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
				const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
				const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
				const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
				const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
				const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
				const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
				const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
				const LoopOnce = 2200;
				const LoopRepeat = 2201;
				const LoopPingPong = 2202;
				const InterpolateDiscrete = 2300;
				const InterpolateLinear = 2301;
				const InterpolateSmooth = 2302;
				const ZeroCurvatureEnding = 2400;
				const ZeroSlopeEnding = 2401;
				const WrapAroundEnding = 2402;
				const NormalAnimationBlendMode = 2500;
				const AdditiveAnimationBlendMode = 2501;
				const TrianglesDrawMode = 0;
				const TriangleStripDrawMode = 1;
				const TriangleFanDrawMode = 2;
				const LinearEncoding = 3000;
				const sRGBEncoding = 3001;
				const GammaEncoding = 3007;
				const RGBEEncoding = 3002;
				const LogLuvEncoding = 3003;
				const RGBM7Encoding = 3004;
				const RGBM16Encoding = 3005;
				const RGBDEncoding = 3006;
				const BasicDepthPacking = 3200;
				const RGBADepthPacking = 3201;
				const TangentSpaceNormalMap = 0;
				const ObjectSpaceNormalMap = 1;

				const ZeroStencilOp = 0;
				const KeepStencilOp = 7680;
				const ReplaceStencilOp = 7681;
				const IncrementStencilOp = 7682;
				const DecrementStencilOp = 7683;
				const IncrementWrapStencilOp = 34055;
				const DecrementWrapStencilOp = 34056;
				const InvertStencilOp = 5386;

				const NeverStencilFunc = 512;
				const LessStencilFunc = 513;
				const EqualStencilFunc = 514;
				const LessEqualStencilFunc = 515;
				const GreaterStencilFunc = 516;
				const NotEqualStencilFunc = 517;
				const GreaterEqualStencilFunc = 518;
				const AlwaysStencilFunc = 519;

				const StaticDrawUsage = 35044;
				const DynamicDrawUsage = 35048;
				const StreamDrawUsage = 35040;
				const StaticReadUsage = 35045;
				const DynamicReadUsage = 35049;
				const StreamReadUsage = 35041;
				const StaticCopyUsage = 35046;
				const DynamicCopyUsage = 35050;
				const StreamCopyUsage = 35042;

				const GLSL1 = '100';
				const GLSL3 = '300 es';


				/***/
}),

/***/ "./libs/three/controls/OrbitControls.js":
/*!**********************************************!*\
  !*** ./libs/three/controls/OrbitControls.js ***!
  \**********************************************/
/*! exports provided: OrbitControls */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrbitControls", function () { return OrbitControls; });
/* harmony import */ var _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./libs/three/constants.js");
/* harmony import */ var _math_Quaternion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Quaternion */ "./libs/three/math/Quaternion.js");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2 */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3 */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Spherical__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Spherical */ "./libs/three/math/Spherical.js");







				class OrbitControls {
					constructor(camera) {
						this.camera = camera
						//相机目标点
						var center = this.center = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();

						// this.userPan = true;
						// this.userPanSpeed = 2.0;
						var EPS = 0.000001;
						var PIXELS_PER_ROUND = 1800;

						var rotateStart = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
						var rotateEnd = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
						var rotateDelta = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();

						var phiDelta = 0;
						var thetaDelta = 0;
						var scale = 1;

						this.enabled = true
						this.enableDamping = true
						this.dampingFactor = 0.25
						this.userZoom = true
						this.userZoomSpeed = 1.0
						this.userRotate = true
						this.userRotateSpeed = 1.0
						this.autoRotate = false
						this.autoRotateSpeed = 2.0
						//最小旋转角
						this.minPolarAngle = 0
						//最大旋转角
						this.maxPolarAngle = Math.PI

						// How far you can orbit horizontally, upper and lower limits.
						// If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )
						this.minAzimuthAngle = - Infinity; // radians
						this.maxAzimuthAngle = Infinity; // radians

						this.minDistance = 0
						this.maxDistance = Infinity
						this.enablePitch = true

						function getAutoRotationAngle() {
							return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;
						}

						function getZoomScale() {
							return Math.pow(0.95, this.userZoomSpeed);
						}

						function rotateLeft(angle = getAutoRotationAngle()) {
							thetaDelta -= angle;
						};


						function rotateUp(angle = getAutoRotationAngle()) {
							phiDelta -= angle;
						};

						function zoomIn(zoomScale = getZoomScale()) {
							scale /= zoomScale;
						};
						function zoomOut(zoomScale = getZoomScale()) {
							scale *= zoomScale;
						};

						this.update = (tRadius) => {
							if (
								Math.abs(thetaDelta) < 0.0001 &&
								Math.abs(phiDelta) < 0.0001 &&
								Math.abs(scale - 1) < 0.0001 &&
								!this.autoRotate &&
								!tRadius
							) {
								return
							}

							var position = this.camera.position;
							var offset = position.clone().sub(center);
							var theta = Math.atan2(offset.x, offset.z);
							var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

							if (this.autoRotate) rotateLeft();

							theta += thetaDelta;
							phi += phiDelta;


							var min = this.minAzimuthAngle;
							var max = this.maxAzimuthAngle;
							var twoPI = Math.PI * 2;

							if (isFinite(min) && isFinite(max)) {

								if (min < - Math.PI) min += twoPI; else if (min > Math.PI) min -= twoPI;
								if (max < - Math.PI) max += twoPI; else if (max > Math.PI) max -= twoPI;

								if (min <= max) {
									theta = Math.max(min, Math.min(max, theta));
								} else {
									theta = (theta > (min + max) / 2) ?
										Math.max(min, theta) :
										Math.min(max, theta);
								}
							}


							phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

							phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

							var radius = offset.length() * scale;

							// restrict radius to be between desired limits
							if (tRadius) {
								radius = Math.max(this.minDistance, Math.min(this.maxDistance, tRadius));
							} else {
								radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
							}

							offset.x = radius * Math.sin(phi) * Math.sin(theta);
							offset.y = radius * Math.cos(phi);
							offset.z = radius * Math.sin(phi) * Math.cos(theta);

							//相机位置
							position.copy(center).add(offset);

							//相机目标点
							this.camera.lookAt(center.x, center.y, center.z);

							//恢复
							if (this.enableDamping) {
								thetaDelta *= (1 - this.dampingFactor);
								phiDelta *= (1 - this.dampingFactor);
							} else {
								thetaDelta = 0;
								phiDelta = 0;
							}

							scale = 1;
							// if (lastPosition.distanceTo(this.object.position) > 0) {
							//     this.dispatchEvent(changeEvent);
							//     lastPosition.copy(this.object.position);
							// }
						};
						//记录两个手指唯一标识
						let fingles = [];
						//距离
						let deltaDis = 0;
						this.onTouchStart = (e) => {
							if (!this.enabled) return;
							//每个处理
							for (var i = 0; i < e.changedTouches.length; i++) {
								let { x, y, identifier } = e.changedTouches[i];
								fingles.push({ x, y, id: identifier })
								if (fingles.length >= 2) {
									let f1 = fingles[fingles.length - 1];
									let f2 = fingles[fingles.length - 2];
									deltaDis = Math.sqrt(Math.pow(f1.x - f2.x, 2) + Math.pow(f1.y - f2.y, 2));
								}
								rotateStart.set(e.changedTouches[0].x, e.changedTouches[0].y);
							}
						}
						this.onTouchMove = (e) => {
							// debugger
							if (!this.enabled || !fingles.length) return;
							for (var i = 0; i < e.changedTouches.length; i++) {
								if (!e.changedTouches[i]) continue;
								let { x, y, identifier } = e.changedTouches[i];
								if (fingles.length == 1) {
									if (!this.userRotate) return;
									if (!rotateStart.x && !rotateStart.y) return;
									rotateEnd.set(x, y);
									rotateDelta.subVectors(rotateEnd, rotateStart);
									rotateLeft(2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * this.userRotateSpeed);
									if (this.enablePitch) rotateUp(2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * this.userRotateSpeed);
									rotateStart.copy(rotateEnd);
								}
								//多指，取最后两个
								else {
									if (!this.userZoom) return;
									var oneF = fingles[fingles.length - 1];
									var twoF = fingles[fingles.length - 2];
									if (identifier == oneF.id) {
										oneF.x = x
										oneF.y = y
									} else if (identifier == twoF.id) {
										twoF.x = x
										twoF.y = y
									} else {
										continue
									}
									var cDelta = Math.sqrt(Math.pow(oneF.x - twoF.x, 2) + Math.pow(oneF.y - twoF.y, 2));
									if (cDelta - deltaDis > 0) {
										zoomOut(Math.pow(0.95, this.userZoomSpeed / 3));//手势的执行太快了
									} else {
										zoomIn(Math.pow(0.95, this.userZoomSpeed / 3));
									}
									deltaDis = cDelta;
								}
							}
							this.update();
						}

						this.onTouchEnd = (e) => {//淘宝有bug，全部移除先
							fingles.length = 0;
						}

					}
				}








				/***/
}),

/***/ "./libs/three/controls/OrbitControlsForCustomerAvatar.js":
/*!***************************************************************!*\
  !*** ./libs/three/controls/OrbitControlsForCustomerAvatar.js ***!
  \***************************************************************/
/*! exports provided: OrbitControls */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrbitControls", function () { return OrbitControls; });
/* harmony import */ var _core_EventDispatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ "./libs/three/constants.js");
/* harmony import */ var _math_Quaternion__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Quaternion */ "./libs/three/math/Quaternion.js");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2 */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3 */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Spherical__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Spherical */ "./libs/three/math/Spherical.js");







				class OrbitControls {
					constructor(camera, canvasW = 750, canvasH = 800) {
						var self = this;
						var camera = this.camera = camera;
						//相机目标点
						var center = this.center = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						var defaultCenter = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 1, 0);
						var EPS = 0.000001;
						var PIXELS_PER_ROUND = 1800;

						this.enabled = true
						this.enableDamping = true
						this.dampingFactor = 0.25
						this.userZoom = true
						this.userZoomSpeed = 1.0

						this.userPan = false
						this.userPanSpeed = 1.0;
						this.screenSpacePanning = true;
						this.panStart = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
						this.panEnd = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
						this.panDelta = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
						this.panLeftV = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						this.panUpV = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						this.panOffset = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						this.tempPanOffset = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						this.minPanOffsetY = 0.4;
						this.maxPanOffsetY = 1.4;

						this.userRotate = true
						this.userRotateSpeed = 2.0
						this.autoRotate = false
						this.autoRotateSpeed = 2.0
						//最小旋转角
						this.minPolarAngle = 0
						//最大旋转角
						this.maxPolarAngle = Math.PI
						this.minDistance = 0
						this.maxDistance = Infinity
						this.enablePitch = true

						var rotateStart = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
						var rotateEnd = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();
						var rotateDelta = new _math_Vector2__WEBPACK_IMPORTED_MODULE_3__["Vector2"]();

						var tempPanOffset = this.tempPanOffset = new _math_Vector3__WEBPACK_IMPORTED_MODULE_4__["Vector3"]()

						var phiDelta = 0;
						var thetaDelta = 0;
						var scale = 1;

						function getAutoRotationAngle() {
							return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;
						}

						function getZoomScale() {
							return Math.pow(0.95, this.userZoomSpeed);
						}

						function rotateLeft(angle = getAutoRotationAngle()) {
							thetaDelta -= angle;
						};


						function rotateUp(angle = getAutoRotationAngle()) {
							phiDelta -= angle;
						};


						function panLeft(distance, objectMatrix) {
							self.panLeftV.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix
							self.panLeftV.multiplyScalar(-distance);
							self.panOffset.add(self.panLeftV);
						};

						function panUp(distance, objectMatrix) {
							if (self.screenSpacePanning === true) {
								self.panUpV.setFromMatrixColumn(objectMatrix, 1);
							} else {
								self.panUpV.setFromMatrixColumn(objectMatrix, 0);
								self.panUpV.crossVectors(self.camera.up, v);
							}
							self.panUpV.multiplyScalar(distance);
							self.panOffset.add(self.panUpV);
						};

						// deltaX and deltaY are in pixels; right and down are positive
						function pan(deltaX, deltaY) {

							// if (camera.isPerspectiveCamera) {
							// perspective
							const { position, fov } = camera;
							tempPanOffset.copy(position).sub(center);
							let targetDistance = tempPanOffset.length();
							// half of the fov is center to top of screen
							targetDistance *= Math.tan((fov / 2) * Math.PI / 180.0);
							// we use only clientHeight here so aspect ratio does not distort speed
							panLeft(2 * deltaX * targetDistance / canvasW, camera.matrix);

							panUp(2 * deltaY * targetDistance / canvasH, camera.matrix);
							// } else if (camera.isOrthographicCamera) {
							// 	// orthographic
							// 	panLeft(deltaX * (camera.right - camera.left) / camera.zoom / canvasW, camera.matrix);
							// 	panUp(deltaY * (camera.top - camera.bottom) / camera.zoom / canvasH, camera.matrix);
							// } else {
							// 	// camera neither orthographic nor perspective
							// 	console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
							// 	this.userPan = false;
							// }
						};

						function zoomIn(zoomScale = getZoomScale()) {
							scale /= zoomScale;
						};
						function zoomOut(zoomScale = getZoomScale()) {
							scale *= zoomScale;
						};

						this.update = (tRadius) => {
							if (
								Math.abs(thetaDelta) < 0.0001 &&
								Math.abs(phiDelta) < 0.0001 &&
								Math.abs(scale - 1) < 0.0001 &&
								!this.autoRotate &&
								!tRadius &&
								Math.abs(self.panOffset.x) < 0.0001 &&
								Math.abs(self.panOffset.y) < 0.0001 &&
								Math.abs(self.panOffset.z) < 0.0001
							) {
								return
							}

							var position = this.camera.position;
							var offset = position.clone().sub(center);
							var theta = Math.atan2(offset.x, offset.z);
							var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

							if (this.autoRotate) rotateLeft();

							theta += thetaDelta;
							phi += phiDelta;

							phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

							phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

							var radius = offset.length() * scale;

							// restrict radius to be between desired limits
							if (tRadius) {
								radius = Math.max(this.minDistance, Math.min(this.maxDistance, tRadius));
							} else {
								radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
							}
							if (Math.abs(this.minDistance - radius) < 0.3) {
								// 放大的时候可以拖动
								this.userPan = true
							} else {
								// 缩小的时候禁用拖动
								this.userPan = false
							}

							offset.x = radius * Math.sin(phi) * Math.sin(theta);
							offset.y = radius * Math.cos(phi);
							offset.z = radius * Math.sin(phi) * Math.cos(theta);

							if (this.enableDamping === true) {
								center.addScaledVector(this.panOffset, this.dampingFactor);
							} else {
								center.add(this.panOffset);
							}
							// 中心点修正
							if (center.y > this.maxPanOffsetY) {
								center.y = this.maxPanOffsetY
							}
							if (center.y < this.minPanOffsetY) {
								center.y = this.minPanOffsetY
							}

							if (!this.userPan) {
								// 不可以拖动的时候将中心点回到初始化的中心
								let deltaY = center.y - defaultCenter.y
								if (Math.abs(deltaY) < 0.001) {
									center.y = defaultCenter.y
								} else {
									center.y -= (deltaY * 0.15)
								}
							}
							center.set(0, center.y, 0)

							//相机位置
							this.camera.position.copy(center).add(offset);
							//相机目标点
							this.camera.lookAt(center.x, center.y, center.z);

							//恢复
							if (this.enableDamping) {
								thetaDelta *= (1 - this.dampingFactor);
								phiDelta *= (1 - this.dampingFactor);
								this.panOffset.multiplyScalar(1 - this.dampingFactor);
							} else {
								thetaDelta = 0;
								phiDelta = 0;
								this.panOffset.set(0, 0, 0);
							}

							scale = 1;

							// if (lastPosition.distanceTo(this.object.position) > 0) {
							//     this.dispatchEvent(changeEvent);
							//     lastPosition.copy(this.object.position);
							// }
						};
						//记录两个手指唯一标识
						let fingles = [];
						//距离
						let deltaDis = 0;

						this.onTouchStart = (e) => {
							if (!this.enabled) return;
							//每个处理
							for (var i = 0; i < e.changedTouches.length; i++) {
								let { x, y, identifier } = e.changedTouches[i];
								fingles.push({ x, y, id: identifier })

								this.panStart.set(fingles[0].x, fingles[0].y);
								if (fingles.length >= 2) {
									let f1 = fingles[fingles.length - 1];
									let f2 = fingles[fingles.length - 2];
									deltaDis = Math.sqrt(Math.pow(f1.x - f2.x, 2) + Math.pow(f1.y - f2.y, 2));

									this.panStart.set(0.5 * (f1.x + f2.x), 0.5 * (f1.y + f2.y));
								}
								rotateStart.set(e.changedTouches[0].x, e.changedTouches[0].y);
							}
						}
						this.onTouchMove = (e) => {
							if (!this.enabled) return
							if (!fingles.length) return;
							for (var i = 0; i < e.changedTouches.length; i++) {
								if (!e.changedTouches[i]) continue;
								let { x, y, identifier } = e.changedTouches[i];
								if (fingles.length == 1) {
									if (!this.userRotate) return;
									if (!rotateStart.x && !rotateStart.y) return;
									rotateEnd.set(x, y);
									rotateDelta.subVectors(rotateEnd, rotateStart);
									rotateLeft(2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * this.userRotateSpeed);
									if (this.enablePitch) rotateUp(2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * this.userRotateSpeed);
									rotateStart.copy(rotateEnd);

									// 处理平移
									if (this.userPan) {
										this.panEnd.set(x, y);
										this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.userPanSpeed);
										// this.pan(this.panDelta.x, this.panDelta.y);
										// x轴不让移动
										pan(0, this.panDelta.y);
										this.panStart.copy(this.panEnd);
									}
								}
								//多指，取最后两个
								else {
									// 处理缩放
									var oneF = fingles[fingles.length - 1];
									var twoF = fingles[fingles.length - 2];
									if (this.userZoom) {
										if (identifier == oneF.id) {
											oneF.x = x
											oneF.y = y
										} else if (identifier == twoF.id) {
											twoF.x = x
											twoF.y = y
										} else {
											continue
										}
										var cDelta = Math.sqrt(Math.pow(oneF.x - twoF.x, 2) + Math.pow(oneF.y - twoF.y, 2));
										if (Math.abs(cDelta - deltaDis) > 0.5) {
											if (cDelta - deltaDis > 0) {
												zoomOut(Math.pow(0.95, this.userZoomSpeed / 3));//手势的执行太快了
											} else {
												zoomIn(Math.pow(0.95, this.userZoomSpeed / 3));
											}
										}

										deltaDis = cDelta;
									}
								}
							}
							this.update();
						}

						this.onTouchEnd = (e) => {//淘宝有bug，全部移除先
							// if(e.touches && e.touches.length<=0){
							fingles.length = 0;
							// }
						}

					}
				}








				/***/
}),

/***/ "./libs/three/core/BufferAttribute.js":
/*!********************************************!*\
  !*** ./libs/three/core/BufferAttribute.js ***!
  \********************************************/
/*! exports provided: Float64BufferAttribute, Float32BufferAttribute, Float16BufferAttribute, Uint32BufferAttribute, Int32BufferAttribute, Uint16BufferAttribute, Int16BufferAttribute, Uint8ClampedBufferAttribute, Uint8BufferAttribute, Int8BufferAttribute, BufferAttribute */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function () { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function () { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float16BufferAttribute", function () { return Float16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function () { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function () { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function () { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function () { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function () { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function () { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function () { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function () { return BufferAttribute; });
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector4.js */ "./libs/three/math/Vector4.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "./libs/three/math/Color.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");






				const _vector = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _vector2 = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]();

				class BufferAttribute {

					constructor(array, itemSize, normalized) {

						if (Array.isArray(array)) {

							throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');

						}

						this.name = '';

						this.array = array;
						this.itemSize = itemSize;
						this.count = array !== undefined ? array.length / itemSize : 0;
						this.normalized = normalized === true;

						this.usage = _constants_js__WEBPACK_IMPORTED_MODULE_4__["StaticDrawUsage"];
						this.updateRange = { offset: 0, count: - 1 };

						this.version = 0;

					}

					onUploadCallback() { }

					set needsUpdate(value) {

						if (value === true) this.version++;

					}

					setUsage(value) {

						this.usage = value;

						return this;

					}

					copy(source) {

						this.name = source.name;
						this.array = new source.array.constructor(source.array);
						this.itemSize = source.itemSize;
						this.count = source.count;
						this.normalized = source.normalized;

						this.usage = source.usage;

						return this;

					}

					copyAt(index1, attribute, index2) {

						index1 *= this.itemSize;
						index2 *= attribute.itemSize;

						for (let i = 0, l = this.itemSize; i < l; i++) {

							this.array[index1 + i] = attribute.array[index2 + i];

						}

						return this;

					}

					copyArray(array) {

						this.array.set(array);

						return this;

					}

					copyColorsArray(colors) {

						const array = this.array;
						let offset = 0;

						for (let i = 0, l = colors.length; i < l; i++) {

							let color = colors[i];

							if (color === undefined) {

								console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined', i);
								color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"]();

							}

							array[offset++] = color.r;
							array[offset++] = color.g;
							array[offset++] = color.b;

						}

						return this;

					}

					copyVector2sArray(vectors) {

						const array = this.array;
						let offset = 0;

						for (let i = 0, l = vectors.length; i < l; i++) {

							let vector = vectors[i];

							if (vector === undefined) {

								console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i);
								vector = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]();

							}

							array[offset++] = vector.x;
							array[offset++] = vector.y;

						}

						return this;

					}

					copyVector3sArray(vectors) {

						const array = this.array;
						let offset = 0;

						for (let i = 0, l = vectors.length; i < l; i++) {

							let vector = vectors[i];

							if (vector === undefined) {

								console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i);
								vector = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

							}

							array[offset++] = vector.x;
							array[offset++] = vector.y;
							array[offset++] = vector.z;

						}

						return this;

					}

					copyVector4sArray(vectors) {

						const array = this.array;
						let offset = 0;

						for (let i = 0, l = vectors.length; i < l; i++) {

							let vector = vectors[i];

							if (vector === undefined) {

								console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i);
								vector = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_0__["Vector4"]();

							}

							array[offset++] = vector.x;
							array[offset++] = vector.y;
							array[offset++] = vector.z;
							array[offset++] = vector.w;

						}

						return this;

					}

					applyMatrix3(m) {

						if (this.itemSize === 2) {

							for (let i = 0, l = this.count; i < l; i++) {

								_vector2.fromBufferAttribute(this, i);
								_vector2.applyMatrix3(m);

								this.setXY(i, _vector2.x, _vector2.y);

							}

						} else if (this.itemSize === 3) {

							for (let i = 0, l = this.count; i < l; i++) {

								_vector.fromBufferAttribute(this, i);
								_vector.applyMatrix3(m);

								this.setXYZ(i, _vector.x, _vector.y, _vector.z);

							}

						}

						return this;

					}

					applyMatrix4(m) {

						for (let i = 0, l = this.count; i < l; i++) {

							_vector.x = this.getX(i);
							_vector.y = this.getY(i);
							_vector.z = this.getZ(i);

							_vector.applyMatrix4(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);

						}

						return this;

					}

					applyNormalMatrix(m) {

						for (let i = 0, l = this.count; i < l; i++) {

							_vector.x = this.getX(i);
							_vector.y = this.getY(i);
							_vector.z = this.getZ(i);

							_vector.applyNormalMatrix(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);

						}

						return this;

					}

					transformDirection(m) {

						for (let i = 0, l = this.count; i < l; i++) {

							_vector.x = this.getX(i);
							_vector.y = this.getY(i);
							_vector.z = this.getZ(i);

							_vector.transformDirection(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);

						}

						return this;

					}

					set(value, offset = 0) {

						this.array.set(value, offset);

						return this;

					}

					getX(index) {

						return this.array[index * this.itemSize];

					}

					setX(index, x) {

						this.array[index * this.itemSize] = x;

						return this;

					}

					getY(index) {

						return this.array[index * this.itemSize + 1];

					}

					setY(index, y) {

						this.array[index * this.itemSize + 1] = y;

						return this;

					}

					getZ(index) {

						return this.array[index * this.itemSize + 2];

					}

					setZ(index, z) {

						this.array[index * this.itemSize + 2] = z;

						return this;

					}

					getW(index) {

						return this.array[index * this.itemSize + 3];

					}

					setW(index, w) {

						this.array[index * this.itemSize + 3] = w;

						return this;

					}

					setXY(index, x, y) {

						index *= this.itemSize;

						this.array[index + 0] = x;
						this.array[index + 1] = y;

						return this;

					}

					setXYZ(index, x, y, z) {

						index *= this.itemSize;

						this.array[index + 0] = x;
						this.array[index + 1] = y;
						this.array[index + 2] = z;

						return this;

					}

					setXYZW(index, x, y, z, w) {

						index *= this.itemSize;

						this.array[index + 0] = x;
						this.array[index + 1] = y;
						this.array[index + 2] = z;
						this.array[index + 3] = w;

						return this;

					}

					onUpload(callback) {

						this.onUploadCallback = callback;

						return this;

					}

					clone() {

						return new this.constructor(this.array, this.itemSize).copy(this);

					}

					toJSON() {

						const data = {
							itemSize: this.itemSize,
							type: this.array.constructor.name,
							array: Array.prototype.slice.call(this.array),
							normalized: this.normalized
						};

						if (this.name !== '') data.name = this.name;
						if (this.usage !== _constants_js__WEBPACK_IMPORTED_MODULE_4__["StaticDrawUsage"]) data.usage = this.usage;
						if (this.updateRange.offset !== 0 || this.updateRange.count !== - 1) data.updateRange = this.updateRange;

						return data;

					}

				}

				BufferAttribute.prototype.isBufferAttribute = true;

				//

				class Int8BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Int8Array(array), itemSize, normalized);

					}

				}

				class Uint8BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Uint8Array(array), itemSize, normalized);

					}

				}

				class Uint8ClampedBufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Uint8ClampedArray(array), itemSize, normalized);

					}

				}

				class Int16BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Int16Array(array), itemSize, normalized);

					}

				}

				class Uint16BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Uint16Array(array), itemSize, normalized);

					}

				}

				class Int32BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Int32Array(array), itemSize, normalized);

					}

				}

				class Uint32BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Uint32Array(array), itemSize, normalized);

					}

				}

				class Float16BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Uint16Array(array), itemSize, normalized);

					}

				}

				Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

				class Float32BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Float32Array(array), itemSize, normalized);

					}

				}

				class Float64BufferAttribute extends BufferAttribute {

					constructor(array, itemSize, normalized) {

						super(new Float64Array(array), itemSize, normalized);

					}

				}

				//




				/***/
}),

/***/ "./libs/three/core/BufferGeometry.js":
/*!*******************************************!*\
  !*** ./libs/three/core/BufferGeometry.js ***!
  \*******************************************/
/*! exports provided: BufferGeometry */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function () { return BufferGeometry; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Box3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Box3.js */ "./libs/three/math/Box3.js");
/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher.js */ "./libs/three/core/EventDispatcher.js");
/* harmony import */ var _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Sphere.js */ "./libs/three/math/Sphere.js");
/* harmony import */ var _Object3D_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Object3D.js */ "./libs/three/core/Object3D.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/Matrix3.js */ "./libs/three/math/Matrix3.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils.js */ "./libs/three/utils.js");












				let _id = 0;

				const _m1 = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_7__["Matrix4"]();
				const _obj = /*@__PURE__*/ new _Object3D_js__WEBPACK_IMPORTED_MODULE_6__["Object3D"]();
				const _offset = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _box = /*@__PURE__*/ new _math_Box3_js__WEBPACK_IMPORTED_MODULE_2__["Box3"]();
				const _boxMorphTargets = /*@__PURE__*/ new _math_Box3_js__WEBPACK_IMPORTED_MODULE_2__["Box3"]();
				const _vector = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				class BufferGeometry extends _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__["EventDispatcher"] {

					constructor() {

						super();

						Object.defineProperty(this, 'id', { value: _id++ });

						this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_9__["generateUUID"]();

						this.name = '';
						this.type = 'BufferGeometry';

						this.index = null;
						this.attributes = {};

						this.morphAttributes = {};
						this.morphTargetsRelative = false;

						this.groups = [];

						this.boundingBox = null;
						this.boundingSphere = null;

						this.drawRange = { start: 0, count: Infinity };

						this.userData = {};

					}

					getIndex() {

						return this.index;

					}

					setIndex(index) {

						if (Array.isArray(index)) {

							this.index = new (Object(_utils_js__WEBPACK_IMPORTED_MODULE_10__["arrayMax"])(index) > 65535 ? _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Uint32BufferAttribute"] : _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Uint16BufferAttribute"])(index, 1);

						} else {

							this.index = index;

						}

						return this;

					}

					getAttribute(name) {

						return this.attributes[name];

					}

					setAttribute(name, attribute) {

						this.attributes[name] = attribute;

						return this;

					}

					deleteAttribute(name) {

						delete this.attributes[name];

						return this;

					}

					hasAttribute(name) {

						return this.attributes[name] !== undefined;

					}

					addGroup(start, count, materialIndex = 0) {

						this.groups.push({

							start: start,
							count: count,
							materialIndex: materialIndex

						});

					}

					clearGroups() {

						this.groups = [];

					}

					setDrawRange(start, count) {

						this.drawRange.start = start;
						this.drawRange.count = count;

					}

					applyMatrix4(matrix) {

						const position = this.attributes.position;

						if (position !== undefined) {

							position.applyMatrix4(matrix);

							position.needsUpdate = true;

						}

						const normal = this.attributes.normal;

						if (normal !== undefined) {

							const normalMatrix = new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_8__["Matrix3"]().getNormalMatrix(matrix);

							normal.applyNormalMatrix(normalMatrix);

							normal.needsUpdate = true;

						}

						const tangent = this.attributes.tangent;

						if (tangent !== undefined) {

							tangent.transformDirection(matrix);

							tangent.needsUpdate = true;

						}

						if (this.boundingBox !== null) {

							this.computeBoundingBox();

						}

						if (this.boundingSphere !== null) {

							this.computeBoundingSphere();

						}

						return this;

					}

					applyQuaternion(q) {

						_m1.makeRotationFromQuaternion(q);

						this.applyMatrix4(_m1);

						return this;

					}

					rotateX(angle) {

						// rotate geometry around world x-axis

						_m1.makeRotationX(angle);

						this.applyMatrix4(_m1);

						return this;

					}

					rotateY(angle) {

						// rotate geometry around world y-axis

						_m1.makeRotationY(angle);

						this.applyMatrix4(_m1);

						return this;

					}

					rotateZ(angle) {

						// rotate geometry around world z-axis

						_m1.makeRotationZ(angle);

						this.applyMatrix4(_m1);

						return this;

					}

					translate(x, y, z) {

						// translate geometry

						_m1.makeTranslation(x, y, z);

						this.applyMatrix4(_m1);

						return this;

					}

					scale(x, y, z) {

						// scale geometry

						_m1.makeScale(x, y, z);

						this.applyMatrix4(_m1);

						return this;

					}

					lookAt(vector) {

						_obj.lookAt(vector);

						_obj.updateMatrix();

						this.applyMatrix4(_obj.matrix);

						return this;

					}

					center() {

						this.computeBoundingBox();

						this.boundingBox.getCenter(_offset).negate();

						this.translate(_offset.x, _offset.y, _offset.z);

						return this;

					}

					setFromPoints(points) {

						const position = [];

						for (let i = 0, l = points.length; i < l; i++) {

							const point = points[i];
							position.push(point.x, point.y, point.z || 0);

						}

						this.setAttribute('position', new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["Float32BufferAttribute"](position, 3));

						return this;

					}

					computeBoundingBox() {

						if (this.boundingBox === null) {

							this.boundingBox = new _math_Box3_js__WEBPACK_IMPORTED_MODULE_2__["Box3"]();

						}

						const position = this.attributes.position;
						const morphAttributesPosition = this.morphAttributes.position;

						if (position && position.isGLBufferAttribute) {

							console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);

							this.boundingBox.set(
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](- Infinity, - Infinity, - Infinity),
								new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](+ Infinity, + Infinity, + Infinity)
							);

							return;

						}

						if (position !== undefined) {

							this.boundingBox.setFromBufferAttribute(position);

							// process morph attributes if present

							if (morphAttributesPosition) {

								for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

									const morphAttribute = morphAttributesPosition[i];
									_box.setFromBufferAttribute(morphAttribute);

									if (this.morphTargetsRelative) {

										_vector.addVectors(this.boundingBox.min, _box.min);
										this.boundingBox.expandByPoint(_vector);

										_vector.addVectors(this.boundingBox.max, _box.max);
										this.boundingBox.expandByPoint(_vector);

									} else {

										this.boundingBox.expandByPoint(_box.min);
										this.boundingBox.expandByPoint(_box.max);

									}

								}

							}

						} else {

							this.boundingBox.makeEmpty();

						}

						if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {

							console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);

						}

					}

					computeBoundingSphere() {

						if (this.boundingSphere === null) {

							this.boundingSphere = new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_5__["Sphere"]();

						}

						const position = this.attributes.position;
						const morphAttributesPosition = this.morphAttributes.position;

						if (position && position.isGLBufferAttribute) {

							console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);

							this.boundingSphere.set(new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), Infinity);

							return;

						}

						if (position) {

							// first, find the center of the bounding sphere

							const center = this.boundingSphere.center;

							_box.setFromBufferAttribute(position);

							// process morph attributes if present

							if (morphAttributesPosition) {

								for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

									const morphAttribute = morphAttributesPosition[i];
									_boxMorphTargets.setFromBufferAttribute(morphAttribute);

									if (this.morphTargetsRelative) {

										_vector.addVectors(_box.min, _boxMorphTargets.min);
										_box.expandByPoint(_vector);

										_vector.addVectors(_box.max, _boxMorphTargets.max);
										_box.expandByPoint(_vector);

									} else {

										_box.expandByPoint(_boxMorphTargets.min);
										_box.expandByPoint(_boxMorphTargets.max);

									}

								}

							}

							_box.getCenter(center);

							// second, try to find a boundingSphere with a radius smaller than the
							// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

							let maxRadiusSq = 0;

							for (let i = 0, il = position.count; i < il; i++) {

								_vector.fromBufferAttribute(position, i);

								maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));

							}

							// process morph attributes if present

							if (morphAttributesPosition) {

								for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {

									const morphAttribute = morphAttributesPosition[i];
									const morphTargetsRelative = this.morphTargetsRelative;

									for (let j = 0, jl = morphAttribute.count; j < jl; j++) {

										_vector.fromBufferAttribute(morphAttribute, j);

										if (morphTargetsRelative) {

											_offset.fromBufferAttribute(position, j);
											_vector.add(_offset);

										}

										maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));

									}

								}

							}

							this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

							if (isNaN(this.boundingSphere.radius)) {

								console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);

							}

						}

					}

					computeTangents() {

						const index = this.index;
						const attributes = this.attributes;

						// based on http://www.terathon.com/code/tangent.html
						// (per vertex tangents)

						if (index === null ||
							attributes.position === undefined ||
							attributes.normal === undefined ||
							attributes.uv === undefined) {

							console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
							return;

						}

						const indices = index.array;
						const positions = attributes.position.array;
						const normals = attributes.normal.array;
						const uvs = attributes.uv.array;

						const nVertices = positions.length / 3;

						if (attributes.tangent === undefined) {

							this.setAttribute('tangent', new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"](new Float32Array(4 * nVertices), 4));

						}

						const tangents = attributes.tangent.array;

						const tan1 = [], tan2 = [];

						for (let i = 0; i < nVertices; i++) {

							tan1[i] = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
							tan2[i] = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

						}

						const vA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
							vB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
							vC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),

							uvA = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](),
							uvB = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](),
							uvC = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](),

							sdir = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
							tdir = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

						function handleTriangle(a, b, c) {

							vA.fromArray(positions, a * 3);
							vB.fromArray(positions, b * 3);
							vC.fromArray(positions, c * 3);

							uvA.fromArray(uvs, a * 2);
							uvB.fromArray(uvs, b * 2);
							uvC.fromArray(uvs, c * 2);

							vB.sub(vA);
							vC.sub(vA);

							uvB.sub(uvA);
							uvC.sub(uvA);

							const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

							// silently ignore degenerate uv triangles having coincident or colinear vertices

							if (!isFinite(r)) return;

							sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, - uvB.y).multiplyScalar(r);
							tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, - uvC.x).multiplyScalar(r);

							tan1[a].add(sdir);
							tan1[b].add(sdir);
							tan1[c].add(sdir);

							tan2[a].add(tdir);
							tan2[b].add(tdir);
							tan2[c].add(tdir);

						}

						let groups = this.groups;

						if (groups.length === 0) {

							groups = [{
								start: 0,
								count: indices.length
							}];

						}

						for (let i = 0, il = groups.length; i < il; ++i) {

							const group = groups[i];

							const start = group.start;
							const count = group.count;

							for (let j = start, jl = start + count; j < jl; j += 3) {

								handleTriangle(
									indices[j + 0],
									indices[j + 1],
									indices[j + 2]
								);

							}

						}

						const tmp = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), tmp2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
						const n = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), n2 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

						function handleVertex(v) {

							n.fromArray(normals, v * 3);
							n2.copy(n);

							const t = tan1[v];

							// Gram-Schmidt orthogonalize

							tmp.copy(t);
							tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

							// Calculate handedness

							tmp2.crossVectors(n2, t);
							const test = tmp2.dot(tan2[v]);
							const w = (test < 0.0) ? - 1.0 : 1.0;

							tangents[v * 4] = tmp.x;
							tangents[v * 4 + 1] = tmp.y;
							tangents[v * 4 + 2] = tmp.z;
							tangents[v * 4 + 3] = w;

						}

						for (let i = 0, il = groups.length; i < il; ++i) {

							const group = groups[i];

							const start = group.start;
							const count = group.count;

							for (let j = start, jl = start + count; j < jl; j += 3) {

								handleVertex(indices[j + 0]);
								handleVertex(indices[j + 1]);
								handleVertex(indices[j + 2]);

							}

						}

					}

					computeVertexNormals() {

						const index = this.index;
						const positionAttribute = this.getAttribute('position');

						if (positionAttribute !== undefined) {

							let normalAttribute = this.getAttribute('normal');

							if (normalAttribute === undefined) {

								normalAttribute = new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"](new Float32Array(positionAttribute.count * 3), 3);
								this.setAttribute('normal', normalAttribute);

							} else {

								// reset existing normals to zero

								for (let i = 0, il = normalAttribute.count; i < il; i++) {

									normalAttribute.setXYZ(i, 0, 0, 0);

								}

							}

							const pA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), pB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), pC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
							const nA = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), nB = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), nC = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
							const cb = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), ab = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

							// indexed elements

							if (index) {

								for (let i = 0, il = index.count; i < il; i += 3) {

									const vA = index.getX(i + 0);
									const vB = index.getX(i + 1);
									const vC = index.getX(i + 2);

									pA.fromBufferAttribute(positionAttribute, vA);
									pB.fromBufferAttribute(positionAttribute, vB);
									pC.fromBufferAttribute(positionAttribute, vC);

									cb.subVectors(pC, pB);
									ab.subVectors(pA, pB);
									cb.cross(ab);

									nA.fromBufferAttribute(normalAttribute, vA);
									nB.fromBufferAttribute(normalAttribute, vB);
									nC.fromBufferAttribute(normalAttribute, vC);

									nA.add(cb);
									nB.add(cb);
									nC.add(cb);

									normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
									normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
									normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);

								}

							} else {

								// non-indexed elements (unconnected triangle soup)

								for (let i = 0, il = positionAttribute.count; i < il; i += 3) {

									pA.fromBufferAttribute(positionAttribute, i + 0);
									pB.fromBufferAttribute(positionAttribute, i + 1);
									pC.fromBufferAttribute(positionAttribute, i + 2);

									cb.subVectors(pC, pB);
									ab.subVectors(pA, pB);
									cb.cross(ab);

									normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
									normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
									normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);

								}

							}

							this.normalizeNormals();

							normalAttribute.needsUpdate = true;

						}

					}

					merge(geometry, offset) {

						if (!(geometry && geometry.isBufferGeometry)) {

							console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry);
							return;

						}

						if (offset === undefined) {

							offset = 0;

							console.warn(
								'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
								+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
							);

						}

						const attributes = this.attributes;

						for (const key in attributes) {

							if (geometry.attributes[key] === undefined) continue;

							const attribute1 = attributes[key];
							const attributeArray1 = attribute1.array;

							const attribute2 = geometry.attributes[key];
							const attributeArray2 = attribute2.array;

							const attributeOffset = attribute2.itemSize * offset;
							const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);

							for (let i = 0, j = attributeOffset; i < length; i++, j++) {

								attributeArray1[j] = attributeArray2[i];

							}

						}

						return this;

					}

					normalizeNormals() {

						const normals = this.attributes.normal;

						for (let i = 0, il = normals.count; i < il; i++) {

							_vector.fromBufferAttribute(normals, i);

							_vector.normalize();

							normals.setXYZ(i, _vector.x, _vector.y, _vector.z);

						}

					}

					toNonIndexed() {

						function convertBufferAttribute(attribute, indices) {

							const array = attribute.array;
							const itemSize = attribute.itemSize;
							const normalized = attribute.normalized;

							const array2 = new array.constructor(indices.length * itemSize);

							let index = 0, index2 = 0;

							for (let i = 0, l = indices.length; i < l; i++) {

								if (attribute.isInterleavedBufferAttribute) {

									index = indices[i] * attribute.data.stride + attribute.offset;

								} else {

									index = indices[i] * itemSize;

								}

								for (let j = 0; j < itemSize; j++) {

									array2[index2++] = array[index++];

								}

							}

							return new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_4__["BufferAttribute"](array2, itemSize, normalized);

						}

						//

						if (this.index === null) {

							console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
							return this;

						}

						const geometry2 = new BufferGeometry();

						const indices = this.index.array;
						const attributes = this.attributes;

						// attributes

						for (const name in attributes) {

							const attribute = attributes[name];

							const newAttribute = convertBufferAttribute(attribute, indices);

							geometry2.setAttribute(name, newAttribute);

						}

						// morph attributes

						const morphAttributes = this.morphAttributes;

						for (const name in morphAttributes) {

							const morphArray = [];
							const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

							for (let i = 0, il = morphAttribute.length; i < il; i++) {

								const attribute = morphAttribute[i];

								const newAttribute = convertBufferAttribute(attribute, indices);

								morphArray.push(newAttribute);

							}

							geometry2.morphAttributes[name] = morphArray;

						}

						geometry2.morphTargetsRelative = this.morphTargetsRelative;

						// groups

						const groups = this.groups;

						for (let i = 0, l = groups.length; i < l; i++) {

							const group = groups[i];
							geometry2.addGroup(group.start, group.count, group.materialIndex);

						}

						return geometry2;

					}

					toJSON() {

						const data = {
							metadata: {
								version: 4.5,
								type: 'BufferGeometry',
								generator: 'BufferGeometry.toJSON'
							}
						};

						// standard BufferGeometry serialization

						data.uuid = this.uuid;
						data.type = this.type;
						if (this.name !== '') data.name = this.name;
						if (Object.keys(this.userData).length > 0) data.userData = this.userData;

						if (this.parameters !== undefined) {

							const parameters = this.parameters;

							for (const key in parameters) {

								if (parameters[key] !== undefined) data[key] = parameters[key];

							}

							return data;

						}

						// for simplicity the code assumes attributes are not shared across geometries, see #15811

						data.data = { attributes: {} };

						const index = this.index;

						if (index !== null) {

							data.data.index = {
								type: index.array.constructor.name,
								array: Array.prototype.slice.call(index.array)
							};

						}

						const attributes = this.attributes;

						for (const key in attributes) {

							const attribute = attributes[key];

							data.data.attributes[key] = attribute.toJSON(data.data);

						}

						const morphAttributes = {};
						let hasMorphAttributes = false;

						for (const key in this.morphAttributes) {

							const attributeArray = this.morphAttributes[key];

							const array = [];

							for (let i = 0, il = attributeArray.length; i < il; i++) {

								const attribute = attributeArray[i];

								array.push(attribute.toJSON(data.data));

							}

							if (array.length > 0) {

								morphAttributes[key] = array;

								hasMorphAttributes = true;

							}

						}

						if (hasMorphAttributes) {

							data.data.morphAttributes = morphAttributes;
							data.data.morphTargetsRelative = this.morphTargetsRelative;

						}

						const groups = this.groups;

						if (groups.length > 0) {

							data.data.groups = JSON.parse(JSON.stringify(groups));

						}

						const boundingSphere = this.boundingSphere;

						if (boundingSphere !== null) {

							data.data.boundingSphere = {
								center: boundingSphere.center.toArray(),
								radius: boundingSphere.radius
							};

						}

						return data;

					}

					clone() {

						return new this.constructor().copy(this);

					}

					copy(source) {

						// reset

						this.index = null;
						this.attributes = {};
						this.morphAttributes = {};
						this.groups = [];
						this.boundingBox = null;
						this.boundingSphere = null;

						// used for storing cloned, shared data

						const data = {};

						// name

						this.name = source.name;

						// index

						const index = source.index;

						if (index !== null) {

							this.setIndex(index.clone(data));

						}

						// attributes

						const attributes = source.attributes;

						for (const name in attributes) {

							const attribute = attributes[name];
							this.setAttribute(name, attribute.clone(data));

						}

						// morph attributes

						const morphAttributes = source.morphAttributes;

						for (const name in morphAttributes) {

							const array = [];
							const morphAttribute = morphAttributes[name]; // morphAttribute: array of Float32BufferAttributes

							for (let i = 0, l = morphAttribute.length; i < l; i++) {

								array.push(morphAttribute[i].clone(data));

							}

							this.morphAttributes[name] = array;

						}

						this.morphTargetsRelative = source.morphTargetsRelative;

						// groups

						const groups = source.groups;

						for (let i = 0, l = groups.length; i < l; i++) {

							const group = groups[i];
							this.addGroup(group.start, group.count, group.materialIndex);

						}

						// bounding box

						const boundingBox = source.boundingBox;

						if (boundingBox !== null) {

							this.boundingBox = boundingBox.clone();

						}

						// bounding sphere

						const boundingSphere = source.boundingSphere;

						if (boundingSphere !== null) {

							this.boundingSphere = boundingSphere.clone();

						}

						// draw range

						this.drawRange.start = source.drawRange.start;
						this.drawRange.count = source.drawRange.count;

						// user data

						this.userData = source.userData;

						// geometry generator parameters

						if (source.parameters !== undefined) this.parameters = Object.assign({}, source.parameters);

						return this;

					}

					dispose() {

						this.dispatchEvent({ type: 'dispose' });

					}

				}

				BufferGeometry.prototype.isBufferGeometry = true;




				/***/
}),

/***/ "./libs/three/core/Clock.js":
/*!**********************************!*\
  !*** ./libs/three/core/Clock.js ***!
  \**********************************/
/*! exports provided: Clock */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function () { return Clock; });
				class Clock {

					constructor(autoStart = true) {

						this.autoStart = autoStart;

						this.startTime = 0;
						this.oldTime = 0;
						this.elapsedTime = 0;

						this.running = false;

					}

					start() {

						this.startTime = now();

						this.oldTime = this.startTime;
						this.elapsedTime = 0;
						this.running = true;

					}

					stop() {

						this.getElapsedTime();
						this.running = false;
						this.autoStart = false;

					}

					getElapsedTime() {

						this.getDelta();
						return this.elapsedTime;

					}

					getDelta() {

						let diff = 0;

						if (this.autoStart && !this.running) {

							this.start();
							return 0;

						}

						if (this.running) {

							const newTime = now();

							diff = (newTime - this.oldTime) / 1000;
							this.oldTime = newTime;

							this.elapsedTime += diff;

						}

						return diff;

					}

				}

				function now() {

					return (typeof performance === 'undefined' ? Date : performance).now(); // see #10732

				}




				/***/
}),

/***/ "./libs/three/core/EventDispatcher.js":
/*!********************************************!*\
  !*** ./libs/three/core/EventDispatcher.js ***!
  \********************************************/
/*! exports provided: EventDispatcher, EventType */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function () { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventType", function () { return EventType; });
				/**
				 * https://github.com/mrdoob/eventdispatcher.js/
				 */

				class EventDispatcher {

					addEventListener(type, listener) {

						if (this._listeners === undefined) this._listeners = {};

						const listeners = this._listeners;

						if (listeners[type] === undefined) {

							listeners[type] = [];

						}

						if (listeners[type].indexOf(listener) === - 1) {

							listeners[type].push(listener);

						}

					}

					hasEventListener(type, listener) {

						if (this._listeners === undefined) return false;

						const listeners = this._listeners;

						return listeners[type] !== undefined && listeners[type].indexOf(listener) !== - 1;

					}

					removeEventListener(type, listener) {

						if (this._listeners === undefined) return;

						const listeners = this._listeners;
						const listenerArray = listeners[type];

						if (listenerArray !== undefined) {
							const index = listenerArray.indexOf(listener);
							if (index !== - 1) {
								listenerArray.splice(index, 1);
							}
						}

					}
					removeAllEvent() {
						for (let key in this._listeners) {
							this._listeners[key] && this._listeners[key].splice(0, this._listeners[key].length);
							this._listeners[key] = undefined;
						}
					}

					dispatchEvent(event, data) {
						if (this._listeners === undefined) return;
						const listeners = this._listeners;
						const listenerArray = listeners[event.type];

						if (listenerArray !== undefined) {
							event.target = this;
							// Make a copy, in case listeners are removed while iterating.
							const array = listenerArray.slice(0);
							for (let i = 0, l = array.length; i < l; i++) {
								array[i].call(this, event, data);
							}
							event.target = null;
						}
					}
				}

				const EventType = {
					ENTERFRAME: "enterFrame"
				}





				/***/
}),

/***/ "./libs/three/core/InterleavedBuffer.js":
/*!**********************************************!*\
  !*** ./libs/three/core/InterleavedBuffer.js ***!
  \**********************************************/
/*! exports provided: InterleavedBuffer */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function () { return InterleavedBuffer; });
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");



				class InterleavedBuffer {

					constructor(array, stride) {

						this.array = array;
						this.stride = stride;
						this.count = array !== undefined ? array.length / stride : 0;

						this.usage = _constants_js__WEBPACK_IMPORTED_MODULE_1__["StaticDrawUsage"];
						this.updateRange = { offset: 0, count: - 1 };

						this.version = 0;

						this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["generateUUID"]();

					}

					onUploadCallback() { }

					set needsUpdate(value) {

						if (value === true) this.version++;

					}

					setUsage(value) {

						this.usage = value;

						return this;

					}

					copy(source) {

						this.array = new source.array.constructor(source.array);
						this.count = source.count;
						this.stride = source.stride;
						this.usage = source.usage;

						return this;

					}

					copyAt(index1, attribute, index2) {

						index1 *= this.stride;
						index2 *= attribute.stride;

						for (let i = 0, l = this.stride; i < l; i++) {

							this.array[index1 + i] = attribute.array[index2 + i];

						}

						return this;

					}

					set(value, offset = 0) {

						this.array.set(value, offset);

						return this;

					}

					clone(data) {

						if (data.arrayBuffers === undefined) {

							data.arrayBuffers = {};

						}

						if (this.array.buffer._uuid === undefined) {

							this.array.buffer._uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["generateUUID"]();

						}

						if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {

							data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;

						}

						const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);

						const ib = new this.constructor(array, this.stride);
						ib.setUsage(this.usage);

						return ib;

					}

					onUpload(callback) {

						this.onUploadCallback = callback;

						return this;

					}

					toJSON(data) {

						if (data.arrayBuffers === undefined) {

							data.arrayBuffers = {};

						}

						// generate UUID for array buffer if necessary

						if (this.array.buffer._uuid === undefined) {

							this.array.buffer._uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["generateUUID"]();

						}

						if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {

							data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));

						}

						//

						return {
							uuid: this.uuid,
							buffer: this.array.buffer._uuid,
							type: this.array.constructor.name,
							stride: this.stride
						};

					}

				}

				InterleavedBuffer.prototype.isInterleavedBuffer = true;




				/***/
}),

/***/ "./libs/three/core/InterleavedBufferAttribute.js":
/*!*******************************************************!*\
  !*** ./libs/three/core/InterleavedBufferAttribute.js ***!
  \*******************************************************/
/*! exports provided: InterleavedBufferAttribute */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function () { return InterleavedBufferAttribute; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");



				const _vector = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				class InterleavedBufferAttribute {

					constructor(interleavedBuffer, itemSize, offset, normalized = false) {

						this.name = '';

						this.data = interleavedBuffer;
						this.itemSize = itemSize;
						this.offset = offset;

						this.normalized = normalized === true;

					}

					get count() {

						return this.data.count;

					}

					get array() {

						return this.data.array;

					}

					set needsUpdate(value) {

						this.data.needsUpdate = value;

					}

					applyMatrix4(m) {

						for (let i = 0, l = this.data.count; i < l; i++) {

							_vector.x = this.getX(i);
							_vector.y = this.getY(i);
							_vector.z = this.getZ(i);

							_vector.applyMatrix4(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);

						}

						return this;

					}

					applyNormalMatrix(m) {

						for (let i = 0, l = this.count; i < l; i++) {

							_vector.x = this.getX(i);
							_vector.y = this.getY(i);
							_vector.z = this.getZ(i);

							_vector.applyNormalMatrix(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);

						}

						return this;

					}

					transformDirection(m) {

						for (let i = 0, l = this.count; i < l; i++) {

							_vector.x = this.getX(i);
							_vector.y = this.getY(i);
							_vector.z = this.getZ(i);

							_vector.transformDirection(m);

							this.setXYZ(i, _vector.x, _vector.y, _vector.z);

						}

						return this;

					}

					setX(index, x) {

						this.data.array[index * this.data.stride + this.offset] = x;

						return this;

					}

					setY(index, y) {

						this.data.array[index * this.data.stride + this.offset + 1] = y;

						return this;

					}

					setZ(index, z) {

						this.data.array[index * this.data.stride + this.offset + 2] = z;

						return this;

					}

					setW(index, w) {

						this.data.array[index * this.data.stride + this.offset + 3] = w;

						return this;

					}

					getX(index) {

						return this.data.array[index * this.data.stride + this.offset];

					}

					getY(index) {

						return this.data.array[index * this.data.stride + this.offset + 1];

					}

					getZ(index) {

						return this.data.array[index * this.data.stride + this.offset + 2];

					}

					getW(index) {

						return this.data.array[index * this.data.stride + this.offset + 3];

					}

					setXY(index, x, y) {

						index = index * this.data.stride + this.offset;

						this.data.array[index + 0] = x;
						this.data.array[index + 1] = y;

						return this;

					}

					setXYZ(index, x, y, z) {

						index = index * this.data.stride + this.offset;

						this.data.array[index + 0] = x;
						this.data.array[index + 1] = y;
						this.data.array[index + 2] = z;

						return this;

					}

					setXYZW(index, x, y, z, w) {

						index = index * this.data.stride + this.offset;

						this.data.array[index + 0] = x;
						this.data.array[index + 1] = y;
						this.data.array[index + 2] = z;
						this.data.array[index + 3] = w;

						return this;

					}

					clone(data) {

						if (data === undefined) {

							console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.');

							const array = [];

							for (let i = 0; i < this.count; i++) {

								const index = i * this.data.stride + this.offset;

								for (let j = 0; j < this.itemSize; j++) {

									array.push(this.data.array[index + j]);

								}

							}

							return new _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](new this.array.constructor(array), this.itemSize, this.normalized);

						} else {

							if (data.interleavedBuffers === undefined) {

								data.interleavedBuffers = {};

							}

							if (data.interleavedBuffers[this.data.uuid] === undefined) {

								data.interleavedBuffers[this.data.uuid] = this.data.clone(data);

							}

							return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);

						}

					}

					toJSON(data) {

						if (data === undefined) {

							console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.');

							const array = [];

							for (let i = 0; i < this.count; i++) {

								const index = i * this.data.stride + this.offset;

								for (let j = 0; j < this.itemSize; j++) {

									array.push(this.data.array[index + j]);

								}

							}

							// deinterleave data and save it as an ordinary buffer attribute for now

							return {
								itemSize: this.itemSize,
								type: this.array.constructor.name,
								array: array,
								normalized: this.normalized
							};

						} else {

							// save as true interlaved attribtue

							if (data.interleavedBuffers === undefined) {

								data.interleavedBuffers = {};

							}

							if (data.interleavedBuffers[this.data.uuid] === undefined) {

								data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);

							}

							return {
								isInterleavedBufferAttribute: true,
								itemSize: this.itemSize,
								data: this.data.uuid,
								offset: this.offset,
								normalized: this.normalized
							};

						}

					}

				}

				InterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;





				/***/
}),

/***/ "./libs/three/core/Layers.js":
/*!***********************************!*\
  !*** ./libs/three/core/Layers.js ***!
  \***********************************/
/*! exports provided: Layers */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function () { return Layers; });
				class Layers {

					constructor() {

						this.mask = 1 | 0;

					}

					set(channel) {

						this.mask = 1 << channel | 0;

					}

					enable(channel) {

						this.mask |= 1 << channel | 0;

					}

					enableAll() {

						this.mask = 0xffffffff | 0;

					}

					toggle(channel) {

						this.mask ^= 1 << channel | 0;

					}

					disable(channel) {

						this.mask &= ~(1 << channel | 0);

					}

					disableAll() {

						this.mask = 0;

					}

					test(layers) {

						return (this.mask & layers.mask) !== 0;

					}

				}





				/***/
}),

/***/ "./libs/three/core/Object3D.js":
/*!*************************************!*\
  !*** ./libs/three/core/Object3D.js ***!
  \*************************************/
/*! exports provided: Object3D */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function () { return Object3D; });
/* harmony import */ var _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Quaternion.js */ "./libs/three/math/Quaternion.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EventDispatcher.js */ "./libs/three/core/EventDispatcher.js");
/* harmony import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Euler.js */ "./libs/three/math/Euler.js");
/* harmony import */ var _Layers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Layers.js */ "./libs/three/core/Layers.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Matrix3.js */ "./libs/three/math/Matrix3.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");









				let _object3DId = 0;

				const _v1 = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _q1 = /*@__PURE__*/ new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
				const _m1 = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
				const _target = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

				const _position = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _scale = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _quaternion = /*@__PURE__*/ new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

				const _xAxis = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](1, 0, 0);
				const _yAxis = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, 1, 0);
				const _zAxis = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, 0, 1);

				const _addedEvent = { type: 'added' };
				const _removedEvent = { type: 'removed' };

				class Object3D extends _EventDispatcher_js__WEBPACK_IMPORTED_MODULE_3__["EventDispatcher"] {

					constructor() {

						super();

						Object.defineProperty(this, 'id', { value: _object3DId++ });

						this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_7__["generateUUID"]();

						this.name = '';
						this.type = 'Object3D';

						this.parent = null;
						this.children = [];

						this.up = Object3D.DefaultUp.clone();

						const position = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
						const rotation = new _math_Euler_js__WEBPACK_IMPORTED_MODULE_4__["Euler"]();
						const quaternion = new _math_Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();
						const scale = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](1, 1, 1);

						function onRotationChange() {

							quaternion.setFromEuler(rotation, false);

						}

						function onQuaternionChange() {

							rotation.setFromQuaternion(quaternion, undefined, false);

						}

						rotation._onChange(onRotationChange);
						quaternion._onChange(onQuaternionChange);

						Object.defineProperties(this, {
							position: {
								configurable: true,
								enumerable: true,
								value: position
							},
							rotation: {
								configurable: true,
								enumerable: true,
								value: rotation
							},
							quaternion: {
								configurable: true,
								enumerable: true,
								value: quaternion
							},
							scale: {
								configurable: true,
								enumerable: true,
								value: scale
							},
							modelViewMatrix: {
								value: new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]()
							},
							normalMatrix: {
								value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__["Matrix3"]()
							}
						});

						this.matrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
						this.matrixWorld = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

						this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
						this.matrixWorldNeedsUpdate = false;

						this.layers = new _Layers_js__WEBPACK_IMPORTED_MODULE_5__["Layers"]();
						this.visible = true;

						this.castShadow = false;
						this.receiveShadow = false;

						this.frustumCulled = true;
						this.renderOrder = 0;

						this.animations = [];

						this.userData = {};

					}

					onBeforeRender( /* renderer, scene, camera, geometry, material, group */) { }

					onAfterRender( /* renderer, scene, camera, geometry, material, group */) { }

					applyMatrix4(matrix) {

						if (this.matrixAutoUpdate) this.updateMatrix();

						this.matrix.premultiply(matrix);

						this.matrix.decompose(this.position, this.quaternion, this.scale);

					}


					setPosition(x, y, z) {
						this.position.set(x, y, z);
					}

					applyQuaternion(q) {

						this.quaternion.premultiply(q);

						return this;

					}

					setRotationFromAxisAngle(axis, angle) {

						// assumes axis is normalized

						this.quaternion.setFromAxisAngle(axis, angle);

					}

					setRotationFromEuler(euler) {

						this.quaternion.setFromEuler(euler, true);

					}

					setRotationFromMatrix(m) {

						// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

						this.quaternion.setFromRotationMatrix(m);

					}

					setRotationFromQuaternion(q) {

						// assumes q is normalized

						this.quaternion.copy(q);

					}

					rotateOnAxis(axis, angle) {

						// rotate object on axis in object space
						// axis is assumed to be normalized

						_q1.setFromAxisAngle(axis, angle);

						this.quaternion.multiply(_q1);

						return this;

					}

					rotateOnWorldAxis(axis, angle) {

						// rotate object on axis in world space
						// axis is assumed to be normalized
						// method assumes no rotated parent

						_q1.setFromAxisAngle(axis, angle);

						this.quaternion.premultiply(_q1);

						return this;

					}

					rotateX(angle) {

						return this.rotateOnAxis(_xAxis, angle);

					}

					rotateY(angle) {

						return this.rotateOnAxis(_yAxis, angle);

					}

					rotateZ(angle) {

						return this.rotateOnAxis(_zAxis, angle);

					}

					translateOnAxis(axis, distance) {

						// translate object by distance along axis in object space
						// axis is assumed to be normalized

						_v1.copy(axis).applyQuaternion(this.quaternion);

						this.position.add(_v1.multiplyScalar(distance));

						return this;

					}

					translateX(distance) {

						return this.translateOnAxis(_xAxis, distance);

					}

					translateY(distance) {

						return this.translateOnAxis(_yAxis, distance);

					}

					translateZ(distance) {

						return this.translateOnAxis(_zAxis, distance);

					}

					localToWorld(vector) {

						return vector.applyMatrix4(this.matrixWorld);

					}

					worldToLocal(vector) {

						return vector.applyMatrix4(_m1.copy(this.matrixWorld).invert());

					}

					lookAt(x, y, z) {

						// This method does not support objects having non-uniformly-scaled parent(s)

						if (x.isVector3) {

							_target.copy(x);

						} else {

							_target.set(x, y, z);

						}

						const parent = this.parent;

						this.updateWorldMatrix(true, false);

						_position.setFromMatrixPosition(this.matrixWorld);

						if (this.isCamera || this.isLight) {

							_m1.lookAt(_position, _target, this.up);

						} else {

							_m1.lookAt(_target, _position, this.up);

						}

						this.quaternion.setFromRotationMatrix(_m1);

						if (parent) {

							_m1.extractRotation(parent.matrixWorld);
							_q1.setFromRotationMatrix(_m1);
							this.quaternion.premultiply(_q1.invert());

						}

					}

					add(object) {

						if (arguments.length > 1) {

							for (let i = 0; i < arguments.length; i++) {

								this.add(arguments[i]);

							}

							return this;

						}

						if (object === this) {

							console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
							return this;

						}

						if (object && object.isObject3D) {

							if (object.parent !== null) {

								object.parent.remove(object);

							}

							object.parent = this;
							this.children.push(object);

							object.dispatchEvent(_addedEvent);

						} else {

							console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);

						}

						return this;

					}

					remove(object) {

						if (arguments.length > 1) {

							for (let i = 0; i < arguments.length; i++) {

								this.remove(arguments[i]);

							}

							return this;

						}

						const index = this.children.indexOf(object);

						if (index !== - 1) {

							object.parent = null;
							this.children.splice(index, 1);

							object.dispatchEvent(_removedEvent);

						}

						return this;

					}

					removeFromParent() {

						const parent = this.parent;

						if (parent !== null) {

							parent.remove(this);

						}

						return this;

					}

					clear() {

						for (let i = 0; i < this.children.length; i++) {

							const object = this.children[i];

							object.parent = null;

							object.dispatchEvent(_removedEvent);

						}

						this.children.length = 0;

						return this;


					}

					attach(object) {

						// adds object as a child of this, while maintaining the object's world transform

						this.updateWorldMatrix(true, false);

						_m1.copy(this.matrixWorld).invert();

						if (object.parent !== null) {

							object.parent.updateWorldMatrix(true, false);

							_m1.multiply(object.parent.matrixWorld);

						}

						object.applyMatrix4(_m1);

						this.add(object);

						object.updateWorldMatrix(false, true);

						return this;

					}

					getObjectById(id) {

						return this.getObjectByProperty('id', id);

					}

					getObjectByName(name) {

						return this.getObjectByProperty('name', name);

					}

					getObjectByProperty(name, value) {

						if (this[name] === value) return this;

						for (let i = 0, l = this.children.length; i < l; i++) {

							const child = this.children[i];
							const object = child.getObjectByProperty(name, value);

							if (object !== undefined) {

								return object;

							}

						}

						return undefined;

					}

					getWorldPosition(target) {

						this.updateWorldMatrix(true, false);

						return target.setFromMatrixPosition(this.matrixWorld);

					}

					getWorldQuaternion(target) {

						this.updateWorldMatrix(true, false);

						this.matrixWorld.decompose(_position, target, _scale);

						return target;

					}

					getWorldScale(target) {

						this.updateWorldMatrix(true, false);

						this.matrixWorld.decompose(_position, _quaternion, target);

						return target;

					}

					getWorldDirection(target) {

						this.updateWorldMatrix(true, false);

						const e = this.matrixWorld.elements;

						return target.set(e[8], e[9], e[10]).normalize();

					}

					raycast() { }

					traverse(callback) {

						callback(this);

						const children = this.children;

						for (let i = 0, l = children.length; i < l; i++) {

							children[i].traverse(callback);

						}

					}

					traverseVisible(callback) {

						if (this.visible === false) return;

						callback(this);

						const children = this.children;

						for (let i = 0, l = children.length; i < l; i++) {

							children[i].traverseVisible(callback);

						}

					}

					traverseAncestors(callback) {

						const parent = this.parent;

						if (parent !== null) {

							callback(parent);

							parent.traverseAncestors(callback);

						}

					}

					updateMatrix() {

						this.matrix.compose(this.position, this.quaternion, this.scale);

						this.matrixWorldNeedsUpdate = true;

					}

					updateMatrixWorld(force) {

						if (this.matrixAutoUpdate) this.updateMatrix();

						if (this.matrixWorldNeedsUpdate || force) {

							if (this.parent === null) {

								this.matrixWorld.copy(this.matrix);

							} else {

								this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);

							}

							this.matrixWorldNeedsUpdate = false;

							force = true;

						}

						// update children

						const children = this.children;

						for (let i = 0, l = children.length; i < l; i++) {

							children[i].updateMatrixWorld(force);

						}

					}

					updateWorldMatrix(updateParents, updateChildren) {

						const parent = this.parent;

						if (updateParents === true && parent !== null) {

							parent.updateWorldMatrix(true, false);

						}

						if (this.matrixAutoUpdate) this.updateMatrix();

						if (this.parent === null) {

							this.matrixWorld.copy(this.matrix);

						} else {

							this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);

						}

						// update children

						if (updateChildren === true) {

							const children = this.children;

							for (let i = 0, l = children.length; i < l; i++) {

								children[i].updateWorldMatrix(false, true);

							}

						}

					}

					toJSON(meta) {

						// meta is a string when called from JSON.stringify
						const isRootObject = (meta === undefined || typeof meta === 'string');

						const output = {};

						// meta is a hash used to collect geometries, materials.
						// not providing it implies that this is the root object
						// being serialized.
						if (isRootObject) {

							// initialize meta obj
							meta = {
								geometries: {},
								materials: {},
								textures: {},
								images: {},
								shapes: {},
								skeletons: {},
								animations: {}
							};

							output.metadata = {
								version: 4.5,
								type: 'Object',
								generator: 'Object3D.toJSON'
							};

						}

						// standard Object3D serialization

						const object = {};

						object.uuid = this.uuid;
						object.type = this.type;

						if (this.name !== '') object.name = this.name;
						if (this.castShadow === true) object.castShadow = true;
						if (this.receiveShadow === true) object.receiveShadow = true;
						if (this.visible === false) object.visible = false;
						if (this.frustumCulled === false) object.frustumCulled = false;
						if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
						if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData;

						object.layers = this.layers.mask;
						object.matrix = this.matrix.toArray();

						if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

						// object specific properties

						if (this.isInstancedMesh) {

							object.type = 'InstancedMesh';
							object.count = this.count;
							object.instanceMatrix = this.instanceMatrix.toJSON();
							if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();

						}

						//

						function serialize(library, element) {

							if (library[element.uuid] === undefined) {

								library[element.uuid] = element.toJSON(meta);

							}

							return element.uuid;

						}

						if (this.isScene) {

							if (this.background) {

								if (this.background.isColor) {

									object.background = this.background.toJSON();

								} else if (this.background.isTexture) {

									object.background = this.background.toJSON(meta).uuid;

								}

							}

							if (this.environment && this.environment.isTexture) {

								object.environment = this.environment.toJSON(meta).uuid;

							}

						} else if (this.isMesh || this.isLine || this.isPoints) {

							object.geometry = serialize(meta.geometries, this.geometry);

							const parameters = this.geometry.parameters;

							if (parameters !== undefined && parameters.shapes !== undefined) {

								const shapes = parameters.shapes;

								if (Array.isArray(shapes)) {

									for (let i = 0, l = shapes.length; i < l; i++) {

										const shape = shapes[i];

										serialize(meta.shapes, shape);

									}

								} else {

									serialize(meta.shapes, shapes);

								}

							}

						}

						if (this.isSkinnedMesh) {

							object.bindMode = this.bindMode;
							object.bindMatrix = this.bindMatrix.toArray();

							if (this.skeleton !== undefined) {

								serialize(meta.skeletons, this.skeleton);

								object.skeleton = this.skeleton.uuid;

							}

						}

						if (this.material !== undefined) {

							if (Array.isArray(this.material)) {

								const uuids = [];

								for (let i = 0, l = this.material.length; i < l; i++) {

									uuids.push(serialize(meta.materials, this.material[i]));

								}

								object.material = uuids;

							} else {

								object.material = serialize(meta.materials, this.material);

							}

						}

						//

						if (this.children.length > 0) {

							object.children = [];

							for (let i = 0; i < this.children.length; i++) {

								object.children.push(this.children[i].toJSON(meta).object);

							}

						}

						//

						if (this.animations.length > 0) {

							object.animations = [];

							for (let i = 0; i < this.animations.length; i++) {

								const animation = this.animations[i];

								object.animations.push(serialize(meta.animations, animation));

							}

						}

						if (isRootObject) {

							const geometries = extractFromCache(meta.geometries);
							const materials = extractFromCache(meta.materials);
							const textures = extractFromCache(meta.textures);
							const images = extractFromCache(meta.images);
							const shapes = extractFromCache(meta.shapes);
							const skeletons = extractFromCache(meta.skeletons);
							const animations = extractFromCache(meta.animations);

							if (geometries.length > 0) output.geometries = geometries;
							if (materials.length > 0) output.materials = materials;
							if (textures.length > 0) output.textures = textures;
							if (images.length > 0) output.images = images;
							if (shapes.length > 0) output.shapes = shapes;
							if (skeletons.length > 0) output.skeletons = skeletons;
							if (animations.length > 0) output.animations = animations;

						}

						output.object = object;

						return output;

						// extract data from the cache hash
						// remove metadata on each item
						// and return as array
						function extractFromCache(cache) {

							const values = [];
							for (const key in cache) {

								const data = cache[key];
								delete data.metadata;
								values.push(data);

							}

							return values;

						}

					}

					clone(recursive) {

						return new this.constructor().copy(this, recursive);

					}

					copy(source, recursive = true) {

						this.name = source.name;

						this.up.copy(source.up);

						this.position.copy(source.position);
						this.rotation.order = source.rotation.order;
						this.quaternion.copy(source.quaternion);
						this.scale.copy(source.scale);

						this.matrix.copy(source.matrix);
						this.matrixWorld.copy(source.matrixWorld);

						this.matrixAutoUpdate = source.matrixAutoUpdate;
						this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

						this.layers.mask = source.layers.mask;
						this.visible = source.visible;

						this.castShadow = source.castShadow;
						this.receiveShadow = source.receiveShadow;

						this.frustumCulled = source.frustumCulled;
						this.renderOrder = source.renderOrder;

						this.userData = JSON.parse(JSON.stringify(source.userData));

						if (recursive === true) {

							for (let i = 0; i < source.children.length; i++) {

								const child = source.children[i];
								this.add(child.clone());

							}

						}

						return this;

					}

				}

				Object3D.DefaultUp = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](0, 1, 0);
				Object3D.DefaultMatrixAutoUpdate = true;

				Object3D.prototype.isObject3D = true;




				/***/
}),

/***/ "./libs/three/extras/ImageUtils.js":
/*!*****************************************!*\
  !*** ./libs/three/extras/ImageUtils.js ***!
  \*****************************************/
/*! exports provided: ImageUtils */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function () { return ImageUtils; });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./libs/three/utils.js");


				let _canvas;

				class ImageUtils {

					static getDataURL(image) {

						if (/^data:/i.test(image.src)) {

							return image.src;

						}

						if (typeof HTMLCanvasElement == 'undefined') {

							return image.src;

						}

						let canvas;

						if (image instanceof HTMLCanvasElement) {

							canvas = image;

						} else {

							if (_canvas === undefined) _canvas = Object(_utils_js__WEBPACK_IMPORTED_MODULE_0__["createElementNS"])('canvas');

							_canvas.width = image.width;
							_canvas.height = image.height;

							const context = _canvas.getContext('2d');

							if (image instanceof ImageData) {

								context.putImageData(image, 0, 0);

							} else {

								context.drawImage(image, 0, 0, image.width, image.height);

							}

							canvas = _canvas;

						}

						if (canvas.width > 2048 || canvas.height > 2048) {

							console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);

							return canvas.toDataURL('image/jpeg', 0.6);

						} else {

							return canvas.toDataURL('image/png');

						}

					}

				}




				/***/
}),

/***/ "./libs/three/extras/PMREMGenerator.js":
/*!*********************************************!*\
  !*** ./libs/three/extras/PMREMGenerator.js ***!
  \*********************************************/
/*! exports provided: PMREMGenerator */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PMREMGenerator", function () { return PMREMGenerator; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "./libs/three/core/BufferGeometry.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../objects/Mesh.js */ "./libs/three/objects/Mesh.js");
/* harmony import */ var _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cameras/OrthographicCamera.js */ "./libs/three/cameras/OrthographicCamera.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cameras/PerspectiveCamera.js */ "./libs/three/cameras/PerspectiveCamera.js");
/* harmony import */ var _materials_RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../materials/RawShaderMaterial.js */ "./libs/three/materials/RawShaderMaterial.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../math/Color.js */ "./libs/three/math/Color.js");
/* harmony import */ var _renderers_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../renderers/WebGLRenderTarget.js */ "./libs/three/renderers/WebGLRenderTarget.js");
/* harmony import */ var _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../materials/MeshBasicMaterial.js */ "./libs/three/materials/MeshBasicMaterial.js");
/* harmony import */ var _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../geometries/BoxGeometry.js */ "./libs/three/geometries/BoxGeometry.js");
















				const LOD_MIN = 4;
				const LOD_MAX = 8;
				const SIZE_MAX = Math.pow(2, LOD_MAX);

				// The standard deviations (radians) associated with the extra mips. These are
				// chosen to approximate a Trowbridge-Reitz distribution function times the
				// geometric shadowing function. These sigma values squared must match the
				// variance #defines in cube_uv_reflection_fragment.glsl.js.
				const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];

				const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

				// The maximum length of the blur for loop. Smaller sigmas will use fewer
				// samples and exit early, but not recompile the shader.
				const MAX_SAMPLES = 20;

				const ENCODINGS = {
					[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]]: 0,
					[_constants_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"]]: 1,
					[_constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBEEncoding"]]: 2,
					[_constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBM7Encoding"]]: 3,
					[_constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBM16Encoding"]]: 4,
					[_constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBDEncoding"]]: 5,
					[_constants_js__WEBPACK_IMPORTED_MODULE_0__["GammaEncoding"]]: 6
				};

				const _flatCamera = /*@__PURE__*/ new _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_4__["OrthographicCamera"]();
				const { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();
				const _clearColor = /*@__PURE__*/ new _math_Color_js__WEBPACK_IMPORTED_MODULE_9__["Color"]();
				let _oldTarget = null;

				// Golden Ratio
				const PHI = (1 + Math.sqrt(5)) / 2;
				const INV_PHI = 1 / PHI;

				// Vertices of a dodecahedron (except the opposites, which represent the
				// same axis), used as axis directions evenly spread on a sphere.
				const _axisDirections = [
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](1, 1, 1),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](- 1, 1, 1),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](1, 1, - 1),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](- 1, 1, - 1),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](0, PHI, INV_PHI),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](0, PHI, - INV_PHI),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](INV_PHI, 0, PHI),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](- INV_PHI, 0, PHI),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](PHI, INV_PHI, 0),
	/*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](- PHI, INV_PHI, 0)];

				/**
				 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
				 * (PMREM) from a cubeMap environment texture. This allows different levels of
				 * blur to be quickly accessed based on material roughness. It is packed into a
				 * special CubeUV format that allows us to perform custom interpolation so that
				 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
				 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
				 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
				 * higher roughness levels. In this way we maintain resolution to smoothly
				 * interpolate diffuse lighting while limiting sampling computation.
				 *
				 * Paper: Fast, Accurate Image-Based Lighting
				 * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
				*/

				class PMREMGenerator {

					constructor(renderer) {

						this._renderer = renderer;
						this._pingPongRenderTarget = null;

						this._blurMaterial = _getBlurShader(MAX_SAMPLES);
						this._equirectShader = null;
						this._cubemapShader = null;

						this._compileMaterial(this._blurMaterial);

					}

					/**
					 * Generates a PMREM from a supplied Scene, which can be faster than using an
					 * image if networking bandwidth is low. Optional sigma specifies a blur radius
					 * in radians to be applied to the scene before PMREM generation. Optional near
					 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
					 * is placed at the origin).
					 */
					fromScene(scene, sigma = 0, near = 0.1, far = 100) {

						_oldTarget = this._renderer.getRenderTarget();
						const cubeUVRenderTarget = this._allocateTargets();

						this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
						if (sigma > 0) {

							this._blur(cubeUVRenderTarget, 0, 0, sigma);

						}

						this._applyPMREM(cubeUVRenderTarget);
						this._cleanup(cubeUVRenderTarget);

						return cubeUVRenderTarget;

					}

					/**
					 * Generates a PMREM from an equirectangular texture, which can be either LDR
					 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
					 * as this matches best with the 256 x 256 cubemap output.
					 */
					fromEquirectangular(equirectangular) {

						return this._fromTexture(equirectangular);

					}

					/**
					 * Generates a PMREM from an cubemap texture, which can be either LDR
					 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
					 * as this matches best with the 256 x 256 cubemap output.
					 */
					fromCubemap(cubemap) {

						return this._fromTexture(cubemap);

					}

					/**
					 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
					 * your texture's network fetch for increased concurrency.
					 */
					compileCubemapShader() {

						if (this._cubemapShader === null) {

							this._cubemapShader = _getCubemapShader();
							this._compileMaterial(this._cubemapShader);

						}

					}

					/**
					 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
					 * your texture's network fetch for increased concurrency.
					 */
					compileEquirectangularShader() {

						if (this._equirectShader === null) {

							this._equirectShader = _getEquirectShader();
							this._compileMaterial(this._equirectShader);

						}

					}

					/**
					 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
					 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
					 * one of them will cause any others to also become unusable.
					 */
					dispose() {

						this._blurMaterial.dispose();

						if (this._cubemapShader !== null) this._cubemapShader.dispose();
						if (this._equirectShader !== null) this._equirectShader.dispose();

						for (let i = 0; i < _lodPlanes.length; i++) {

							_lodPlanes[i].dispose();

						}

					}

					// private interface

					_cleanup(outputTarget) {

						this._pingPongRenderTarget.dispose();
						this._renderer.setRenderTarget(_oldTarget);
						outputTarget.scissorTest = false;
						_setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);

					}

					_fromTexture(texture) {

						_oldTarget = this._renderer.getRenderTarget();
						const cubeUVRenderTarget = this._allocateTargets(texture);
						this._textureToCubeUV(texture, cubeUVRenderTarget);
						this._applyPMREM(cubeUVRenderTarget);
						this._cleanup(cubeUVRenderTarget);

						return cubeUVRenderTarget;

					}

					_allocateTargets(texture) { // warning: null texture is valid

						const params = {
							magFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
							minFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
							generateMipmaps: false,
							type: _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"],
							format: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBEFormat"],
							encoding: _isLDR(texture) ? texture.encoding : _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBEEncoding"],
							depthBuffer: false
						};

						const cubeUVRenderTarget = _createRenderTarget(params);
						cubeUVRenderTarget.depthBuffer = texture ? false : true;
						this._pingPongRenderTarget = _createRenderTarget(params);
						return cubeUVRenderTarget;

					}

					_compileMaterial(material) {

						const tmpMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"](_lodPlanes[0], material);
						this._renderer.compile(tmpMesh, _flatCamera);

					}

					_sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {

						const fov = 90;
						const aspect = 1;
						const cubeCamera = new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_5__["PerspectiveCamera"](fov, aspect, near, far);
						const upSign = [1, - 1, 1, 1, 1, 1];
						const forwardSign = [1, 1, 1, - 1, - 1, - 1];
						const renderer = this._renderer;

						const originalAutoClear = renderer.autoClear;
						const outputEncoding = renderer.outputEncoding;
						const toneMapping = renderer.toneMapping;
						renderer.getClearColor(_clearColor);

						renderer.toneMapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoToneMapping"];
						renderer.outputEncoding = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"];
						renderer.autoClear = false;

						const backgroundMaterial = new _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_11__["MeshBasicMaterial"]({
							name: 'PMREM.Background',
							side: _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"],
							depthWrite: false,
							depthTest: false,
						});

						const backgroundBox = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"](new _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_12__["BoxGeometry"](), backgroundMaterial);

						let useSolidColor = false;
						const background = scene.background;

						if (background) {

							if (background.isColor) {

								backgroundMaterial.color.copy(background);
								scene.background = null;
								useSolidColor = true;

							}

						} else {

							backgroundMaterial.color.copy(_clearColor);
							useSolidColor = true;

						}

						for (let i = 0; i < 6; i++) {

							const col = i % 3;
							if (col == 0) {

								cubeCamera.up.set(0, upSign[i], 0);
								cubeCamera.lookAt(forwardSign[i], 0, 0);

							} else if (col == 1) {

								cubeCamera.up.set(0, 0, upSign[i]);
								cubeCamera.lookAt(0, forwardSign[i], 0);

							} else {

								cubeCamera.up.set(0, upSign[i], 0);
								cubeCamera.lookAt(0, 0, forwardSign[i]);

							}

							_setViewport(cubeUVRenderTarget,
								col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
							renderer.setRenderTarget(cubeUVRenderTarget);

							if (useSolidColor) {

								renderer.render(backgroundBox, cubeCamera);

							}

							renderer.render(scene, cubeCamera);

						}

						backgroundBox.geometry.dispose();
						backgroundBox.material.dispose();

						renderer.toneMapping = toneMapping;
						renderer.outputEncoding = outputEncoding;
						renderer.autoClear = originalAutoClear;
						scene.background = background;

					}

					_setEncoding(uniform, texture) {

						if (this._renderer.capabilities.isWebGL2 === true && texture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] && texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"] && texture.encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"]) {

							uniform.value = ENCODINGS[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]];

						} else {

							uniform.value = ENCODINGS[texture.encoding];

						}

					}

					_textureToCubeUV(texture, cubeUVRenderTarget) {

						const renderer = this._renderer;

						const isCubeTexture = (texture.mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeReflectionMapping"] || texture.mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeRefractionMapping"]);

						if (isCubeTexture) {

							if (this._cubemapShader == null) {

								this._cubemapShader = _getCubemapShader();

							}

						} else {

							if (this._equirectShader == null) {

								this._equirectShader = _getEquirectShader();

							}

						}

						const material = isCubeTexture ? this._cubemapShader : this._equirectShader;
						const mesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"](_lodPlanes[0], material);

						const uniforms = material.uniforms;

						uniforms['envMap'].value = texture;

						if (!isCubeTexture) {

							uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);

						}

						this._setEncoding(uniforms['inputEncoding'], texture);
						this._setEncoding(uniforms['outputEncoding'], cubeUVRenderTarget.texture);

						_setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);

						renderer.setRenderTarget(cubeUVRenderTarget);
						renderer.render(mesh, _flatCamera);

					}

					_applyPMREM(cubeUVRenderTarget) {

						const renderer = this._renderer;
						const autoClear = renderer.autoClear;
						renderer.autoClear = false;

						for (let i = 1; i < TOTAL_LODS; i++) {

							const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);

							const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];

							this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);

						}

						renderer.autoClear = autoClear;

					}

					/**
					 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
					 * vertically and horizontally, but this breaks down on a cube. Here we apply
					 * the blur latitudinally (around the poles), and then longitudinally (towards
					 * the poles) to approximate the orthogonally-separable blur. It is least
					 * accurate at the poles, but still does a decent job.
					 */
					_blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {

						const pingPongRenderTarget = this._pingPongRenderTarget;

						this._halfBlur(
							cubeUVRenderTarget,
							pingPongRenderTarget,
							lodIn,
							lodOut,
							sigma,
							'latitudinal',
							poleAxis);

						this._halfBlur(
							pingPongRenderTarget,
							cubeUVRenderTarget,
							lodOut,
							lodOut,
							sigma,
							'longitudinal',
							poleAxis);

					}

					_halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {

						const renderer = this._renderer;
						const blurMaterial = this._blurMaterial;

						if (direction !== 'latitudinal' && direction !== 'longitudinal') {

							console.error(
								'blur direction must be either latitudinal or longitudinal!');

						}

						// Number of standard deviations at which to cut off the discrete approximation.
						const STANDARD_DEVIATIONS = 3;

						const blurMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_3__["Mesh"](_lodPlanes[lodOut], blurMaterial);
						const blurUniforms = blurMaterial.uniforms;

						const pixels = _sizeLods[lodIn] - 1;
						const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
						const sigmaPixels = sigmaRadians / radiansPerPixel;
						const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;

						if (samples > MAX_SAMPLES) {

							console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);

						}

						const weights = [];
						let sum = 0;

						for (let i = 0; i < MAX_SAMPLES; ++i) {

							const x = i / sigmaPixels;
							const weight = Math.exp(- x * x / 2);
							weights.push(weight);

							if (i == 0) {

								sum += weight;

							} else if (i < samples) {

								sum += 2 * weight;

							}

						}

						for (let i = 0; i < weights.length; i++) {

							weights[i] = weights[i] / sum;

						}

						blurUniforms['envMap'].value = targetIn.texture;
						blurUniforms['samples'].value = samples;
						blurUniforms['weights'].value = weights;
						blurUniforms['latitudinal'].value = direction === 'latitudinal';

						if (poleAxis) {

							blurUniforms['poleAxis'].value = poleAxis;

						}

						blurUniforms['dTheta'].value = radiansPerPixel;
						blurUniforms['mipInt'].value = LOD_MAX - lodIn;

						this._setEncoding(blurUniforms['inputEncoding'], targetIn.texture);
						this._setEncoding(blurUniforms['outputEncoding'], targetIn.texture);

						const outputSize = _sizeLods[lodOut];
						const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
						const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);

						_setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
						renderer.setRenderTarget(targetOut);
						renderer.render(blurMesh, _flatCamera);

					}

				}

				function _isLDR(texture) {

					if (texture === undefined || texture.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"]) return false;

					return texture.encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"] || texture.encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"] || texture.encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["GammaEncoding"];

				}

				function _createPlanes() {

					const _lodPlanes = [];
					const _sizeLods = [];
					const _sigmas = [];

					let lod = LOD_MAX;

					for (let i = 0; i < TOTAL_LODS; i++) {

						const sizeLod = Math.pow(2, lod);
						_sizeLods.push(sizeLod);
						let sigma = 1.0 / sizeLod;

						if (i > LOD_MAX - LOD_MIN) {

							sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];

						} else if (i == 0) {

							sigma = 0;

						}

						_sigmas.push(sigma);

						const texelSize = 1.0 / (sizeLod - 1);
						const min = - texelSize / 2;
						const max = 1 + texelSize / 2;
						const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];

						const cubeFaces = 6;
						const vertices = 6;
						const positionSize = 3;
						const uvSize = 2;
						const faceIndexSize = 1;

						const position = new Float32Array(positionSize * vertices * cubeFaces);
						const uv = new Float32Array(uvSize * vertices * cubeFaces);
						const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);

						for (let face = 0; face < cubeFaces; face++) {

							const x = (face % 3) * 2 / 3 - 1;
							const y = face > 2 ? 0 : - 1;
							const coordinates = [
								x, y, 0,
								x + 2 / 3, y, 0,
								x + 2 / 3, y + 1, 0,
								x, y, 0,
								x + 2 / 3, y + 1, 0,
								x, y + 1, 0
							];
							position.set(coordinates, positionSize * vertices * face);
							uv.set(uv1, uvSize * vertices * face);
							const fill = [face, face, face, face, face, face];
							faceIndex.set(fill, faceIndexSize * vertices * face);

						}

						const planes = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_2__["BufferGeometry"]();
						planes.setAttribute('position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](position, positionSize));
						planes.setAttribute('uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](uv, uvSize));
						planes.setAttribute('faceIndex', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["BufferAttribute"](faceIndex, faceIndexSize));
						_lodPlanes.push(planes);

						if (lod > LOD_MIN) {

							lod--;

						}

					}

					return { _lodPlanes, _sizeLods, _sigmas };

				}

				function _createRenderTarget(params) {

					const cubeUVRenderTarget = new _renderers_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_10__["WebGLRenderTarget"](3 * SIZE_MAX, 3 * SIZE_MAX, params);
					cubeUVRenderTarget.texture.mapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVReflectionMapping"];
					cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
					cubeUVRenderTarget.scissorTest = true;
					return cubeUVRenderTarget;

				}

				function _setViewport(target, x, y, width, height) {

					target.viewport.set(x, y, width, height);
					target.scissor.set(x, y, width, height);

				}

				function _getBlurShader(maxSamples) {

					const weights = new Float32Array(maxSamples);
					const poleAxis = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_8__["Vector3"](0, 1, 0);
					const shaderMaterial = new _materials_RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_6__["RawShaderMaterial"]({

						name: 'SphericalGaussianBlur',

						defines: { 'n': maxSamples },

						uniforms: {
							'envMap': { value: null },
							'samples': { value: 1 },
							'weights': { value: weights },
							'latitudinal': { value: false },
							'dTheta': { value: 0 },
							'mipInt': { value: 0 },
							'poleAxis': { value: poleAxis },
							'inputEncoding': { value: ENCODINGS[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]] },
							'outputEncoding': { value: ENCODINGS[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]] }
						},

						vertexShader: _getCommonVertexShader(),

						fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${_getEncodings()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

						blending: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"],
						depthTest: false,
						depthWrite: false

					});

					return shaderMaterial;

				}

				function _getEquirectShader() {

					const texelSize = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_7__["Vector2"](1, 1);
					const shaderMaterial = new _materials_RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_6__["RawShaderMaterial"]({

						name: 'EquirectangularToCubeUV',

						uniforms: {
							'envMap': { value: null },
							'texelSize': { value: texelSize },
							'inputEncoding': { value: ENCODINGS[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]] },
							'outputEncoding': { value: ENCODINGS[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]] }
						},

						vertexShader: _getCommonVertexShader(),

						fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${_getEncodings()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

						blending: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"],
						depthTest: false,
						depthWrite: false

					});

					return shaderMaterial;

				}

				function _getCubemapShader() {

					const shaderMaterial = new _materials_RawShaderMaterial_js__WEBPACK_IMPORTED_MODULE_6__["RawShaderMaterial"]({

						name: 'CubemapToCubeUV',

						uniforms: {
							'envMap': { value: null },
							'inputEncoding': { value: ENCODINGS[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]] },
							'outputEncoding': { value: ENCODINGS[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]] }
						},

						vertexShader: _getCommonVertexShader(),

						fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${_getEncodings()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

						blending: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"],
						depthTest: false,
						depthWrite: false

					});

					return shaderMaterial;

				}

				function _getCommonVertexShader() {

					return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

				}

				function _getEncodings() {

					return /* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;

				}




				/***/
}),

/***/ "./libs/three/geometries/BoxGeometry.js":
/*!**********************************************!*\
  !*** ./libs/three/geometries/BoxGeometry.js ***!
  \**********************************************/
/*! exports provided: BoxGeometry, BoxBufferGeometry */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function () { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function () { return BoxGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "./libs/three/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");




				class BoxGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {
					constructor(
						width = 1,
						height = 1,
						depth = 1,
						widthSegments = 1,
						heightSegments = 1,
						depthSegments = 1
					) {
						super();

						this.type = 'BoxGeometry';

						this.parameters = {
							width: width,
							height: height,
							depth: depth,
							widthSegments: widthSegments,
							heightSegments: heightSegments,
							depthSegments: depthSegments
						};

						const scope = this;

						// segments

						widthSegments = Math.floor(widthSegments);
						heightSegments = Math.floor(heightSegments);
						depthSegments = Math.floor(depthSegments);

						// buffers

						const indices = [];
						const vertices = [];
						const normals = [];
						const uvs = [];

						// helper variables

						let numberOfVertices = 0;
						let groupStart = 0;

						// build each side of the box geometry

						buildPlane(
							'z',
							'y',
							'x',
							-1,
							-1,
							depth,
							height,
							width,
							depthSegments,
							heightSegments,
							0
						); // px
						buildPlane(
							'z',
							'y',
							'x',
							1,
							-1,
							depth,
							height,
							-width,
							depthSegments,
							heightSegments,
							1
						); // nx
						buildPlane(
							'x',
							'z',
							'y',
							1,
							1,
							width,
							depth,
							height,
							widthSegments,
							depthSegments,
							2
						); // py
						buildPlane(
							'x',
							'z',
							'y',
							1,
							-1,
							width,
							depth,
							-height,
							widthSegments,
							depthSegments,
							3
						); // ny
						buildPlane(
							'x',
							'y',
							'z',
							1,
							-1,
							width,
							height,
							depth,
							widthSegments,
							heightSegments,
							4
						); // pz
						buildPlane(
							'x',
							'y',
							'z',
							-1,
							-1,
							width,
							height,
							-depth,
							widthSegments,
							heightSegments,
							5
						); // nz

						// build geometry

						this.setIndex(indices);
						this.setAttribute('position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](vertices, 3));
						this.setAttribute('normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](normals, 3));
						this.setAttribute('uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](uvs, 2));

						function buildPlane(
							u,
							v,
							w,
							udir,
							vdir,
							width,
							height,
							depth,
							gridX,
							gridY,
							materialIndex
						) {
							const segmentWidth = width / gridX;
							const segmentHeight = height / gridY;

							const widthHalf = width / 2;
							const heightHalf = height / 2;
							const depthHalf = depth / 2;

							const gridX1 = gridX + 1;
							const gridY1 = gridY + 1;

							let vertexCounter = 0;
							let groupCount = 0;

							const vector = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

							// generate vertices, normals and uvs

							for (let iy = 0; iy < gridY1; iy++) {
								const y = iy * segmentHeight - heightHalf;

								for (let ix = 0; ix < gridX1; ix++) {
									const x = ix * segmentWidth - widthHalf;

									// set values to correct vector component

									vector[u] = x * udir;
									vector[v] = y * vdir;
									vector[w] = depthHalf;

									// now apply vector to vertex buffer

									vertices.push(vector.x, vector.y, vector.z);

									// set values to correct vector component

									vector[u] = 0;
									vector[v] = 0;
									vector[w] = depth > 0 ? 1 : -1;

									// now apply vector to normal buffer

									normals.push(vector.x, vector.y, vector.z);

									// uvs

									uvs.push(ix / gridX);
									uvs.push(1 - iy / gridY);

									// counters

									vertexCounter += 1;
								}
							}

							// indices

							// 1. you need three indices to draw a single face
							// 2. a single segment consists of two faces
							// 3. so we need to generate six (2*3) indices per segment

							for (let iy = 0; iy < gridY; iy++) {
								for (let ix = 0; ix < gridX; ix++) {
									const a = numberOfVertices + ix + gridX1 * iy;
									const b = numberOfVertices + ix + gridX1 * (iy + 1);
									const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
									const d = numberOfVertices + (ix + 1) + gridX1 * iy;

									// faces

									indices.push(a, b, d);
									indices.push(b, c, d);

									// increase counter

									groupCount += 6;
								}
							}

							// add a group to the geometry. this will ensure multi material support

							scope.addGroup(groupStart, groupCount, materialIndex);

							// calculate new start value for groups

							groupStart += groupCount;

							// update total number of vertices

							numberOfVertices += vertexCounter;
						}
					}

					static fromJSON(data) {
						return new BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);
					}
				}




				/***/
}),

/***/ "./libs/three/geometries/PlaneGeometry.js":
/*!************************************************!*\
  !*** ./libs/three/geometries/PlaneGeometry.js ***!
  \************************************************/
/*! exports provided: PlaneGeometry, PlaneBufferGeometry */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function () { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function () { return PlaneGeometry; });
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "./libs/three/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");



				class PlaneGeometry extends _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_0__["BufferGeometry"] {
					constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
						super();
						this.type = 'PlaneGeometry';

						this.parameters = {
							width: width,
							height: height,
							widthSegments: widthSegments,
							heightSegments: heightSegments
						};

						const width_half = width / 2;
						const height_half = height / 2;

						const gridX = Math.floor(widthSegments);
						const gridY = Math.floor(heightSegments);

						const gridX1 = gridX + 1;
						const gridY1 = gridY + 1;

						const segment_width = width / gridX;
						const segment_height = height / gridY;

						//

						const indices = [];
						const vertices = [];
						const normals = [];
						const uvs = [];

						for (let iy = 0; iy < gridY1; iy++) {
							const y = iy * segment_height - height_half;

							for (let ix = 0; ix < gridX1; ix++) {
								const x = ix * segment_width - width_half;

								vertices.push(x, -y, 0);

								normals.push(0, 0, 1);

								uvs.push(ix / gridX);
								uvs.push(1 - iy / gridY);
							}
						}

						for (let iy = 0; iy < gridY; iy++) {
							for (let ix = 0; ix < gridX; ix++) {
								const a = ix + gridX1 * iy;
								const b = ix + gridX1 * (iy + 1);
								const c = ix + 1 + gridX1 * (iy + 1);
								const d = ix + 1 + gridX1 * iy;

								indices.push(a, b, d);
								indices.push(b, c, d);
							}
						}

						this.setIndex(indices);
						this.setAttribute('position', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](vertices, 3));
						this.setAttribute('normal', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](normals, 3));
						this.setAttribute('uv', new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"](uvs, 2));
					}

					static fromJSON(data) {
						return new PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);
					}
				}




				/***/
}),

/***/ "./libs/three/lights/AmbientLight.js":
/*!*******************************************!*\
  !*** ./libs/three/lights/AmbientLight.js ***!
  \*******************************************/
/*! exports provided: AmbientLight */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function () { return AmbientLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "./libs/three/lights/Light.js");


				class AmbientLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {
					constructor(color, intensity) {
						super(color, intensity);

						this.type = 'AmbientLight';
					}
				}

				AmbientLight.prototype.isAmbientLight = true;




				/***/
}),

/***/ "./libs/three/lights/DirectionalLight.js":
/*!***********************************************!*\
  !*** ./libs/three/lights/DirectionalLight.js ***!
  \***********************************************/
/*! exports provided: DirectionalLight */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function () { return DirectionalLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "./libs/three/lights/Light.js");
/* harmony import */ var _DirectionalLightShadow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DirectionalLightShadow.js */ "./libs/three/lights/DirectionalLightShadow.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");




				class DirectionalLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {
					constructor(color, intensity) {
						super(color, intensity);

						this.type = 'DirectionalLight';

						this.position.copy(_core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"].DefaultUp);
						this.updateMatrix();

						this.target = new _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"]();

						this.shadow = new _DirectionalLightShadow_js__WEBPACK_IMPORTED_MODULE_1__["DirectionalLightShadow"]();
					}

					dispose() {
						this.shadow.dispose();
					}

					copy(source) {
						super.copy(source);

						this.target = source.target.clone();
						this.shadow = source.shadow.clone();

						return this;
					}
				}

				DirectionalLight.prototype.isDirectionalLight = true;




				/***/
}),

/***/ "./libs/three/lights/DirectionalLightShadow.js":
/*!*****************************************************!*\
  !*** ./libs/three/lights/DirectionalLightShadow.js ***!
  \*****************************************************/
/*! exports provided: DirectionalLightShadow */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function () { return DirectionalLightShadow; });
/* harmony import */ var _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LightShadow.js */ "./libs/three/lights/LightShadow.js");
/* harmony import */ var _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cameras/OrthographicCamera.js */ "./libs/three/cameras/OrthographicCamera.js");



				class DirectionalLightShadow extends _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__["LightShadow"] {
					constructor() {
						super(new _cameras_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_1__["OrthographicCamera"](-5, 5, 5, -5, 0.5, 500));
					}
				}

				DirectionalLightShadow.prototype.isDirectionalLightShadow = true;




				/***/
}),

/***/ "./libs/three/lights/Light.js":
/*!************************************!*\
  !*** ./libs/three/lights/Light.js ***!
  \************************************/
/*! exports provided: Light */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function () { return Light; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "./libs/three/math/Color.js");



				class Light extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {
					constructor(color, intensity = 1) {
						super();

						this.type = 'Light';

						this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"](color);
						this.intensity = intensity;
					}

					dispose() {
						// Empty here in base class; some subclasses override.
					}

					copy(source) {
						super.copy(source);

						this.color.copy(source.color);
						this.intensity = source.intensity;

						return this;
					}

					toJSON(meta) {
						const data = super.toJSON(meta);

						data.object.color = this.color.getHex();
						data.object.intensity = this.intensity;

						if (this.groundColor !== undefined)
							data.object.groundColor = this.groundColor.getHex();

						if (this.distance !== undefined) data.object.distance = this.distance;
						if (this.angle !== undefined) data.object.angle = this.angle;
						if (this.decay !== undefined) data.object.decay = this.decay;
						if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;

						if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();

						return data;
					}
				}

				Light.prototype.isLight = true;




				/***/
}),

/***/ "./libs/three/lights/LightShadow.js":
/*!******************************************!*\
  !*** ./libs/three/lights/LightShadow.js ***!
  \******************************************/
/*! exports provided: LightShadow */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightShadow", function () { return LightShadow; });
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector4.js */ "./libs/three/math/Vector4.js");
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Frustum.js */ "./libs/three/math/Frustum.js");






				const _projScreenMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
				const _lightPositionWorld = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
				const _lookTarget = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

				class LightShadow {
					constructor(camera) {
						this.camera = camera;

						this.bias = 0;
						this.normalBias = 0;
						this.radius = 1;
						this.blurSamples = 8;

						this.mapSize = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](512, 512);

						this.map = null;
						this.mapPass = null;
						this.matrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();

						this.autoUpdate = true;
						this.needsUpdate = false;

						this._frustum = new _math_Frustum_js__WEBPACK_IMPORTED_MODULE_4__["Frustum"]();
						this._frameExtents = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](1, 1);

						this._viewportCount = 1;

						this._viewports = [new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"](0, 0, 1, 1)];
					}

					getViewportCount() {
						return this._viewportCount;
					}

					getFrustum() {
						return this._frustum;
					}

					updateMatrices(light) {
						const shadowCamera = this.camera;
						const shadowMatrix = this.matrix;

						_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
						shadowCamera.position.copy(_lightPositionWorld);

						_lookTarget.setFromMatrixPosition(light.target.matrixWorld);
						shadowCamera.lookAt(_lookTarget);
						shadowCamera.updateMatrixWorld();

						_projScreenMatrix.multiplyMatrices(
							shadowCamera.projectionMatrix,
							shadowCamera.matrixWorldInverse
						);
						this._frustum.setFromProjectionMatrix(_projScreenMatrix);

						shadowMatrix.set(
							0.5,
							0.0,
							0.0,
							0.5,
							0.0,
							0.5,
							0.0,
							0.5,
							0.0,
							0.0,
							0.5,
							0.5,
							0.0,
							0.0,
							0.0,
							1.0
						);

						shadowMatrix.multiply(shadowCamera.projectionMatrix);
						shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
					}

					getViewport(viewportIndex) {
						return this._viewports[viewportIndex];
					}

					getFrameExtents() {
						return this._frameExtents;
					}

					dispose() {
						if (this.map) {
							this.map.dispose();
						}

						if (this.mapPass) {
							this.mapPass.dispose();
						}
					}

					copy(source) {
						this.camera = source.camera.clone();

						this.bias = source.bias;
						this.radius = source.radius;

						this.mapSize.copy(source.mapSize);

						return this;
					}

					clone() {
						return new this.constructor().copy(this);
					}

					toJSON() {
						const object = {};

						if (this.bias !== 0) object.bias = this.bias;
						if (this.normalBias !== 0) object.normalBias = this.normalBias;
						if (this.radius !== 1) object.radius = this.radius;
						if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
							object.mapSize = this.mapSize.toArray();

						object.camera = this.camera.toJSON(false).object;
						delete object.camera.matrix;

						return object;
					}
				}




				/***/
}),

/***/ "./libs/three/lights/PointLight.js":
/*!*****************************************!*\
  !*** ./libs/three/lights/PointLight.js ***!
  \*****************************************/
/*! exports provided: PointLight */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function () { return PointLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "./libs/three/lights/Light.js");
/* harmony import */ var _PointLightShadow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PointLightShadow.js */ "./libs/three/lights/PointLightShadow.js");



				class PointLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {
					constructor(color, intensity, distance = 0, decay = 1) {
						super(color, intensity);

						this.type = 'PointLight';

						this.distance = distance;
						this.decay = decay; // for physically correct lights, should be 2.

						this.shadow = new _PointLightShadow_js__WEBPACK_IMPORTED_MODULE_1__["PointLightShadow"]();
					}

					get power() {
						// compute the light's luminous power (in lumens) from its intensity (in candela)
						// for an isotropic light source, luminous power (lm) = 4 π luminous intensity (cd)
						return this.intensity * 4 * Math.PI;
					}

					set power(power) {
						// set the light's intensity (in candela) from the desired luminous power (in lumens)
						this.intensity = power / (4 * Math.PI);
					}

					dispose() {
						this.shadow.dispose();
					}

					copy(source) {
						super.copy(source);

						this.distance = source.distance;
						this.decay = source.decay;

						this.shadow = source.shadow.clone();

						return this;
					}
				}

				PointLight.prototype.isPointLight = true;




				/***/
}),

/***/ "./libs/three/lights/PointLightShadow.js":
/*!***********************************************!*\
  !*** ./libs/three/lights/PointLightShadow.js ***!
  \***********************************************/
/*! exports provided: PointLightShadow */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightShadow", function () { return PointLightShadow; });
/* harmony import */ var _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LightShadow.js */ "./libs/three/lights/LightShadow.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cameras/PerspectiveCamera.js */ "./libs/three/cameras/PerspectiveCamera.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../math/Vector4.js */ "./libs/three/math/Vector4.js");







				const _projScreenMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
				const _lightPositionWorld = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
				const _lookTarget = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();

				class PointLightShadow extends _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__["LightShadow"] {
					constructor() {
						super(new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_1__["PerspectiveCamera"](90, 1, 0.5, 500));

						this._frameExtents = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"](4, 2);

						this._viewportCount = 6;

						this._viewports = [
							// These viewports map a cube-map onto a 2D texture with the
							// following orientation:
							//
							//  xzXZ
							//   y Y
							//
							// X - Positive x direction
							// x - Negative x direction
							// Y - Positive y direction
							// y - Negative y direction
							// Z - Positive z direction
							// z - Negative z direction

							// positive X
							new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"](2, 1, 1, 1),
							// negative X
							new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"](0, 1, 1, 1),
							// positive Z
							new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"](3, 1, 1, 1),
							// negative Z
							new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"](1, 1, 1, 1),
							// positive Y
							new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"](3, 0, 1, 1),
							// negative Y
							new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_5__["Vector4"](1, 0, 1, 1)
						];

						this._cubeDirections = [
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](1, 0, 0),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](-1, 0, 0),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 0, 1),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 0, -1),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 1, 0),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, -1, 0)
						];

						this._cubeUps = [
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 1, 0),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 1, 0),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 1, 0),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 1, 0),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 0, 1),
							new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"](0, 0, -1)
						];
					}

					updateMatrices(light, viewportIndex = 0) {
						const camera = this.camera;
						const shadowMatrix = this.matrix;

						const far = light.distance || camera.far;

						if (far !== camera.far) {
							camera.far = far;
							camera.updateProjectionMatrix();
						}

						_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
						camera.position.copy(_lightPositionWorld);

						_lookTarget.copy(camera.position);
						_lookTarget.add(this._cubeDirections[viewportIndex]);
						camera.up.copy(this._cubeUps[viewportIndex]);
						camera.lookAt(_lookTarget);
						camera.updateMatrixWorld();

						shadowMatrix.makeTranslation(
							-_lightPositionWorld.x,
							-_lightPositionWorld.y,
							-_lightPositionWorld.z
						);

						_projScreenMatrix.multiplyMatrices(
							camera.projectionMatrix,
							camera.matrixWorldInverse
						);
						this._frustum.setFromProjectionMatrix(_projScreenMatrix);
					}
				}

				PointLightShadow.prototype.isPointLightShadow = true;




				/***/
}),

/***/ "./libs/three/lights/SpotLight.js":
/*!****************************************!*\
  !*** ./libs/three/lights/SpotLight.js ***!
  \****************************************/
/*! exports provided: SpotLight */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function () { return SpotLight; });
/* harmony import */ var _Light_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Light.js */ "./libs/three/lights/Light.js");
/* harmony import */ var _SpotLightShadow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SpotLightShadow.js */ "./libs/three/lights/SpotLightShadow.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");




				class SpotLight extends _Light_js__WEBPACK_IMPORTED_MODULE_0__["Light"] {
					constructor(
						color,
						intensity,
						distance = 0,
						angle = Math.PI / 3,
						penumbra = 0,
						decay = 1
					) {
						super(color, intensity);

						this.type = 'SpotLight';

						this.position.copy(_core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"].DefaultUp);
						this.updateMatrix();

						this.target = new _core_Object3D_js__WEBPACK_IMPORTED_MODULE_2__["Object3D"]();

						this.distance = distance;
						this.angle = angle;
						this.penumbra = penumbra;
						this.decay = decay; // for physically correct lights, should be 2.

						this.shadow = new _SpotLightShadow_js__WEBPACK_IMPORTED_MODULE_1__["SpotLightShadow"]();
					}

					get power() {
						// compute the light's luminous power (in lumens) from its intensity (in candela)
						// by convention for a spotlight, luminous power (lm) = π * luminous intensity (cd)
						return this.intensity * Math.PI;
					}

					set power(power) {
						// set the light's intensity (in candela) from the desired luminous power (in lumens)
						this.intensity = power / Math.PI;
					}

					dispose() {
						this.shadow.dispose();
					}

					copy(source) {
						super.copy(source);

						this.distance = source.distance;
						this.angle = source.angle;
						this.penumbra = source.penumbra;
						this.decay = source.decay;

						this.target = source.target.clone();

						this.shadow = source.shadow.clone();

						return this;
					}
				}

				SpotLight.prototype.isSpotLight = true;




				/***/
}),

/***/ "./libs/three/lights/SpotLightShadow.js":
/*!**********************************************!*\
  !*** ./libs/three/lights/SpotLightShadow.js ***!
  \**********************************************/
/*! exports provided: SpotLightShadow */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function () { return SpotLightShadow; });
/* harmony import */ var _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LightShadow.js */ "./libs/three/lights/LightShadow.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");
/* harmony import */ var _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cameras/PerspectiveCamera.js */ "./libs/three/cameras/PerspectiveCamera.js");




				class SpotLightShadow extends _LightShadow_js__WEBPACK_IMPORTED_MODULE_0__["LightShadow"] {
					constructor() {
						super(new _cameras_PerspectiveCamera_js__WEBPACK_IMPORTED_MODULE_2__["PerspectiveCamera"](50, 1, 0.5, 500));

						this.focus = 1;
					}

					updateMatrices(light) {
						const camera = this.camera;

						const fov = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["RAD2DEG"] * 2 * light.angle * this.focus;
						const aspect = this.mapSize.width / this.mapSize.height;
						const far = light.distance || camera.far;

						if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
							camera.fov = fov;
							camera.aspect = aspect;
							camera.far = far;
							camera.updateProjectionMatrix();
						}

						super.updateMatrices(light);
					}

					copy(source) {
						super.copy(source);

						this.focus = source.focus;

						return this;
					}
				}

				SpotLightShadow.prototype.isSpotLightShadow = true;




				/***/
}),

/***/ "./libs/three/loaders/Cache.js":
/*!*************************************!*\
  !*** ./libs/three/loaders/Cache.js ***!
  \*************************************/
/*! exports provided: Cache */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function () { return Cache; });
				const Cache = {

					enabled: false,

					files: {},

					add: function (key, file) {

						if (this.enabled === false) return;

						// console.log( 'THREE.Cache', 'Adding key:', key );

						this.files[key] = file;

					},

					get: function (key) {

						if (this.enabled === false) return;

						// console.log( 'THREE.Cache', 'Checking key:', key );

						return this.files[key];

					},

					remove: function (key) {

						delete this.files[key];

					},

					clear: function () {

						this.files = {};

					}

				};





				/***/
}),

/***/ "./libs/three/loaders/FileLoader.js":
/*!******************************************!*\
  !*** ./libs/three/loaders/FileLoader.js ***!
  \******************************************/
/*! exports provided: FileLoader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function () { return FileLoader; });
/* harmony import */ var _Cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache.js */ "./libs/three/loaders/Cache.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loader.js */ "./libs/three/loaders/Loader.js");



				const loading = {};

				class FileLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_1__["Loader"] {

					constructor(manager) {

						super(manager);

					}

					load(url, onLoad, onProgress, onError) {

						if (url === undefined) url = '';

						if (this.path !== undefined) url = this.path + url;

						url = this.manager.resolveURL(url);

						const scope = this;

						const cached = _Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].get(url);

						if (cached !== undefined) {

							scope.manager.itemStart(url);

							setTimeout(function () {
								if (onLoad) onLoad(cached);

								scope.manager.itemEnd(url);

							}, 0);

							return cached;

						}

						// Check if request is duplicate

						if (loading[url] !== undefined) {

							loading[url].push({

								onLoad: onLoad,
								onProgress: onProgress,
								onError: onError

							});

							return;

						}

						// Check for data: URI
						const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
						const dataUriRegexResult = url.match(dataUriRegex);
						let request;

						// Safari can not handle Data URIs through XMLHttpRequest so process manually
						if (dataUriRegexResult) {

							const mimeType = dataUriRegexResult[1];
							const isBase64 = !!dataUriRegexResult[2];

							let data = dataUriRegexResult[3];
							data = decodeURIComponent(data);

							if (isBase64) data = window ? window.atob(data) : my.global.atob(data);

							try {

								let response;
								const responseType = (this.responseType || '').toLowerCase();
								switch (responseType) {

									case 'arraybuffer':
									case 'blob':

										const view = new Uint8Array(data.length);

										for (let i = 0; i < data.length; i++) {

											view[i] = data.charCodeAt(i);

										}

										if (responseType === 'blob') {

											response = new Blob([view.buffer], { type: mimeType });

										} else {

											response = view.buffer;

										}

										break;

									case 'document':

										const parser = new DOMParser();
										response = parser.parseFromString(data, mimeType);

										break;

									case 'json':

										response = JSON.parse(data);

										break;

									default: // 'text' or other

										response = data;

										break;

								}

								// Wait for next browser tick like standard XMLHttpRequest event dispatching does
								setTimeout(function () {

									if (onLoad) onLoad(response);

									scope.manager.itemEnd(url);

								}, 0);

							} catch (error) {

								// Wait for next browser tick like standard XMLHttpRequest event dispatching does
								setTimeout(function () {

									if (onError) onError(error);

									scope.manager.itemError(url);
									scope.manager.itemEnd(url);

								}, 0);

							}

						} else {

							// Initialise array for duplicate requests

							loading[url] = [];

							loading[url].push({

								onLoad: onLoad,
								onProgress: onProgress,
								onError: onError

							});

							request = window ? new window.XMLHttpRequest() : new my.global.XMLHttpRequest();

							request.open('GET', url, true);

							request.addEventListener('load', function (event) {

								const response = this.response;

								// 里面是onLoad，onProgress，onError
								const callbacks = loading[url];

								delete loading[url];

								if (this.status === 200 || this.status === 0) {

									// Some browsers return HTTP Status 0 when using non-http protocol
									// e.g. 'file://' or 'data://'. Handle as success.

									if (this.status === 0) console.warn('THREE.FileLoader: HTTP Status 0 received.');

									// Add to cache only on HTTP success, so that we do not cache
									// error response bodies as proper responses to requests.
									_Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].add(url, response);

									for (let i = 0, il = callbacks.length; i < il; i++) {

										const callback = callbacks[i];
										if (callback.onLoad) {
											callback.onLoad(response)
										};

									}

									scope.manager.itemEnd(url);

								} else {

									for (let i = 0, il = callbacks.length; i < il; i++) {

										const callback = callbacks[i];
										if (callback.onError) callback.onError(event);

									}

									scope.manager.itemError(url);
									scope.manager.itemEnd(url);

								}

							}, false);

							request.addEventListener('progress', function (event) {

								const callbacks = loading[url];

								for (let i = 0, il = callbacks.length; i < il; i++) {

									const callback = callbacks[i];
									if (callback.onProgress) callback.onProgress(event);

								}

							}, false);

							request.addEventListener('error', function (event) {

								// my.alert({content:"err:"+JSON.stringify(event)})
								const callbacks = loading[url];

								delete loading[url];

								for (let i = 0, il = callbacks.length; i < il; i++) {

									const callback = callbacks[i];
									if (callback.onError) callback.onError(event);

								}

								scope.manager.itemError(url);
								scope.manager.itemEnd(url);

							}, false);

							request.addEventListener('abort', function (event) {

								// my.alert({content:"abort:"+JSON.stringify(event)})
								const callbacks = loading[url];

								delete loading[url];

								for (let i = 0, il = callbacks.length; i < il; i++) {

									const callback = callbacks[i];
									if (callback.onError) callback.onError(event);

								}

								scope.manager.itemError(url);
								scope.manager.itemEnd(url);

							}, false);

							if (this.responseType !== undefined) request.responseType = this.responseType;
							if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;

							if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : 'text/plain');

							for (const header in this.requestHeader) {

								request.setRequestHeader(header, this.requestHeader[header]);

							}

							request.send(null);

						}

						scope.manager.itemStart(url);

						return request;

					}

					setResponseType(value) {

						this.responseType = value;
						return this;

					}

					setMimeType(value) {

						this.mimeType = value;
						return this;

					}

				}




				/***/
}),

/***/ "./libs/three/loaders/GLTFLoader.js":
/*!******************************************!*\
  !*** ./libs/three/loaders/GLTFLoader.js ***!
  \******************************************/
/*! exports provided: GLTFLoader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFLoader", function () { return GLTFLoader; });
/* harmony import */ var _FileLoader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FileLoader */ "./libs/three/loaders/FileLoader.js");
/* harmony import */ var _Loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loader */ "./libs/three/loaders/Loader.js");
/* harmony import */ var _LoaderUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LoaderUtils */ "./libs/three/loaders/LoaderUtils.js");
/* harmony import */ var _gltf_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gltf/utils */ "./libs/three/loaders/gltf/utils.js");
/* harmony import */ var _gltf_GLTFMaterialsClearcoatExtension__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gltf/GLTFMaterialsClearcoatExtension */ "./libs/three/loaders/gltf/GLTFMaterialsClearcoatExtension.js");
/* harmony import */ var _gltf_GLTFTextureBasisUExtension__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gltf/GLTFTextureBasisUExtension */ "./libs/three/loaders/gltf/GLTFTextureBasisUExtension.js");
/* harmony import */ var _gltf_GLTFTextureWebPExtension__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gltf/GLTFTextureWebPExtension */ "./libs/three/loaders/gltf/GLTFTextureWebPExtension.js");
/* harmony import */ var _gltf_GLTFMaterialsSheenExtension__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gltf/GLTFMaterialsSheenExtension */ "./libs/three/loaders/gltf/GLTFMaterialsSheenExtension.js");
/* harmony import */ var _gltf_GLTFMaterialsTransmissionExtension__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gltf/GLTFMaterialsTransmissionExtension */ "./libs/three/loaders/gltf/GLTFMaterialsTransmissionExtension.js");
/* harmony import */ var _gltf_GLTFMaterialsVolumeExtension__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./gltf/GLTFMaterialsVolumeExtension */ "./libs/three/loaders/gltf/GLTFMaterialsVolumeExtension.js");
/* harmony import */ var _gltf_GLTFMaterialsIorExtension__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./gltf/GLTFMaterialsIorExtension */ "./libs/three/loaders/gltf/GLTFMaterialsIorExtension.js");
/* harmony import */ var _gltf_GLTFMaterialsSpecularExtension__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./gltf/GLTFMaterialsSpecularExtension */ "./libs/three/loaders/gltf/GLTFMaterialsSpecularExtension.js");
/* harmony import */ var _gltf_GLTFLightsExtension__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./gltf/GLTFLightsExtension */ "./libs/three/loaders/gltf/GLTFLightsExtension.js");
/* harmony import */ var _gltf_GLTFMeshoptCompression__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gltf/GLTFMeshoptCompression */ "./libs/three/loaders/gltf/GLTFMeshoptCompression.js");
/* harmony import */ var _gltf_GLTFBinaryExtension__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./gltf/GLTFBinaryExtension */ "./libs/three/loaders/gltf/GLTFBinaryExtension.js");
/* harmony import */ var _gltf_GLTFParser__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./gltf/GLTFParser */ "./libs/three/loaders/gltf/GLTFParser.js");
/* harmony import */ var _gltf_GLTFMaterialsPbrSpecularGlossinessExtension__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./gltf/GLTFMaterialsPbrSpecularGlossinessExtension */ "./libs/three/loaders/gltf/GLTFMaterialsPbrSpecularGlossinessExtension.js");
/* harmony import */ var _gltf_GLTFMaterialsUnlitExtension__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./gltf/GLTFMaterialsUnlitExtension */ "./libs/three/loaders/gltf/GLTFMaterialsUnlitExtension.js");
/* harmony import */ var _gltf_GLTFDracoMeshCompressionExtension__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./gltf/GLTFDracoMeshCompressionExtension */ "./libs/three/loaders/gltf/GLTFDracoMeshCompressionExtension.js");
/* harmony import */ var _gltf_GLTFTextureTransformExtension__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./gltf/GLTFTextureTransformExtension */ "./libs/three/loaders/gltf/GLTFTextureTransformExtension.js");
/* harmony import */ var _gltf_GLTFMeshQuantizationExtension__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./gltf/GLTFMeshQuantizationExtension */ "./libs/three/loaders/gltf/GLTFMeshQuantizationExtension.js");


























				class GLTFLoader extends _Loader__WEBPACK_IMPORTED_MODULE_1__["Loader"] {
					constructor(manager) {
						super(manager);

						this.dracoLoader = null;
						this.ktx2Loader = null;
						this.meshoptDecoder = null;
						this.complieEnv = null;

						this.pluginCallbacks = [];

						this.register(parser => new _gltf_GLTFMaterialsClearcoatExtension__WEBPACK_IMPORTED_MODULE_4__["GLTFMaterialsClearcoatExtension"](parser));

						this.register(parser => new _gltf_GLTFTextureBasisUExtension__WEBPACK_IMPORTED_MODULE_5__["GLTFTextureBasisUExtension"](parser));

						this.register(parser => new _gltf_GLTFTextureWebPExtension__WEBPACK_IMPORTED_MODULE_6__["GLTFTextureWebPExtension"](parser));

						this.register(parser => new _gltf_GLTFMaterialsSheenExtension__WEBPACK_IMPORTED_MODULE_7__["GLTFMaterialsSheenExtension"](parser));

						this.register(parser => new _gltf_GLTFMaterialsTransmissionExtension__WEBPACK_IMPORTED_MODULE_8__["GLTFMaterialsTransmissionExtension"](parser));

						this.register(parser => new _gltf_GLTFMaterialsVolumeExtension__WEBPACK_IMPORTED_MODULE_9__["GLTFMaterialsVolumeExtension"](parser));

						this.register(parser => new _gltf_GLTFMaterialsIorExtension__WEBPACK_IMPORTED_MODULE_10__["GLTFMaterialsIorExtension"](parser));

						this.register(parser => new _gltf_GLTFMaterialsSpecularExtension__WEBPACK_IMPORTED_MODULE_11__["GLTFMaterialsSpecularExtension"](parser));

						this.register(parser => new _gltf_GLTFLightsExtension__WEBPACK_IMPORTED_MODULE_12__["GLTFLightsExtension"](parser));

						this.register(parser => new _gltf_GLTFMeshoptCompression__WEBPACK_IMPORTED_MODULE_13__["GLTFMeshoptCompression"](parser));
					}

					load(url, onLoad, onProgress, onError) {
						const scope = this;

						let resourcePath;

						if (this.resourcePath !== '') {
							({ resourcePath } = this.resourcePath);
						} else if (this.path !== '') {
							resourcePath = this.path;
						} else {
							resourcePath = _LoaderUtils__WEBPACK_IMPORTED_MODULE_2__["LoaderUtils"].extractUrlBase(url);
						}

						// Tells the LoadingManager to track an extra item, which resolves after
						// the model is fully loaded. This means the count of items loaded will
						// be incorrect, but ensures manager.onLoad() does not fire early.
						this.manager.itemStart(url);

						const _onError = e => {
							// my.alert({content:JSON.stringify(e)})
							if (onError) {
								onError(e);
							} else {
								console.error(e);
							}
							scope.manager.itemError(url);
							scope.manager.itemEnd(url);
						};

						const loader = new _FileLoader__WEBPACK_IMPORTED_MODULE_0__["FileLoader"](this.manager);

						loader.setPath(this.path);

						loader.load(
							url,
							data => {
								console.log("走到下载文件", url)
								try {
									this.parse(
										data,
										resourcePath,
										gltf => {
											console.log("走到解析文件", url)
											onLoad(gltf);
											this.manager.itemEnd(url);
										},
										_onError
									);
								} catch (e) {
									console.error(e);
									_onError(e);
								}
							},
							onProgress,
							_onError
						);
					}

					setDRACOLoader(dracoLoader) {
						this.dracoLoader = dracoLoader;
						return this;
					}

					setDDSLoader() {
						throw new Error(
							'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
						);
					}

					setKTX2Loader(ktx2Loader) {
						this.ktx2Loader = ktx2Loader;
						return this;
					}

					setMeshoptDecoder(meshoptDecoder) {
						this.meshoptDecoder = meshoptDecoder;
						return this;
					}

					/**
					 * 设置编译环境 大部件需要在解析的时候串行解析
					 * @param {*} complieEnv 
					 * @returns 
					 */
					setComplieEnv(complieEnv) {
						this.complieEnv = complieEnv;
						return this
					}

					register(callback) {
						if (this.pluginCallbacks.indexOf(callback) === -1) {
							this.pluginCallbacks.push(callback);
						}
						return this;
					}

					unregister(callback) {
						if (this.pluginCallbacks.indexOf(callback) !== -1) {
							this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
						}
						return this;
					}

					parse(data, path, onLoad, onError) {
						let content;
						const extensions = {};
						const plugins = {};
						if (typeof data === 'string') {
							content = data;
						} else {
							const magic = _LoaderUtils__WEBPACK_IMPORTED_MODULE_2__["LoaderUtils"].decodeText(new Uint8Array(data, 0, 4));

							// console.log("magic",magic);
							if (magic === _gltf_utils__WEBPACK_IMPORTED_MODULE_3__["BINARY_EXTENSION_HEADER_MAGIC"]) {
								try {
									extensions[_gltf_utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_BINARY_GLTF] = new _gltf_GLTFBinaryExtension__WEBPACK_IMPORTED_MODULE_14__["GLTFBinaryExtension"](
										data
									);
								} catch (error) {
									if (onError) onError(error);
									return;
								}

								({ content } = extensions[_gltf_utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_BINARY_GLTF]);
							} else {
								content = _LoaderUtils__WEBPACK_IMPORTED_MODULE_2__["LoaderUtils"].decodeText(new Uint8Array(data));
							}
						}
						const json = JSON.parse(content);

						if (json.asset === undefined || json.asset.version[0] < 2) {
							if (onError)
								onError(
									new Error(
										'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'
									)
								);
							return;
						}


						// console.log("走到解析json");
						const parser = new _gltf_GLTFParser__WEBPACK_IMPORTED_MODULE_15__["GLTFParser"](json, {
							path: path || this.resourcePath || '',
							requestHeader: this.requestHeader,
							manager: this.manager,
							ktx2Loader: this.ktx2Loader,
							meshoptDecoder: this.meshoptDecoder,
							complieEnv: this.complieEnv
						});
						// console.log("parser",parser);
						parser.fileLoader.setRequestHeader(this.requestHeader);

						for (let i = 0; i < this.pluginCallbacks.length; i++) {
							const plugin = this.pluginCallbacks[i](parser);
							plugins[plugin.name] = plugin;
							// Workaround to avoid determining as unknown extension
							// in addUnknownExtensionsToUserData().
							// Remove this workaround if we move all the existing
							// extension handlers to plugin system
							extensions[plugin.name] = true;
						}
						if (json.extensionsUsed) {
							for (let i = 0; i < json.extensionsUsed.length; ++i) {
								const extensionName = json.extensionsUsed[i];
								const extensionsRequired = json.extensionsRequired || [];

								switch (extensionName) {
									case _gltf_utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_MATERIALS_UNLIT:
										extensions[extensionName] = new _gltf_GLTFMaterialsUnlitExtension__WEBPACK_IMPORTED_MODULE_17__["GLTFMaterialsUnlitExtension"]();
										break;

									case _gltf_utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
										extensions[
											extensionName
										] = new _gltf_GLTFMaterialsPbrSpecularGlossinessExtension__WEBPACK_IMPORTED_MODULE_16__["GLTFMaterialsPbrSpecularGlossinessExtension"]();
										break;

									case _gltf_utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_DRACO_MESH_COMPRESSION:
										extensions[extensionName] = new _gltf_GLTFDracoMeshCompressionExtension__WEBPACK_IMPORTED_MODULE_18__["GLTFDracoMeshCompressionExtension"](
											json,
											this.dracoLoader
										);
										break;

									case _gltf_utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_TEXTURE_TRANSFORM:
										extensions[extensionName] = new _gltf_GLTFTextureTransformExtension__WEBPACK_IMPORTED_MODULE_19__["GLTFTextureTransformExtension"]();
										break;

									case _gltf_utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_MESH_QUANTIZATION:
										extensions[extensionName] = new _gltf_GLTFMeshQuantizationExtension__WEBPACK_IMPORTED_MODULE_20__["GLTFMeshQuantizationExtension"]();
										break;

									default:
										if (
											extensionsRequired.indexOf(extensionName) >= 0 &&
											plugins[extensionName] === undefined
										) {
											console.warn(
												`THREE.GLTFLoader: Unknown extension ${extensionName}.`
											);
										}
								}
							}
						}
						parser.setExtensions(extensions);
						parser.setPlugins(plugins);
						parser.parse(onLoad, onError);
					}
				}




				/***/
}),

/***/ "./libs/three/loaders/ImageBitmapLoader.js":
/*!*************************************************!*\
  !*** ./libs/three/loaders/ImageBitmapLoader.js ***!
  \*************************************************/
/*! exports provided: ImageBitmapLoader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function () { return ImageBitmapLoader; });
/* harmony import */ var _Cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache.js */ "./libs/three/loaders/Cache.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loader.js */ "./libs/three/loaders/Loader.js");



				class ImageBitmapLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_1__["Loader"] {

					constructor(manager) {

						super(manager);

						if (typeof createImageBitmap === 'undefined') {

							console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');

						}

						if (typeof fetch === 'undefined') {

							console.warn('THREE.ImageBitmapLoader: fetch() not supported.');

						}

						this.options = { premultiplyAlpha: 'none' };

					}

					setOptions(options) {

						this.options = options;

						return this;

					}

					load(url, onLoad, onProgress, onError) {

						if (url === undefined) url = '';

						if (this.path !== undefined) url = this.path + url;

						url = this.manager.resolveURL(url);

						const scope = this;

						const cached = _Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].get(url);

						if (cached !== undefined) {

							scope.manager.itemStart(url);

							setTimeout(function () {

								if (onLoad) onLoad(cached);

								scope.manager.itemEnd(url);

							}, 0);

							return cached;

						}

						const fetchOptions = {};
						fetchOptions.credentials = (this.crossOrigin === 'anonymous') ? 'same-origin' : 'include';
						fetchOptions.headers = this.requestHeader;

						fetch(url, fetchOptions).then(function (res) {

							return res.blob();

						}).then(function (blob) {

							return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: 'none' }));

						}).then(function (imageBitmap) {

							_Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].add(url, imageBitmap);

							if (onLoad) onLoad(imageBitmap);

							scope.manager.itemEnd(url);

						}).catch(function (e) {

							if (onError) onError(e);

							scope.manager.itemError(url);
							scope.manager.itemEnd(url);

						});

						scope.manager.itemStart(url);

					}

				}

				ImageBitmapLoader.prototype.isImageBitmapLoader = true;




				/***/
}),

/***/ "./libs/three/loaders/ImageLoader.js":
/*!*******************************************!*\
  !*** ./libs/three/loaders/ImageLoader.js ***!
  \*******************************************/
/*! exports provided: ImageLoader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function () { return ImageLoader; });
/* harmony import */ var _Cache_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache.js */ "./libs/three/loaders/Cache.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Loader.js */ "./libs/three/loaders/Loader.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./libs/three/utils.js");




				class ImageLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_1__["Loader"] {

					constructor(manager) {

						super(manager);

					}

					load(url, onLoad, onProgress, onError) {

						if (this.path !== undefined) url = this.path + url;

						url = this.manager.resolveURL(url);

						const scope = this;

						const cached = _Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].get(url);

						if (cached !== undefined) {

							scope.manager.itemStart(url);

							setTimeout(function () {

								if (onLoad) onLoad(cached);

								scope.manager.itemEnd(url);

							}, 0);

							return cached;

						}

						const image = window ? document.createElement("img") : my.global.canvas.createImage();
						if (window) {
							image.setAttribute('crossOrigin', '*')
						}
						image.onload = () => {
							image.onload = () => { };
							image.onerror = () => { };
							_Cache_js__WEBPACK_IMPORTED_MODULE_0__["Cache"].add(url, image);
							if (onLoad) onLoad(image);
							this.manager.itemEnd(url);
						};

						image.onerror = event => {
							image.onload = () => { };
							image.onerror = () => { };
							if (onError) onError(event);
							this.manager.itemEnd(url);
							this.manager.itemError(url);
						};

						this.manager.itemStart(url);

						image.src = url;
						return image;

					}

				}





				/***/
}),

/***/ "./libs/three/loaders/Loader.js":
/*!**************************************!*\
  !*** ./libs/three/loaders/Loader.js ***!
  \**************************************/
/*! exports provided: Loader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function () { return Loader; });
/* harmony import */ var _LoadingManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LoadingManager.js */ "./libs/three/loaders/LoadingManager.js");


				class Loader {

					constructor(manager) {

						this.manager = (manager !== undefined) ? manager : _LoadingManager_js__WEBPACK_IMPORTED_MODULE_0__["DefaultLoadingManager"];

						this.crossOrigin = 'anonymous';
						this.withCredentials = false;
						this.path = '';
						this.resourcePath = '';
						this.requestHeader = {};

					}

					load( /* url, onLoad, onProgress, onError */) { }

					loadAsync(url, onProgress) {

						const scope = this;

						return new Promise(function (resolve, reject) {

							scope.load(url, resolve, onProgress, reject);

						});

					}

					parse( /* data */) { }

					setCrossOrigin(crossOrigin) {

						this.crossOrigin = crossOrigin;
						return this;

					}

					setWithCredentials(value) {

						this.withCredentials = value;
						return this;

					}

					setPath(path) {

						this.path = path;
						return this;

					}

					setResourcePath(resourcePath) {

						this.resourcePath = resourcePath;
						return this;

					}

					setRequestHeader(requestHeader) {

						this.requestHeader = requestHeader;
						return this;

					}

				}




				/***/
}),

/***/ "./libs/three/loaders/LoaderUtils.js":
/*!*******************************************!*\
  !*** ./libs/three/loaders/LoaderUtils.js ***!
  \*******************************************/
/*! exports provided: LoaderUtils */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function () { return LoaderUtils; });
				class LoaderUtils {

					static decodeText(array) {

						if (typeof TextDecoder !== 'undefined') {

							return new TextDecoder().decode(array);

						}

						// Avoid the String.fromCharCode.apply(null, array) shortcut, which
						// throws a "maximum call stack size exceeded" error for large arrays.

						let s = '';

						for (let i = 0, il = array.length; i < il; i++) {

							// Implicitly assumes little-endian.
							s += String.fromCharCode(array[i]);

						}

						try {

							// merges multi-byte utf-8 characters.

							return decodeURIComponent(escape(s));

						} catch (e) { // see #16358

							return s;

						}

					}

					static extractUrlBase(url) {

						const index = url.lastIndexOf('/');

						if (index === - 1) return './';

						return url.substr(0, index + 1);

					}

					static resolveURL(url, path) {

						// Invalid URL
						if (typeof url !== 'string' || url === '') return '';

						// Host Relative URL
						if (/^https?:\/\//i.test(path) && /^\//.test(url)) {

							path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');

						}

						// Absolute URL http://,https://,//
						if (/^(https?:)?\/\//i.test(url)) return url;

						// Data URI
						if (/^data:.*,.*$/i.test(url)) return url;

						// Blob URL
						if (/^blob:.*$/i.test(url)) return url;

						// Relative URL
						return path + url;

					}

				}




				/***/
}),

/***/ "./libs/three/loaders/LoadingManager.js":
/*!**********************************************!*\
  !*** ./libs/three/loaders/LoadingManager.js ***!
  \**********************************************/
/*! exports provided: DefaultLoadingManager, LoadingManager */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function () { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function () { return LoadingManager; });
				class LoadingManager {

					constructor(onLoad, onProgress, onError) {

						const scope = this;

						let isLoading = false;
						let itemsLoaded = 0;
						let itemsTotal = 0;
						let urlModifier = undefined;
						const handlers = [];

						// Refer to #5689 for the reason why we don't set .onStart
						// in the constructor

						this.onStart = undefined;
						this.onLoad = onLoad;
						this.onProgress = onProgress;
						this.onError = onError;

						this.itemStart = function (url) {

							itemsTotal++;

							if (isLoading === false) {

								if (scope.onStart !== undefined) {

									scope.onStart(url, itemsLoaded, itemsTotal);

								}

							}

							isLoading = true;

						};

						this.itemEnd = function (url) {

							itemsLoaded++;

							if (scope.onProgress !== undefined) {

								scope.onProgress(url, itemsLoaded, itemsTotal);

							}

							if (itemsLoaded === itemsTotal) {

								isLoading = false;

								if (scope.onLoad !== undefined) {

									scope.onLoad();

								}

							}

						};

						this.itemError = function (url) {

							if (scope.onError !== undefined) {

								scope.onError(url);

							}

						};

						this.resolveURL = function (url) {

							if (urlModifier) {

								return urlModifier(url);

							}

							return url;

						};

						this.setURLModifier = function (transform) {

							urlModifier = transform;

							return this;

						};

						this.addHandler = function (regex, loader) {

							handlers.push(regex, loader);

							return this;

						};

						this.removeHandler = function (regex) {

							const index = handlers.indexOf(regex);

							if (index !== - 1) {

								handlers.splice(index, 2);

							}

							return this;

						};

						this.getHandler = function (file) {

							for (let i = 0, l = handlers.length; i < l; i += 2) {

								const regex = handlers[i];
								const loader = handlers[i + 1];

								if (regex.global) regex.lastIndex = 0; // see #17920

								if (regex.test(file)) {

									return loader;

								}

							}

							return null;

						};

					}

				}

				const DefaultLoadingManager = new LoadingManager();




				/***/
}),

/***/ "./libs/three/loaders/TextureLoader.js":
/*!*********************************************!*\
  !*** ./libs/three/loaders/TextureLoader.js ***!
  \*********************************************/
/*! exports provided: TextureLoader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function () { return TextureLoader; });
/* harmony import */ var _ImageLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ImageLoader.js */ "./libs/three/loaders/ImageLoader.js");
/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../textures/Texture.js */ "./libs/three/textures/Texture.js");
/* harmony import */ var _Loader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Loader.js */ "./libs/three/loaders/Loader.js");




				class TextureLoader extends _Loader_js__WEBPACK_IMPORTED_MODULE_2__["Loader"] {

					constructor(manager) {

						super(manager);

					}

					load(url, onLoad, onProgress, onError) {

						const texture = new _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__["Texture"]();

						const loader = new _ImageLoader_js__WEBPACK_IMPORTED_MODULE_0__["ImageLoader"](this.manager);
						loader.setCrossOrigin(this.crossOrigin);
						loader.setPath(this.path);

						loader.load(url, function (image) {
							texture.image = image;
							texture.needsUpdate = true;

							if (onLoad !== undefined) {

								onLoad(texture);

							}

						}, onProgress, onError);

						return texture;

					}

				}





				/***/
}),

/***/ "./libs/three/loaders/decoder_base.js":
/*!********************************************!*\
  !*** ./libs/three/loaders/decoder_base.js ***!
  \********************************************/
/*! exports provided: memory, __wasm_call_ctors, meshopt_decodeVertexBuffer, meshopt_decodeIndexBuffer, meshopt_decodeIndexSequence, meshopt_decodeFilterOct, meshopt_decodeFilterQuat, meshopt_decodeFilterExp, sbrk */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "memory", function () { return memory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__wasm_call_ctors", function () { return __wasm_call_ctors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshopt_decodeVertexBuffer", function () { return meshopt_decodeVertexBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshopt_decodeIndexBuffer", function () { return meshopt_decodeIndexBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshopt_decodeIndexSequence", function () { return meshopt_decodeIndexSequence; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshopt_decodeFilterOct", function () { return meshopt_decodeFilterOct; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshopt_decodeFilterQuat", function () { return meshopt_decodeFilterQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "meshopt_decodeFilterExp", function () { return meshopt_decodeFilterExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sbrk", function () { return sbrk; });

				var bufferView;
				var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);
				for (var i = 25; i >= 0; --i) {
					base64ReverseLookup[48 + i] = 52 + i; // '0-9'
					base64ReverseLookup[65 + i] = i; // 'A-Z'
					base64ReverseLookup[97 + i] = 26 + i; // 'a-z'
				}
				base64ReverseLookup[43] = 62; // '+'
				base64ReverseLookup[47] = 63; // '/'
				/** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
				function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
					var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength * 3 >> 2) - (b64[bLength - 2] == '=') - (b64[bLength - 1] == '=');
					for (; i < bLength; i += 4) {
						b1 = base64ReverseLookup[b64.charCodeAt(i + 1)];
						b2 = base64ReverseLookup[b64.charCodeAt(i + 2)];
						uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
						if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
						if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i + 3)];
					}
				}
				function initActiveSegments(imports) {
					base64DecodeToExistingUint8Array(bufferView, 1024, "EGQAAA==");
				}

				var scratchBuffer = new ArrayBuffer(16);
				var i32ScratchView = new Int32Array(scratchBuffer);
				var f32ScratchView = new Float32Array(scratchBuffer);
				var f64ScratchView = new Float64Array(scratchBuffer);

				function wasm2js_scratch_store_i32(index, value) {
					i32ScratchView[index] = value;
				}

				function wasm2js_scratch_load_f32() {
					return f32ScratchView[2];
				}

				function asmFunc(env) {
					var buffer = new ArrayBuffer(65536);
					var HEAP8 = new Int8Array(buffer);
					var HEAP16 = new Int16Array(buffer);
					var HEAP32 = new Int32Array(buffer);
					var HEAPU8 = new Uint8Array(buffer);
					var HEAPU16 = new Uint16Array(buffer);
					var HEAPU32 = new Uint32Array(buffer);
					var HEAPF32 = new Float32Array(buffer);
					var HEAPF64 = new Float64Array(buffer);
					var Math_imul = Math.imul;
					var Math_fround = Math.fround;
					var Math_abs = Math.abs;
					var Math_clz32 = Math.clz32;
					var Math_min = Math.min;
					var Math_max = Math.max;
					var Math_floor = Math.floor;
					var Math_ceil = Math.ceil;
					var Math_trunc = Math.trunc;
					var Math_sqrt = Math.sqrt;
					var abort = env.abort;
					var nan = NaN;
					var infinity = Infinity;
					var global$0 = 25616;
					function $0() {

					}

					function $1($0_1, $1_1, $2_1, $3_1, $4_1) {
						$0_1 = $0_1 | 0;
						$1_1 = $1_1 | 0;
						$2_1 = $2_1 | 0;
						$3_1 = $3_1 | 0;
						$4_1 = $4_1 | 0;
						var $19 = 0, $18 = 0, $20 = 0, $6_1 = 0, i64toi32_i32$1 = 0, i64toi32_i32$0 = 0, $59 = 0, $8_1 = 0, $16 = 0, $17 = 0, $10 = 0, $11 = 0, $7_1 = 0, $15 = 0, $60 = 0, $61 = 0, $5_1 = 0, $14 = 0, $9_1 = 0, $12 = 0, $13 = 0, $112 = 0, $128 = 0, $143 = 0, $157 = 0, $173 = 0, $188 = 0, $203 = 0, $217 = 0, $233 = 0, $248 = 0, $263 = 0, $277 = 0, $293 = 0, $308 = 0, $323 = 0, $329 = 0, $337 = 0, $352 = 0, $367 = 0, $383 = 0, $397 = 0, $413 = 0, $427 = 0, $443 = 0, $457 = 0, $473 = 0, $487 = 0, $503 = 0, $517 = 0, $533 = 0, $547 = 0, $563 = 0, $569 = 0, $577 = 0, $587 = 0, $592 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
						$5_1 = global$0 - 8704 | 0;
						global$0 = $5_1;
						$6_1 = -2;
						label$1: {
							if (($2_1 + 1 | 0) >>> 0 > $4_1 >>> 0) {
								break label$1
							}
							$6_1 = -1;
							if ((HEAPU8[$3_1 >> 0] | 0 | 0) != (160 | 0)) {
								break label$1
							}
							$7_1 = $3_1 + $4_1 | 0;
							$8_1 = $8($5_1 | 0, $7_1 - $2_1 | 0 | 0, $2_1 | 0) | 0;
							$6_1 = ((8192 >>> 0) / ($2_1 >>> 0) | 0) & 16368 | 0;
							$9_1 = $6_1 >>> 0 < 256 >>> 0 ? $6_1 : 256;
							$4_1 = $3_1 + 1 | 0;
							$10 = 0;
							label$2: {
								label$3: while (1) {
									if ($10 >>> 0 >= $1_1 >>> 0) {
										break label$2
									}
									$11 = ($10 + $9_1 | 0) >>> 0 < $1_1 >>> 0 ? $9_1 : $1_1 - $10 | 0;
									label$4: {
										label$5: {
											if (!$2_1) {
												break label$5
											}
											$6_1 = $11 + 15 | 0;
											$12 = $6_1 & -16 | 0;
											$13 = (($6_1 >>> 4 | 0) + 3 | 0) >>> 2 | 0;
											$14 = $8_1 + 256 | 0;
											$15 = 0;
											$16 = $4_1;
											label$6: while (1) {
												label$7: {
													if (($7_1 - $16 | 0) >>> 0 >= $13 >>> 0) {
														break label$7
													}
													$4_1 = 0;
													break label$4;
												}
												$4_1 = $16 + $13 | 0;
												label$8: {
													if (!$12) {
														break label$8
													}
													$17 = 0;
													$3_1 = 0;
													label$9: while (1) {
														label$10: {
															if (($7_1 - $4_1 | 0) >>> 0 >= 24 >>> 0) {
																break label$10
															}
															$4_1 = 0;
															break label$4;
														}
														$6_1 = ($8_1 + 8448 | 0) + $3_1 | 0;
														label$11: {
															label$12: {
																switch (((HEAPU8[($16 + ($3_1 >>> 6 | 0) | 0) >> 0] | 0) >>> ($17 & 6 | 0) | 0) & 3 | 0 | 0) {
																	default:
																		i64toi32_i32$1 = $6_1;
																		i64toi32_i32$0 = 0;
																		HEAP32[$6_1 >> 2] = 0;
																		HEAP32[($6_1 + 4 | 0) >> 2] = i64toi32_i32$0;
																		i64toi32_i32$1 = $6_1 + 8 | 0;
																		i64toi32_i32$0 = 0;
																		HEAP32[i64toi32_i32$1 >> 2] = 0;
																		HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
																		break label$11;
																	case 1:
																		$18 = HEAPU8[$4_1 >> 0] | 0;
																		$19 = $18 >>> 6 | 0;
																		$112 = $19;
																		$19 = ($19 | 0) == (3 | 0);
																		HEAP8[$6_1 >> 0] = (wasm2js_i32$0 = HEAPU8[($4_1 + 4 | 0) >> 0] | 0, wasm2js_i32$1 = $112, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = ($4_1 + 4 | 0) + $19 | 0;
																		$20 = ($18 >>> 4 | 0) & 3 | 0;
																		$128 = $20;
																		$20 = ($20 | 0) == (3 | 0);
																		HEAP8[($6_1 + 1 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $128, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $20 | 0;
																		$20 = ($18 >>> 2 | 0) & 3 | 0;
																		$143 = $20;
																		$20 = ($20 | 0) == (3 | 0);
																		HEAP8[($6_1 + 2 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $143, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $20 | 0;
																		$18 = $18 & 3 | 0;
																		$157 = $18;
																		$18 = ($18 | 0) == (3 | 0);
																		HEAP8[($6_1 + 3 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $157, wasm2js_i32$2 = $18, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $18 | 0;
																		$18 = HEAPU8[($4_1 + 1 | 0) >> 0] | 0;
																		$20 = $18 >>> 6 | 0;
																		$173 = $20;
																		$20 = ($20 | 0) == (3 | 0);
																		HEAP8[($6_1 + 4 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $173, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $20 | 0;
																		$20 = ($18 >>> 4 | 0) & 3 | 0;
																		$188 = $20;
																		$20 = ($20 | 0) == (3 | 0);
																		HEAP8[($6_1 + 5 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $188, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $20 | 0;
																		$20 = ($18 >>> 2 | 0) & 3 | 0;
																		$203 = $20;
																		$20 = ($20 | 0) == (3 | 0);
																		HEAP8[($6_1 + 6 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $203, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $20 | 0;
																		$18 = $18 & 3 | 0;
																		$217 = $18;
																		$18 = ($18 | 0) == (3 | 0);
																		HEAP8[($6_1 + 7 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $217, wasm2js_i32$2 = $18, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $18 | 0;
																		$18 = HEAPU8[($4_1 + 2 | 0) >> 0] | 0;
																		$20 = $18 >>> 6 | 0;
																		$233 = $20;
																		$20 = ($20 | 0) == (3 | 0);
																		HEAP8[($6_1 + 8 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $233, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $20 | 0;
																		$20 = ($18 >>> 4 | 0) & 3 | 0;
																		$248 = $20;
																		$20 = ($20 | 0) == (3 | 0);
																		HEAP8[($6_1 + 9 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $248, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $20 | 0;
																		$20 = ($18 >>> 2 | 0) & 3 | 0;
																		$263 = $20;
																		$20 = ($20 | 0) == (3 | 0);
																		HEAP8[($6_1 + 10 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $263, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = $19 + $20 | 0;
																		$18 = $18 & 3 | 0;
																		$277 = $18;
																		$18 = ($18 | 0) == (3 | 0);
																		HEAP8[($6_1 + 11 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $277, wasm2js_i32$2 = $18, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $19 + $18 | 0;
																		$4_1 = HEAPU8[($4_1 + 3 | 0) >> 0] | 0;
																		$19 = $4_1 >>> 6 | 0;
																		$293 = $19;
																		$19 = ($19 | 0) == (3 | 0);
																		HEAP8[($6_1 + 12 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $293, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $19 | 0;
																		$19 = ($4_1 >>> 4 | 0) & 3 | 0;
																		$308 = $19;
																		$19 = ($19 | 0) == (3 | 0);
																		HEAP8[($6_1 + 13 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $308, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $19 | 0;
																		$19 = ($4_1 >>> 2 | 0) & 3 | 0;
																		$323 = $19;
																		$19 = ($19 | 0) == (3 | 0);
																		HEAP8[($6_1 + 14 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $323, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$329 = $6_1 + 15 | 0;
																		$6_1 = $18 + $19 | 0;
																		$4_1 = $4_1 & 3 | 0;
																		$337 = $4_1;
																		$4_1 = ($4_1 | 0) == (3 | 0);
																		HEAP8[$329 >> 0] = (wasm2js_i32$0 = HEAPU8[$6_1 >> 0] | 0, wasm2js_i32$1 = $337, wasm2js_i32$2 = $4_1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$4_1 = $6_1 + $4_1 | 0;
																		break label$11;
																	case 2:
																		$18 = HEAPU8[$4_1 >> 0] | 0;
																		$19 = $18 >>> 4 | 0;
																		$352 = $19;
																		$19 = ($19 | 0) == (15 | 0);
																		HEAP8[$6_1 >> 0] = (wasm2js_i32$0 = HEAPU8[($4_1 + 8 | 0) >> 0] | 0, wasm2js_i32$1 = $352, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$19 = ($4_1 + 8 | 0) + $19 | 0;
																		$18 = $18 & 15 | 0;
																		$367 = $18;
																		$18 = ($18 | 0) == (15 | 0);
																		HEAP8[($6_1 + 1 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$19 >> 0] | 0, wasm2js_i32$1 = $367, wasm2js_i32$2 = $18, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $19 + $18 | 0;
																		$19 = HEAPU8[($4_1 + 1 | 0) >> 0] | 0;
																		$20 = $19 >>> 4 | 0;
																		$383 = $20;
																		$20 = ($20 | 0) == (15 | 0);
																		HEAP8[($6_1 + 2 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $383, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $20 | 0;
																		$19 = $19 & 15 | 0;
																		$397 = $19;
																		$19 = ($19 | 0) == (15 | 0);
																		HEAP8[($6_1 + 3 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $397, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $19 | 0;
																		$19 = HEAPU8[($4_1 + 2 | 0) >> 0] | 0;
																		$20 = $19 >>> 4 | 0;
																		$413 = $20;
																		$20 = ($20 | 0) == (15 | 0);
																		HEAP8[($6_1 + 4 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $413, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $20 | 0;
																		$19 = $19 & 15 | 0;
																		$427 = $19;
																		$19 = ($19 | 0) == (15 | 0);
																		HEAP8[($6_1 + 5 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $427, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $19 | 0;
																		$19 = HEAPU8[($4_1 + 3 | 0) >> 0] | 0;
																		$20 = $19 >>> 4 | 0;
																		$443 = $20;
																		$20 = ($20 | 0) == (15 | 0);
																		HEAP8[($6_1 + 6 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $443, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $20 | 0;
																		$19 = $19 & 15 | 0;
																		$457 = $19;
																		$19 = ($19 | 0) == (15 | 0);
																		HEAP8[($6_1 + 7 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $457, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $19 | 0;
																		$19 = HEAPU8[($4_1 + 4 | 0) >> 0] | 0;
																		$20 = $19 >>> 4 | 0;
																		$473 = $20;
																		$20 = ($20 | 0) == (15 | 0);
																		HEAP8[($6_1 + 8 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $473, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $20 | 0;
																		$19 = $19 & 15 | 0;
																		$487 = $19;
																		$19 = ($19 | 0) == (15 | 0);
																		HEAP8[($6_1 + 9 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $487, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $19 | 0;
																		$19 = HEAPU8[($4_1 + 5 | 0) >> 0] | 0;
																		$20 = $19 >>> 4 | 0;
																		$503 = $20;
																		$20 = ($20 | 0) == (15 | 0);
																		HEAP8[($6_1 + 10 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $503, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $20 | 0;
																		$19 = $19 & 15 | 0;
																		$517 = $19;
																		$19 = ($19 | 0) == (15 | 0);
																		HEAP8[($6_1 + 11 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $517, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $19 | 0;
																		$19 = HEAPU8[($4_1 + 6 | 0) >> 0] | 0;
																		$20 = $19 >>> 4 | 0;
																		$533 = $20;
																		$20 = ($20 | 0) == (15 | 0);
																		HEAP8[($6_1 + 12 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $533, wasm2js_i32$2 = $20, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $20 | 0;
																		$19 = $19 & 15 | 0;
																		$547 = $19;
																		$19 = ($19 | 0) == (15 | 0);
																		HEAP8[($6_1 + 13 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $547, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$18 = $18 + $19 | 0;
																		$4_1 = HEAPU8[($4_1 + 7 | 0) >> 0] | 0;
																		$19 = $4_1 >>> 4 | 0;
																		$563 = $19;
																		$19 = ($19 | 0) == (15 | 0);
																		HEAP8[($6_1 + 14 | 0) >> 0] = (wasm2js_i32$0 = HEAPU8[$18 >> 0] | 0, wasm2js_i32$1 = $563, wasm2js_i32$2 = $19, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$569 = $6_1 + 15 | 0;
																		$6_1 = $18 + $19 | 0;
																		$4_1 = $4_1 & 15 | 0;
																		$577 = $4_1;
																		$4_1 = ($4_1 | 0) == (15 | 0);
																		HEAP8[$569 >> 0] = (wasm2js_i32$0 = HEAPU8[$6_1 >> 0] | 0, wasm2js_i32$1 = $577, wasm2js_i32$2 = $4_1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
																		$4_1 = $6_1 + $4_1 | 0;
																		break label$11;
																	case 3:
																		break label$12;
																};
															}
															i64toi32_i32$0 = HEAPU8[$4_1 >> 0] | 0 | ((HEAPU8[($4_1 + 1 | 0) >> 0] | 0) << 8 | 0) | 0 | ((HEAPU8[($4_1 + 2 | 0) >> 0] | 0) << 16 | 0 | ((HEAPU8[($4_1 + 3 | 0) >> 0] | 0) << 24 | 0) | 0) | 0;
															i64toi32_i32$1 = HEAPU8[($4_1 + 4 | 0) >> 0] | 0 | ((HEAPU8[($4_1 + 5 | 0) >> 0] | 0) << 8 | 0) | 0 | ((HEAPU8[($4_1 + 6 | 0) >> 0] | 0) << 16 | 0 | ((HEAPU8[($4_1 + 7 | 0) >> 0] | 0) << 24 | 0) | 0) | 0;
															$587 = i64toi32_i32$0;
															i64toi32_i32$0 = $6_1;
															$60 = $587;
															HEAP8[$6_1 >> 0] = $60;
															HEAP8[($6_1 + 1 | 0) >> 0] = $60 >>> 8 | 0;
															HEAP8[($6_1 + 2 | 0) >> 0] = $60 >>> 16 | 0;
															HEAP8[($6_1 + 3 | 0) >> 0] = $60 >>> 24 | 0;
															HEAP8[($6_1 + 4 | 0) >> 0] = i64toi32_i32$1;
															HEAP8[($6_1 + 5 | 0) >> 0] = i64toi32_i32$1 >>> 8 | 0;
															HEAP8[($6_1 + 6 | 0) >> 0] = i64toi32_i32$1 >>> 16 | 0;
															HEAP8[($6_1 + 7 | 0) >> 0] = i64toi32_i32$1 >>> 24 | 0;
															$59 = $4_1 + 8 | 0;
															i64toi32_i32$1 = HEAPU8[$59 >> 0] | 0 | ((HEAPU8[($59 + 1 | 0) >> 0] | 0) << 8 | 0) | 0 | ((HEAPU8[($59 + 2 | 0) >> 0] | 0) << 16 | 0 | ((HEAPU8[($59 + 3 | 0) >> 0] | 0) << 24 | 0) | 0) | 0;
															i64toi32_i32$0 = HEAPU8[($59 + 4 | 0) >> 0] | 0 | ((HEAPU8[($59 + 5 | 0) >> 0] | 0) << 8 | 0) | 0 | ((HEAPU8[($59 + 6 | 0) >> 0] | 0) << 16 | 0 | ((HEAPU8[($59 + 7 | 0) >> 0] | 0) << 24 | 0) | 0) | 0;
															$592 = i64toi32_i32$1;
															i64toi32_i32$1 = $6_1 + 8 | 0;
															$61 = $592;
															HEAP8[i64toi32_i32$1 >> 0] = $61;
															HEAP8[(i64toi32_i32$1 + 1 | 0) >> 0] = $61 >>> 8 | 0;
															HEAP8[(i64toi32_i32$1 + 2 | 0) >> 0] = $61 >>> 16 | 0;
															HEAP8[(i64toi32_i32$1 + 3 | 0) >> 0] = $61 >>> 24 | 0;
															HEAP8[(i64toi32_i32$1 + 4 | 0) >> 0] = i64toi32_i32$0;
															HEAP8[(i64toi32_i32$1 + 5 | 0) >> 0] = i64toi32_i32$0 >>> 8 | 0;
															HEAP8[(i64toi32_i32$1 + 6 | 0) >> 0] = i64toi32_i32$0 >>> 16 | 0;
															HEAP8[(i64toi32_i32$1 + 7 | 0) >> 0] = i64toi32_i32$0 >>> 24 | 0;
															$4_1 = $4_1 + 16 | 0;
														}
														$17 = $17 + 2 | 0;
														$3_1 = $3_1 + 16 | 0;
														if ($3_1 >>> 0 < $12 >>> 0) {
															continue label$9
														}
														break label$9;
													};
												}
												label$16: {
													if ($4_1) {
														break label$16
													}
													$4_1 = 0;
													break label$4;
												}
												label$17: {
													if (!$11) {
														break label$17
													}
													$17 = HEAPU8[($8_1 + $15 | 0) >> 0] | 0;
													$6_1 = 0;
													$3_1 = $14;
													label$18: while (1) {
														$16 = HEAPU8[(($8_1 + 8448 | 0) + $6_1 | 0) >> 0] | 0;
														$17 = (($16 >>> 1 | 0) ^ (0 - ($16 & 1 | 0) | 0) | 0) + $17 | 0;
														HEAP8[$3_1 >> 0] = $17;
														$3_1 = $3_1 + $2_1 | 0;
														$6_1 = $6_1 + 1 | 0;
														if (($6_1 | 0) != ($11 | 0)) {
															continue label$18
														}
														break label$18;
													};
												}
												$14 = $14 + 1 | 0;
												$16 = $4_1;
												$15 = $15 + 1 | 0;
												if (($15 | 0) != ($2_1 | 0)) {
													continue label$6
												}
												break label$6;
											};
										}
										$8($0_1 + Math_imul($10, $2_1) | 0 | 0, $8_1 + 256 | 0 | 0, Math_imul($11, $2_1) | 0) | 0;
										$8($8_1 | 0, ($8_1 + 256 | 0) + Math_imul($11 + -1 | 0, $2_1) | 0 | 0, $2_1 | 0) | 0;
									}
									$10 = ($4_1 ? $11 : 0) + $10 | 0;
									if ($4_1) {
										continue label$3
									}
									break label$3;
								};
								$6_1 = -2;
								break label$1;
							}
							$6_1 = ($7_1 - $4_1 | 0 | 0) == (($2_1 >>> 0 > 32 >>> 0 ? $2_1 : 32) | 0) ? 0 : -3;
						}
						global$0 = $5_1 + 8704 | 0;
						return $6_1 | 0;
					}

					function $2($0_1, $1_1, $2_1, $3_1, $4_1) {
						$0_1 = $0_1 | 0;
						$1_1 = $1_1 | 0;
						$2_1 = $2_1 | 0;
						$3_1 = $3_1 | 0;
						$4_1 = $4_1 | 0;
						var $7_1 = 0, $11 = 0, $15 = 0, $19 = 0, $5_1 = 0, $16 = 0, $6_1 = 0, i64toi32_i32$1 = 0, $20 = 0, $13 = 0, $17 = 0, $9_1 = 0, i64toi32_i32$0 = 0, $18 = 0, $8_1 = 0, $10 = 0, $14 = 0, $12 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
						$5_1 = global$0 - 192 | 0;
						global$0 = $5_1;
						$6_1 = -2;
						label$1: {
							$7_1 = ($1_1 >>> 0) / (3 >>> 0) | 0;
							if (($7_1 + 17 | 0) >>> 0 > $4_1 >>> 0) {
								break label$1
							}
							$6_1 = -1;
							$8_1 = HEAPU8[$3_1 >> 0] | 0;
							if (($8_1 & 240 | 0 | 0) != (224 | 0)) {
								break label$1
							}
							$9_1 = $8_1 & 15 | 0;
							if ($9_1 >>> 0 > 1 >>> 0) {
								break label$1
							}
							$9($5_1 + 64 | 0 | 0, 255 | 0, 128 | 0) | 0;
							i64toi32_i32$1 = $5_1 + 56 | 0;
							i64toi32_i32$0 = -1;
							HEAP32[i64toi32_i32$1 >> 2] = -1;
							HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
							i64toi32_i32$1 = $5_1 + 48 | 0;
							i64toi32_i32$0 = -1;
							HEAP32[i64toi32_i32$1 >> 2] = -1;
							HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
							i64toi32_i32$1 = $5_1 + 40 | 0;
							i64toi32_i32$0 = -1;
							HEAP32[i64toi32_i32$1 >> 2] = -1;
							HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
							i64toi32_i32$1 = $5_1 + 32 | 0;
							i64toi32_i32$0 = -1;
							HEAP32[i64toi32_i32$1 >> 2] = -1;
							HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
							i64toi32_i32$1 = $5_1 + 24 | 0;
							i64toi32_i32$0 = -1;
							HEAP32[i64toi32_i32$1 >> 2] = -1;
							HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
							i64toi32_i32$1 = $5_1 + 16 | 0;
							i64toi32_i32$0 = -1;
							HEAP32[i64toi32_i32$1 >> 2] = -1;
							HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;
							i64toi32_i32$1 = $5_1;
							i64toi32_i32$0 = -1;
							HEAP32[($5_1 + 8 | 0) >> 2] = -1;
							HEAP32[($5_1 + 12 | 0) >> 2] = i64toi32_i32$0;
							i64toi32_i32$1 = $5_1;
							i64toi32_i32$0 = -1;
							HEAP32[$5_1 >> 2] = -1;
							HEAP32[($5_1 + 4 | 0) >> 2] = i64toi32_i32$0;
							$10 = ($3_1 + $4_1 | 0) + -16 | 0;
							$8_1 = $3_1 + 1 | 0;
							$11 = $8_1 + $7_1 | 0;
							label$2: {
								if (!$1_1) {
									break label$2
								}
								$12 = ($9_1 | 0) == (1 | 0) ? 13 : 15;
								$3_1 = $0_1;
								$9_1 = 0;
								$13 = 0;
								$14 = 0;
								$4_1 = 0;
								$6_1 = 0;
								label$3: while (1) {
									label$4: {
										if ($11 >>> 0 <= $10 >>> 0) {
											break label$4
										}
										$6_1 = -2;
										break label$1;
									}
									label$5: {
										label$6: {
											$7_1 = HEAPU8[$8_1 >> 0] | 0;
											if ($7_1 >>> 0 > 239 >>> 0) {
												break label$6
											}
											$15 = ($5_1 + 64 | 0) + ((((($7_1 >>> 4 | 0) ^ -1 | 0) + $6_1 | 0) & 15 | 0) << 3 | 0) | 0;
											$16 = HEAP32[($15 + 4 | 0) >> 2] | 0;
											$17 = HEAP32[$15 >> 2] | 0;
											label$7: {
												$15 = $7_1 & 15 | 0;
												if ($15 >>> 0 >= $12 >>> 0) {
													break label$7
												}
												$7_1 = (wasm2js_i32$0 = HEAP32[($5_1 + (((($7_1 ^ -1 | 0) + $4_1 | 0) & 15 | 0) << 2 | 0) | 0) >> 2] | 0, wasm2js_i32$1 = $9_1, wasm2js_i32$2 = $15, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
												$15 = !$15;
												label$8: {
													label$9: {
														if (($2_1 | 0) != (2 | 0)) {
															break label$9
														}
														HEAP16[$0_1 >> 1] = $17;
														HEAP16[($0_1 + 4 | 0) >> 1] = $7_1;
														HEAP16[($0_1 + 2 | 0) >> 1] = $16;
														break label$8;
													}
													HEAP32[$3_1 >> 2] = $17;
													HEAP32[($3_1 + 8 | 0) >> 2] = $7_1;
													HEAP32[($3_1 + 4 | 0) >> 2] = $16;
												}
												$9_1 = $9_1 + $15 | 0;
												$18 = ($5_1 + 64 | 0) + ($6_1 << 3 | 0) | 0;
												HEAP32[$18 >> 2] = $7_1;
												HEAP32[($18 + 4 | 0) >> 2] = $16;
												HEAP32[($5_1 + ($4_1 << 2 | 0) | 0) >> 2] = $7_1;
												$6_1 = ($6_1 + 1 | 0) & 15 | 0;
												$16 = ($5_1 + 64 | 0) + ($6_1 << 3 | 0) | 0;
												HEAP32[$16 >> 2] = $17;
												HEAP32[($16 + 4 | 0) >> 2] = $7_1;
												$4_1 = $4_1 + $15 | 0;
												$6_1 = $6_1 + 1 | 0;
												break label$5;
											}
											label$10: {
												label$11: {
													if (($15 | 0) == (15 | 0)) {
														break label$11
													}
													$13 = (($13 + $15 | 0) + ($15 ^ -4 | 0) | 0) + 1 | 0;
													break label$10;
												}
												$15 = HEAP8[$11 >> 0] | 0;
												$7_1 = $15 & 255 | 0;
												label$12: {
													label$13: {
														if (($15 | 0) <= (-1 | 0)) {
															break label$13
														}
														$11 = $11 + 1 | 0;
														break label$12;
													}
													$15 = HEAP8[($11 + 1 | 0) >> 0] | 0;
													$7_1 = ($15 & 127 | 0) << 7 | 0 | ($7_1 & 127 | 0) | 0;
													label$14: {
														if (($15 | 0) <= (-1 | 0)) {
															break label$14
														}
														$11 = $11 + 2 | 0;
														break label$12;
													}
													$15 = HEAP8[($11 + 2 | 0) >> 0] | 0;
													$7_1 = ($15 & 127 | 0) << 14 | 0 | $7_1 | 0;
													label$15: {
														if (($15 | 0) <= (-1 | 0)) {
															break label$15
														}
														$11 = $11 + 3 | 0;
														break label$12;
													}
													$15 = HEAP8[($11 + 3 | 0) >> 0] | 0;
													$7_1 = ($15 & 127 | 0) << 21 | 0 | $7_1 | 0;
													label$16: {
														if (($15 | 0) <= (-1 | 0)) {
															break label$16
														}
														$11 = $11 + 4 | 0;
														break label$12;
													}
													$7_1 = (HEAPU8[($11 + 4 | 0) >> 0] | 0) << 28 | 0 | $7_1 | 0;
													$11 = $11 + 5 | 0;
												}
												$13 = (($7_1 >>> 1 | 0) ^ (0 - ($7_1 & 1 | 0) | 0) | 0) + $13 | 0;
											}
											label$17: {
												label$18: {
													if (($2_1 | 0) != (2 | 0)) {
														break label$18
													}
													HEAP16[$0_1 >> 1] = $17;
													HEAP16[($0_1 + 4 | 0) >> 1] = $13;
													HEAP16[($0_1 + 2 | 0) >> 1] = $16;
													break label$17;
												}
												HEAP32[$3_1 >> 2] = $17;
												HEAP32[($3_1 + 8 | 0) >> 2] = $13;
												HEAP32[($3_1 + 4 | 0) >> 2] = $16;
											}
											$7_1 = ($5_1 + 64 | 0) + ($6_1 << 3 | 0) | 0;
											HEAP32[$7_1 >> 2] = $13;
											HEAP32[($7_1 + 4 | 0) >> 2] = $16;
											HEAP32[($5_1 + ($4_1 << 2 | 0) | 0) >> 2] = $13;
											$6_1 = ($6_1 + 1 | 0) & 15 | 0;
											$7_1 = ($5_1 + 64 | 0) + ($6_1 << 3 | 0) | 0;
											HEAP32[$7_1 >> 2] = $17;
											HEAP32[($7_1 + 4 | 0) >> 2] = $13;
											$4_1 = $4_1 + 1 | 0;
											$6_1 = $6_1 + 1 | 0;
											break label$5;
										}
										label$19: {
											if ($7_1 >>> 0 > 253 >>> 0) {
												break label$19
											}
											$15 = HEAPU8[($10 + ($7_1 & 15 | 0) | 0) >> 0] | 0;
											$16 = $15 >>> 4 | 0;
											$17 = $9_1 + 1 | 0;
											$7_1 = (wasm2js_i32$0 = HEAP32[($5_1 + ((($4_1 - $16 | 0) & 15 | 0) << 2 | 0) | 0) >> 2] | 0, wasm2js_i32$1 = $17, wasm2js_i32$2 = $16, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
											$18 = !$16;
											$17 = $17 + $18 | 0;
											$16 = $15 & 15 | 0;
											$15 = (wasm2js_i32$0 = HEAP32[($5_1 + ((($4_1 - $15 | 0) & 15 | 0) << 2 | 0) | 0) >> 2] | 0, wasm2js_i32$1 = $17, wasm2js_i32$2 = $16, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);
											$16 = !$16;
											label$20: {
												label$21: {
													if (($2_1 | 0) != (2 | 0)) {
														break label$21
													}
													HEAP16[$0_1 >> 1] = $9_1;
													HEAP16[($0_1 + 4 | 0) >> 1] = $15;
													HEAP16[($0_1 + 2 | 0) >> 1] = $7_1;
													break label$20;
												}
												HEAP32[$3_1 >> 2] = $9_1;
												HEAP32[($3_1 + 8 | 0) >> 2] = $15;
												HEAP32[($3_1 + 4 | 0) >> 2] = $7_1;
											}
											HEAP32[($5_1 + ($4_1 << 2 | 0) | 0) >> 2] = $9_1;
											$19 = ($5_1 + 64 | 0) + ($6_1 << 3 | 0) | 0;
											HEAP32[$19 >> 2] = $7_1;
											HEAP32[($19 + 4 | 0) >> 2] = $9_1;
											$4_1 = $4_1 + 1 | 0;
											HEAP32[($5_1 + (($4_1 & 15 | 0) << 2 | 0) | 0) >> 2] = $7_1;
											$19 = ($5_1 + 64 | 0) + ((($6_1 + 1 | 0) & 15 | 0) << 3 | 0) | 0;
											HEAP32[$19 >> 2] = $15;
											HEAP32[($19 + 4 | 0) >> 2] = $7_1;
											$4_1 = ($4_1 + $18 | 0) & 15 | 0;
											HEAP32[($5_1 + ($4_1 << 2 | 0) | 0) >> 2] = $15;
											$6_1 = ($6_1 + 2 | 0) & 15 | 0;
											$7_1 = ($5_1 + 64 | 0) + ($6_1 << 3 | 0) | 0;
											HEAP32[$7_1 >> 2] = $9_1;
											HEAP32[($7_1 + 4 | 0) >> 2] = $15;
											$6_1 = $6_1 + 1 | 0;
											$4_1 = $4_1 + $16 | 0;
											$9_1 = $17 + $16 | 0;
											break label$5;
										}
										$19 = HEAPU8[$11 >> 0] | 0;
										$16 = $19 ? $9_1 : 0;
										$20 = ($7_1 | 0) == (254 | 0);
										$7_1 = $16 + $20 | 0;
										$17 = $19 & 15 | 0;
										label$22: {
											label$23: {
												$18 = $19 >>> 4 | 0;
												if ($18) {
													break label$23
												}
												$15 = $7_1 + 1 | 0;
												break label$22;
											}
											$15 = $7_1;
											$7_1 = HEAP32[($5_1 + ((($4_1 - $18 | 0) & 15 | 0) << 2 | 0) | 0) >> 2] | 0;
										}
										label$24: {
											label$25: {
												if ($17) {
													break label$25
												}
												$9_1 = $15 + 1 | 0;
												break label$24;
											}
											$9_1 = $15;
											$15 = HEAP32[($5_1 + ((($4_1 - $19 | 0) & 15 | 0) << 2 | 0) | 0) >> 2] | 0;
										}
										label$26: {
											label$27: {
												if (!$20) {
													break label$27
												}
												$19 = $11 + 1 | 0;
												break label$26;
											}
											$19 = HEAP8[($11 + 1 | 0) >> 0] | 0;
											$16 = $19 & 255 | 0;
											label$28: {
												label$29: {
													if (($19 | 0) <= (-1 | 0)) {
														break label$29
													}
													$19 = $11 + 2 | 0;
													break label$28;
												}
												$19 = HEAP8[($11 + 2 | 0) >> 0] | 0;
												$16 = ($19 & 127 | 0) << 7 | 0 | ($16 & 127 | 0) | 0;
												label$30: {
													if (($19 | 0) <= (-1 | 0)) {
														break label$30
													}
													$19 = $11 + 3 | 0;
													break label$28;
												}
												$19 = HEAP8[($11 + 3 | 0) >> 0] | 0;
												$16 = ($19 & 127 | 0) << 14 | 0 | $16 | 0;
												label$31: {
													if (($19 | 0) <= (-1 | 0)) {
														break label$31
													}
													$19 = $11 + 4 | 0;
													break label$28;
												}
												$19 = HEAP8[($11 + 4 | 0) >> 0] | 0;
												$16 = ($19 & 127 | 0) << 21 | 0 | $16 | 0;
												label$32: {
													if (($19 | 0) <= (-1 | 0)) {
														break label$32
													}
													$19 = $11 + 5 | 0;
													break label$28;
												}
												$19 = $11 + 6 | 0;
												$16 = (HEAPU8[($11 + 5 | 0) >> 0] | 0) << 28 | 0 | $16 | 0;
											}
											$13 = (($16 >>> 1 | 0) ^ (0 - ($16 & 1 | 0) | 0) | 0) + $13 | 0;
											$16 = $13;
										}
										label$33: {
											label$34: {
												if (($18 | 0) == (15 | 0)) {
													break label$34
												}
												$20 = $19;
												break label$33;
											}
											$11 = HEAP8[$19 >> 0] | 0;
											$7_1 = $11 & 255 | 0;
											label$35: {
												label$36: {
													if (($11 | 0) <= (-1 | 0)) {
														break label$36
													}
													$20 = $19 + 1 | 0;
													break label$35;
												}
												$11 = HEAP8[($19 + 1 | 0) >> 0] | 0;
												$7_1 = ($11 & 127 | 0) << 7 | 0 | ($7_1 & 127 | 0) | 0;
												label$37: {
													if (($11 | 0) <= (-1 | 0)) {
														break label$37
													}
													$20 = $19 + 2 | 0;
													break label$35;
												}
												$11 = HEAP8[($19 + 2 | 0) >> 0] | 0;
												$7_1 = ($11 & 127 | 0) << 14 | 0 | $7_1 | 0;
												label$38: {
													if (($11 | 0) <= (-1 | 0)) {
														break label$38
													}
													$20 = $19 + 3 | 0;
													break label$35;
												}
												$11 = HEAP8[($19 + 3 | 0) >> 0] | 0;
												$7_1 = ($11 & 127 | 0) << 21 | 0 | $7_1 | 0;
												label$39: {
													if (($11 | 0) <= (-1 | 0)) {
														break label$39
													}
													$20 = $19 + 4 | 0;
													break label$35;
												}
												$20 = $19 + 5 | 0;
												$7_1 = (HEAPU8[($19 + 4 | 0) >> 0] | 0) << 28 | 0 | $7_1 | 0;
											}
											$13 = (($7_1 >>> 1 | 0) ^ (0 - ($7_1 & 1 | 0) | 0) | 0) + $13 | 0;
											$7_1 = $13;
										}
										label$40: {
											label$41: {
												if (($17 | 0) == (15 | 0)) {
													break label$41
												}
												$11 = $20;
												break label$40;
											}
											$11 = HEAP8[$20 >> 0] | 0;
											$15 = $11 & 255 | 0;
											label$42: {
												label$43: {
													if (($11 | 0) <= (-1 | 0)) {
														break label$43
													}
													$11 = $20 + 1 | 0;
													break label$42;
												}
												$11 = HEAP8[($20 + 1 | 0) >> 0] | 0;
												$15 = ($11 & 127 | 0) << 7 | 0 | ($15 & 127 | 0) | 0;
												label$44: {
													if (($11 | 0) <= (-1 | 0)) {
														break label$44
													}
													$11 = $20 + 2 | 0;
													break label$42;
												}
												$11 = HEAP8[($20 + 2 | 0) >> 0] | 0;
												$15 = ($11 & 127 | 0) << 14 | 0 | $15 | 0;
												label$45: {
													if (($11 | 0) <= (-1 | 0)) {
														break label$45
													}
													$11 = $20 + 3 | 0;
													break label$42;
												}
												$11 = HEAP8[($20 + 3 | 0) >> 0] | 0;
												$15 = ($11 & 127 | 0) << 21 | 0 | $15 | 0;
												label$46: {
													if (($11 | 0) <= (-1 | 0)) {
														break label$46
													}
													$11 = $20 + 4 | 0;
													break label$42;
												}
												$11 = $20 + 5 | 0;
												$15 = (HEAPU8[($20 + 4 | 0) >> 0] | 0) << 28 | 0 | $15 | 0;
											}
											$13 = (($15 >>> 1 | 0) ^ (0 - ($15 & 1 | 0) | 0) | 0) + $13 | 0;
											$15 = $13;
										}
										label$47: {
											label$48: {
												if (($2_1 | 0) != (2 | 0)) {
													break label$48
												}
												HEAP16[$0_1 >> 1] = $16;
												HEAP16[($0_1 + 4 | 0) >> 1] = $15;
												HEAP16[($0_1 + 2 | 0) >> 1] = $7_1;
												break label$47;
											}
											HEAP32[$3_1 >> 2] = $16;
											HEAP32[($3_1 + 8 | 0) >> 2] = $15;
											HEAP32[($3_1 + 4 | 0) >> 2] = $7_1;
										}
										$19 = ($5_1 + 64 | 0) + ($6_1 << 3 | 0) | 0;
										HEAP32[$19 >> 2] = $7_1;
										HEAP32[($19 + 4 | 0) >> 2] = $16;
										HEAP32[($5_1 + ($4_1 << 2 | 0) | 0) >> 2] = $16;
										$19 = ($5_1 + 64 | 0) + ((($6_1 + 1 | 0) & 15 | 0) << 3 | 0) | 0;
										HEAP32[$19 >> 2] = $15;
										HEAP32[($19 + 4 | 0) >> 2] = $7_1;
										$4_1 = $4_1 + 1 | 0;
										HEAP32[($5_1 + (($4_1 & 15 | 0) << 2 | 0) | 0) >> 2] = $7_1;
										$7_1 = ($5_1 + 64 | 0) + ((($6_1 + 2 | 0) & 15 | 0) << 3 | 0) | 0;
										HEAP32[$7_1 >> 2] = $16;
										HEAP32[($7_1 + 4 | 0) >> 2] = $15;
										$4_1 = $4_1 + (!$18 | ($18 | 0) == (15 | 0) | 0) | 0;
										HEAP32[($5_1 + (($4_1 & 15 | 0) << 2 | 0) | 0) >> 2] = $15;
										$4_1 = $4_1 + (!$17 | ($17 | 0) == (15 | 0) | 0) | 0;
										$6_1 = $6_1 + 3 | 0;
									}
									$8_1 = $8_1 + 1 | 0;
									$0_1 = $0_1 + 6 | 0;
									$3_1 = $3_1 + 12 | 0;
									$6_1 = $6_1 & 15 | 0;
									$4_1 = $4_1 & 15 | 0;
									$14 = $14 + 3 | 0;
									if ($14 >>> 0 < $1_1 >>> 0) {
										continue label$3
									}
									break label$3;
								};
							}
							$6_1 = ($11 | 0) == ($10 | 0) ? 0 : -3;
						}
						global$0 = $5_1 + 192 | 0;
						return $6_1 | 0;
					}

					function $3($0_1, $1_1, $2_1, $3_1, $4_1) {
						$0_1 = $0_1 | 0;
						$1_1 = $1_1 | 0;
						$2_1 = $2_1 | 0;
						$3_1 = $3_1 | 0;
						$4_1 = $4_1 | 0;
						var $6_1 = 0, $5_1 = 0, $164 = 0;
						$5_1 = global$0 - 16 | 0;
						$6_1 = -2;
						label$1: {
							if (($1_1 + 5 | 0) >>> 0 > $4_1 >>> 0) {
								break label$1
							}
							$6_1 = -1;
							if (((HEAPU8[$3_1 >> 0] | 0) & 254 | 0 | 0) != (208 | 0)) {
								break label$1
							}
							HEAP32[($5_1 + 8 | 0) >> 2] = 0;
							HEAP32[($5_1 + 12 | 0) >> 2] = 0;
							$6_1 = $3_1 + 1 | 0;
							$3_1 = ($3_1 + $4_1 | 0) + -4 | 0;
							label$2: {
								if (!$1_1) {
									break label$2
								}
								label$3: {
									if (($2_1 | 0) == (2 | 0)) {
										break label$3
									}
									label$4: while (1) {
										label$5: {
											if ($6_1 >>> 0 < $3_1 >>> 0) {
												break label$5
											}
											return -2 | 0;
										}
										$2_1 = HEAP8[$6_1 >> 0] | 0;
										$4_1 = $2_1 & 255 | 0;
										label$6: {
											label$7: {
												if (($2_1 | 0) <= (-1 | 0)) {
													break label$7
												}
												$6_1 = $6_1 + 1 | 0;
												break label$6;
											}
											$2_1 = HEAP8[($6_1 + 1 | 0) >> 0] | 0;
											$4_1 = ($2_1 & 127 | 0) << 7 | 0 | ($4_1 & 127 | 0) | 0;
											label$8: {
												if (($2_1 | 0) <= (-1 | 0)) {
													break label$8
												}
												$6_1 = $6_1 + 2 | 0;
												break label$6;
											}
											$2_1 = HEAP8[($6_1 + 2 | 0) >> 0] | 0;
											$4_1 = ($2_1 & 127 | 0) << 14 | 0 | $4_1 | 0;
											label$9: {
												if (($2_1 | 0) <= (-1 | 0)) {
													break label$9
												}
												$6_1 = $6_1 + 3 | 0;
												break label$6;
											}
											$2_1 = HEAP8[($6_1 + 3 | 0) >> 0] | 0;
											$4_1 = ($2_1 & 127 | 0) << 21 | 0 | $4_1 | 0;
											label$10: {
												if (($2_1 | 0) <= (-1 | 0)) {
													break label$10
												}
												$6_1 = $6_1 + 4 | 0;
												break label$6;
											}
											$4_1 = (HEAPU8[($6_1 + 4 | 0) >> 0] | 0) << 28 | 0 | $4_1 | 0;
											$6_1 = $6_1 + 5 | 0;
										}
										$2_1 = $5_1 + 8 | 0 | (($4_1 & 1 | 0) << 2 | 0) | 0;
										$4_1 = (($4_1 >>> 2 | 0) ^ (0 - (($4_1 >>> 1 | 0) & 1 | 0) | 0) | 0) + (HEAP32[$2_1 >> 2] | 0) | 0;
										HEAP32[$2_1 >> 2] = $4_1;
										HEAP32[$0_1 >> 2] = $4_1;
										$0_1 = $0_1 + 4 | 0;
										$1_1 = $1_1 + -1 | 0;
										if ($1_1) {
											continue label$4
										}
										break label$2;
									};
								}
								label$11: while (1) {
									label$12: {
										if ($6_1 >>> 0 < $3_1 >>> 0) {
											break label$12
										}
										return -2 | 0;
									}
									$2_1 = HEAP8[$6_1 >> 0] | 0;
									$4_1 = $2_1 & 255 | 0;
									label$13: {
										label$14: {
											if (($2_1 | 0) <= (-1 | 0)) {
												break label$14
											}
											$6_1 = $6_1 + 1 | 0;
											break label$13;
										}
										$2_1 = HEAP8[($6_1 + 1 | 0) >> 0] | 0;
										$4_1 = ($2_1 & 127 | 0) << 7 | 0 | ($4_1 & 127 | 0) | 0;
										label$15: {
											if (($2_1 | 0) <= (-1 | 0)) {
												break label$15
											}
											$6_1 = $6_1 + 2 | 0;
											break label$13;
										}
										$2_1 = HEAP8[($6_1 + 2 | 0) >> 0] | 0;
										$4_1 = ($2_1 & 127 | 0) << 14 | 0 | $4_1 | 0;
										label$16: {
											if (($2_1 | 0) <= (-1 | 0)) {
												break label$16
											}
											$6_1 = $6_1 + 3 | 0;
											break label$13;
										}
										$2_1 = HEAP8[($6_1 + 3 | 0) >> 0] | 0;
										$4_1 = ($2_1 & 127 | 0) << 21 | 0 | $4_1 | 0;
										label$17: {
											if (($2_1 | 0) <= (-1 | 0)) {
												break label$17
											}
											$6_1 = $6_1 + 4 | 0;
											break label$13;
										}
										$4_1 = (HEAPU8[($6_1 + 4 | 0) >> 0] | 0) << 28 | 0 | $4_1 | 0;
										$6_1 = $6_1 + 5 | 0;
									}
									$164 = ($4_1 >>> 2 | 0) ^ (0 - (($4_1 >>> 1 | 0) & 1 | 0) | 0) | 0;
									$4_1 = $5_1 + 8 | 0 | (($4_1 & 1 | 0) << 2 | 0) | 0;
									$2_1 = $164 + (HEAP32[$4_1 >> 2] | 0) | 0;
									HEAP16[$0_1 >> 1] = $2_1;
									HEAP32[$4_1 >> 2] = $2_1;
									$0_1 = $0_1 + 2 | 0;
									$1_1 = $1_1 + -1 | 0;
									if ($1_1) {
										continue label$11
									}
									break label$11;
								};
							}
							$6_1 = ($6_1 | 0) == ($3_1 | 0) ? 0 : -3;
						}
						return $6_1 | 0;
					}

					function $4($0_1, $1_1, $2_1) {
						$0_1 = $0_1 | 0;
						$1_1 = $1_1 | 0;
						$2_1 = $2_1 | 0;
						var $8_1 = Math_fround(0), $10 = Math_fround(0), $4_1 = Math_fround(0), $7_1 = Math_fround(0), $3_1 = 0, $5_1 = 0, $6_1 = 0, $9_1 = 0, $11 = Math_fround(0);
						label$1: {
							label$2: {
								if (($2_1 | 0) != (4 | 0)) {
									break label$2
								}
								if (!$1_1) {
									break label$1
								}
								label$3: while (1) {
									label$4: {
										label$5: {
											$2_1 = $0_1 + 2 | 0;
											$3_1 = HEAP8[$0_1 >> 0] | 0;
											$4_1 = Math_fround($3_1 | 0);
											$5_1 = $0_1 + 1 | 0;
											$6_1 = HEAP8[$5_1 >> 0] | 0;
											$7_1 = Math_fround($6_1 | 0);
											$8_1 = Math_fround(Math_fround(Math_fround(HEAP8[$2_1 >> 0] | 0 | 0) - Math_fround(Math_abs($4_1))) - Math_fround(Math_abs($7_1)));
											$9_1 = $8_1 >= Math_fround(0.0);
											$10 = $9_1 ? Math_fround(0.0) : $8_1;
											$11 = Math_fround(-$10);
											$4_1 = Math_fround((($3_1 | 0) > (-1 | 0) ? $10 : $11) + $4_1);
											$10 = Math_fround((($6_1 | 0) > (-1 | 0) ? $10 : $11) + $7_1);
											$7_1 = Math_fround(Math_fround(127.0) / Math_fround(Math_sqrt(Math_fround(Math_fround($8_1 * $8_1) + Math_fround(Math_fround($4_1 * $4_1) + Math_fround($10 * $10))))));
											$8_1 = Math_fround(($9_1 ? Math_fround(.5) : Math_fround(-.5)) + Math_fround($8_1 * $7_1));
											if (!(Math_fround(Math_abs($8_1)) < Math_fround(2147483648.0))) {
												break label$5
											}
											$3_1 = ~~$8_1;
											break label$4;
										}
										$3_1 = -2147483648;
									}
									HEAP8[$2_1 >> 0] = $3_1;
									label$6: {
										label$7: {
											$8_1 = Math_fround(($10 >= Math_fround(0.0) ? Math_fround(.5) : Math_fround(-.5)) + Math_fround($10 * $7_1));
											if (!(Math_fround(Math_abs($8_1)) < Math_fround(2147483648.0))) {
												break label$7
											}
											$2_1 = ~~$8_1;
											break label$6;
										}
										$2_1 = -2147483648;
									}
									HEAP8[$5_1 >> 0] = $2_1;
									label$8: {
										label$9: {
											$8_1 = Math_fround(($4_1 >= Math_fround(0.0) ? Math_fround(.5) : Math_fround(-.5)) + Math_fround($4_1 * $7_1));
											if (!(Math_fround(Math_abs($8_1)) < Math_fround(2147483648.0))) {
												break label$9
											}
											$2_1 = ~~$8_1;
											break label$8;
										}
										$2_1 = -2147483648;
									}
									HEAP8[$0_1 >> 0] = $2_1;
									$0_1 = $0_1 + 4 | 0;
									$1_1 = $1_1 + -1 | 0;
									if ($1_1) {
										continue label$3
									}
									break label$1;
								};
							}
							if (!$1_1) {
								break label$1
							}
							label$10: while (1) {
								label$11: {
									label$12: {
										$2_1 = $0_1 + 4 | 0;
										$3_1 = HEAP16[$0_1 >> 1] | 0;
										$4_1 = Math_fround($3_1 | 0);
										$5_1 = $0_1 + 2 | 0;
										$6_1 = HEAP16[$5_1 >> 1] | 0;
										$7_1 = Math_fround($6_1 | 0);
										$8_1 = Math_fround(Math_fround(Math_fround(HEAP16[$2_1 >> 1] | 0 | 0) - Math_fround(Math_abs($4_1))) - Math_fround(Math_abs($7_1)));
										$9_1 = $8_1 >= Math_fround(0.0);
										$10 = $9_1 ? Math_fround(0.0) : $8_1;
										$11 = Math_fround(-$10);
										$4_1 = Math_fround((($3_1 | 0) > (-1 | 0) ? $10 : $11) + $4_1);
										$10 = Math_fround((($6_1 | 0) > (-1 | 0) ? $10 : $11) + $7_1);
										$7_1 = Math_fround(Math_fround(32767.0) / Math_fround(Math_sqrt(Math_fround(Math_fround($8_1 * $8_1) + Math_fround(Math_fround($4_1 * $4_1) + Math_fround($10 * $10))))));
										$8_1 = Math_fround(($9_1 ? Math_fround(.5) : Math_fround(-.5)) + Math_fround($8_1 * $7_1));
										if (!(Math_fround(Math_abs($8_1)) < Math_fround(2147483648.0))) {
											break label$12
										}
										$3_1 = ~~$8_1;
										break label$11;
									}
									$3_1 = -2147483648;
								}
								HEAP16[$2_1 >> 1] = $3_1;
								label$13: {
									label$14: {
										$8_1 = Math_fround(($10 >= Math_fround(0.0) ? Math_fround(.5) : Math_fround(-.5)) + Math_fround($10 * $7_1));
										if (!(Math_fround(Math_abs($8_1)) < Math_fround(2147483648.0))) {
											break label$14
										}
										$2_1 = ~~$8_1;
										break label$13;
									}
									$2_1 = -2147483648;
								}
								HEAP16[$5_1 >> 1] = $2_1;
								label$15: {
									label$16: {
										$8_1 = Math_fround(($4_1 >= Math_fround(0.0) ? Math_fround(.5) : Math_fround(-.5)) + Math_fround($4_1 * $7_1));
										if (!(Math_fround(Math_abs($8_1)) < Math_fround(2147483648.0))) {
											break label$16
										}
										$2_1 = ~~$8_1;
										break label$15;
									}
									$2_1 = -2147483648;
								}
								HEAP16[$0_1 >> 1] = $2_1;
								$0_1 = $0_1 + 8 | 0;
								$1_1 = $1_1 + -1 | 0;
								if ($1_1) {
									continue label$10
								}
								break label$10;
							};
						}
					}

					function $5($0_1, $1_1, $2_1) {
						$0_1 = $0_1 | 0;
						$1_1 = $1_1 | 0;
						$2_1 = $2_1 | 0;
						var $7_1 = Math_fround(0), $6_1 = Math_fround(0), $8_1 = Math_fround(0), $10 = 0, $3_1 = 0, $4_1 = 0, $5_1 = 0, $12 = Math_fround(0), $11 = 0, $9_1 = 0;
						label$1: {
							if (!$1_1) {
								break label$1
							}
							$3_1 = 0;
							$4_1 = $0_1;
							label$2: while (1) {
								label$3: {
									label$4: {
										$5_1 = HEAP16[($4_1 + 6 | 0) >> 1] | 0;
										$6_1 = Math_fround(Math_fround(.7071067690849304) / Math_fround($5_1 | 3 | 0 | 0));
										$7_1 = Math_fround($6_1 * Math_fround(HEAP16[$4_1 >> 1] | 0 | 0));
										$8_1 = Math_fround(Math_fround($7_1 * Math_fround(32767.0)) + ($7_1 >= Math_fround(0.0) ? Math_fround(.5) : Math_fround(-.5)));
										if (!(Math_fround(Math_abs($8_1)) < Math_fround(2147483648.0))) {
											break label$4
										}
										$9_1 = ~~$8_1;
										break label$3;
									}
									$9_1 = -2147483648;
								}
								$10 = HEAP16[($4_1 + 4 | 0) >> 1] | 0;
								$11 = HEAP16[($4_1 + 2 | 0) >> 1] | 0;
								HEAP16[($0_1 + ((($5_1 + 1 | 0) & 3 | 0 | $3_1 | 0) << 1 | 0) | 0) >> 1] = $9_1;
								label$5: {
									label$6: {
										$8_1 = Math_fround($6_1 * Math_fround($11 | 0));
										$12 = Math_fround(Math_fround($8_1 * Math_fround(32767.0)) + ($8_1 >= Math_fround(0.0) ? Math_fround(.5) : Math_fround(-.5)));
										if (!(Math_fround(Math_abs($12)) < Math_fround(2147483648.0))) {
											break label$6
										}
										$11 = ~~$12;
										break label$5;
									}
									$11 = -2147483648;
								}
								HEAP16[($0_1 + ((($5_1 + 2 | 0) & 3 | 0 | $3_1 | 0) << 1 | 0) | 0) >> 1] = $11;
								label$7: {
									label$8: {
										$6_1 = Math_fround($6_1 * Math_fround($10 | 0));
										$12 = Math_fround(Math_fround($6_1 * Math_fround(32767.0)) + ($6_1 >= Math_fround(0.0) ? Math_fround(.5) : Math_fround(-.5)));
										if (!(Math_fround(Math_abs($12)) < Math_fround(2147483648.0))) {
											break label$8
										}
										$10 = ~~$12;
										break label$7;
									}
									$10 = -2147483648;
								}
								HEAP16[($0_1 + ((($5_1 + -1 | 0) & 3 | 0 | $3_1 | 0) << 1 | 0) | 0) >> 1] = $10;
								label$9: {
									label$10: {
										$7_1 = Math_fround(Math_fround(Math_fround(Math_fround(1.0) - Math_fround($7_1 * $7_1)) - Math_fround($8_1 * $8_1)) - Math_fround($6_1 * $6_1));
										$7_1 = Math_fround(Math_fround(Math_fround(Math_sqrt($7_1 >= Math_fround(0.0) ? $7_1 : Math_fround(0.0))) * Math_fround(32767.0)) + Math_fround(.5));
										if (!(Math_fround(Math_abs($7_1)) < Math_fround(2147483648.0))) {
											break label$10
										}
										$10 = ~~$7_1;
										break label$9;
									}
									$10 = -2147483648;
								}
								HEAP16[($0_1 + (($5_1 & 3 | 0 | $3_1 | 0) << 1 | 0) | 0) >> 1] = $10;
								$4_1 = $4_1 + 8 | 0;
								$3_1 = $3_1 + 4 | 0;
								$1_1 = $1_1 + -1 | 0;
								if ($1_1) {
									continue label$2
								}
								break label$2;
							};
						}
					}

					function $6($0_1, $1_1, $2_1) {
						$0_1 = $0_1 | 0;
						$1_1 = $1_1 | 0;
						$2_1 = $2_1 | 0;
						label$1: {
							$1_1 = Math_imul($2_1 >>> 2 | 0, $1_1);
							if (!$1_1) {
								break label$1
							}
							label$2: while (1) {
								$2_1 = HEAP32[$0_1 >> 2] | 0;
								HEAPF32[$0_1 >> 2] = Math_fround(Math_fround(($2_1 << 8 | 0) >> 8 | 0 | 0) * (wasm2js_scratch_store_i32(2, (($2_1 >> 24 | 0) << 23 | 0) + 1065353216 | 0), wasm2js_scratch_load_f32()));
								$0_1 = $0_1 + 4 | 0;
								$1_1 = $1_1 + -1 | 0;
								if ($1_1) {
									continue label$2
								}
								break label$2;
							};
						}
					}

					function $7($0_1) {
						$0_1 = $0_1 | 0;
						var $1_1 = 0, $2_1 = 0, $3_1 = 0;
						$1_1 = HEAP32[(0 + 1024 | 0) >> 2] | 0;
						$0_1 = $1_1 + (($0_1 + 3 | 0) & -4 | 0) | 0;
						HEAP32[(0 + 1024 | 0) >> 2] = $0_1;
						label$1: {
							label$2: {
								$2_1 = __wasm_memory_size() << 16 | 0;
								if ($0_1 >>> 0 <= $2_1 >>> 0) {
									break label$2
								}
								$3_1 = -1;
								if ((__wasm_memory_grow((($0_1 - $2_1 | 0) + 65535 | 0) >>> 16 | 0 | 0) | 0) == (-1 | 0)) {
									break label$1
								}
							}
							$3_1 = $1_1;
						}
						return $3_1 | 0;
					}

					function $8($0_1, $1_1, $2_1) {
						$0_1 = $0_1 | 0;
						$1_1 = $1_1 | 0;
						$2_1 = $2_1 | 0;
						var $3_1 = 0;
						label$1: {
							label$2: {
								if (!(($1_1 | $0_1 | 0) & 3 | 0)) {
									break label$2
								}
								$3_1 = $0_1;
								break label$1;
							}
							label$3: {
								label$4: {
									if ($2_1 >>> 0 >= 16 >>> 0) {
										break label$4
									}
									$3_1 = $0_1;
									break label$3;
								}
								$3_1 = $0_1;
								label$5: while (1) {
									HEAP32[$3_1 >> 2] = HEAP32[$1_1 >> 2] | 0;
									HEAP32[($3_1 + 4 | 0) >> 2] = HEAP32[($1_1 + 4 | 0) >> 2] | 0;
									HEAP32[($3_1 + 8 | 0) >> 2] = HEAP32[($1_1 + 8 | 0) >> 2] | 0;
									HEAP32[($3_1 + 12 | 0) >> 2] = HEAP32[($1_1 + 12 | 0) >> 2] | 0;
									$3_1 = $3_1 + 16 | 0;
									$1_1 = $1_1 + 16 | 0;
									$2_1 = $2_1 + -16 | 0;
									if ($2_1 >>> 0 > 15 >>> 0) {
										continue label$5
									}
									break label$5;
								};
							}
							if ($2_1 >>> 0 < 4 >>> 0) {
								break label$1
							}
							label$6: while (1) {
								HEAP32[$3_1 >> 2] = HEAP32[$1_1 >> 2] | 0;
								$1_1 = $1_1 + 4 | 0;
								$3_1 = $3_1 + 4 | 0;
								$2_1 = $2_1 + -4 | 0;
								if ($2_1 >>> 0 > 3 >>> 0) {
									continue label$6
								}
								break label$6;
							};
						}
						label$7: {
							if (!$2_1) {
								break label$7
							}
							label$8: while (1) {
								HEAP8[$3_1 >> 0] = HEAPU8[$1_1 >> 0] | 0;
								$3_1 = $3_1 + 1 | 0;
								$1_1 = $1_1 + 1 | 0;
								$2_1 = $2_1 + -1 | 0;
								if ($2_1) {
									continue label$8
								}
								break label$8;
							};
						}
						return $0_1 | 0;
					}

					function $9($0_1, $1_1, $2_1) {
						$0_1 = $0_1 | 0;
						$1_1 = $1_1 | 0;
						$2_1 = $2_1 | 0;
						var $3_1 = 0, $4_1 = 0;
						label$1: {
							label$2: {
								if (!($0_1 & 3 | 0)) {
									break label$2
								}
								$3_1 = $0_1;
								break label$1;
							}
							$4_1 = Math_imul($1_1 & 255 | 0, 16843009);
							label$3: {
								label$4: {
									if ($2_1 >>> 0 >= 16 >>> 0) {
										break label$4
									}
									$3_1 = $0_1;
									break label$3;
								}
								$3_1 = $0_1;
								label$5: while (1) {
									HEAP32[$3_1 >> 2] = $4_1;
									HEAP32[($3_1 + 12 | 0) >> 2] = $4_1;
									HEAP32[($3_1 + 8 | 0) >> 2] = $4_1;
									HEAP32[($3_1 + 4 | 0) >> 2] = $4_1;
									$3_1 = $3_1 + 16 | 0;
									$2_1 = $2_1 + -16 | 0;
									if ($2_1 >>> 0 > 15 >>> 0) {
										continue label$5
									}
									break label$5;
								};
							}
							if ($2_1 >>> 0 < 4 >>> 0) {
								break label$1
							}
							label$6: while (1) {
								HEAP32[$3_1 >> 2] = $4_1;
								$3_1 = $3_1 + 4 | 0;
								$2_1 = $2_1 + -4 | 0;
								if ($2_1 >>> 0 > 3 >>> 0) {
									continue label$6
								}
								break label$6;
							};
						}
						label$7: {
							if (!$2_1) {
								break label$7
							}
							label$8: while (1) {
								HEAP8[$3_1 >> 0] = $1_1;
								$3_1 = $3_1 + 1 | 0;
								$2_1 = $2_1 + -1 | 0;
								if ($2_1) {
									continue label$8
								}
								break label$8;
							};
						}
						return $0_1 | 0;
					}

					bufferView = HEAPU8;
					initActiveSegments(env);
					function __wasm_memory_size() {
						return buffer.byteLength / 65536 | 0;
					}

					function __wasm_memory_grow(pagesToAdd) {
						pagesToAdd = pagesToAdd | 0;
						var oldPages = __wasm_memory_size() | 0;
						var newPages = oldPages + pagesToAdd | 0;
						if ((oldPages < newPages) && (newPages < 65536)) {
							var newBuffer = new ArrayBuffer(Math_imul(newPages, 65536));
							var newHEAP8 = new Int8Array(newBuffer);
							newHEAP8.set(HEAP8);
							HEAP8 = new Int8Array(newBuffer);
							HEAP16 = new Int16Array(newBuffer);
							HEAP32 = new Int32Array(newBuffer);
							HEAPU8 = new Uint8Array(newBuffer);
							HEAPU16 = new Uint16Array(newBuffer);
							HEAPU32 = new Uint32Array(newBuffer);
							HEAPF32 = new Float32Array(newBuffer);
							HEAPF64 = new Float64Array(newBuffer);
							buffer = newBuffer;
							bufferView = HEAPU8;
						}
						return oldPages;
					}

					return {
						"memory": Object.create(Object.prototype, {
							"grow": {
								"value": __wasm_memory_grow
							},
							"buffer": {
								"get": function () {
									return buffer;
								}

							}
						}),
						"__wasm_call_ctors": $0,
						"meshopt_decodeVertexBuffer": $1,
						"meshopt_decodeIndexBuffer": $2,
						"meshopt_decodeIndexSequence": $3,
						"meshopt_decodeFilterOct": $4,
						"meshopt_decodeFilterQuat": $5,
						"meshopt_decodeFilterExp": $6,
						"sbrk": $7
					};
				}

				var retasmFunc = asmFunc({
					abort: function () { throw new Error('abort'); }
				});
				var memory = retasmFunc.memory;
				var __wasm_call_ctors = retasmFunc.__wasm_call_ctors;
				var meshopt_decodeVertexBuffer = retasmFunc.meshopt_decodeVertexBuffer;
				var meshopt_decodeIndexBuffer = retasmFunc.meshopt_decodeIndexBuffer;
				var meshopt_decodeIndexSequence = retasmFunc.meshopt_decodeIndexSequence;
				var meshopt_decodeFilterOct = retasmFunc.meshopt_decodeFilterOct;
				var meshopt_decodeFilterQuat = retasmFunc.meshopt_decodeFilterQuat;
				var meshopt_decodeFilterExp = retasmFunc.meshopt_decodeFilterExp;
				var sbrk = retasmFunc.sbrk;


				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFBinaryExtension.js":
/*!********************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFBinaryExtension.js ***!
  \********************************************************/
/*! exports provided: GLTFBinaryExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFBinaryExtension", function () { return GLTFBinaryExtension; });
/* harmony import */ var _LoaderUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../LoaderUtils */ "./libs/three/loaders/LoaderUtils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");



				class GLTFBinaryExtension {

					constructor(data) {

						this.name = _utils__WEBPACK_IMPORTED_MODULE_1__["EXTENSIONS"].KHR_BINARY_GLTF;
						this.content = null;
						this.body = null;

						const headerView = new DataView(data, 0, _utils__WEBPACK_IMPORTED_MODULE_1__["BINARY_EXTENSION_HEADER_LENGTH"]);

						this.header = {
							magic: _LoaderUtils__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].decodeText(new Uint8Array(data.slice(0, 4))),
							version: headerView.getUint32(4, true),
							length: headerView.getUint32(8, true)
						};

						if (this.header.magic !== _utils__WEBPACK_IMPORTED_MODULE_1__["BINARY_EXTENSION_HEADER_MAGIC"]) {

							throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');

						} else if (this.header.version < 2.0) {

							throw new Error('THREE.GLTFLoader: Legacy binary file detected.');

						}

						const chunkContentsLength = this.header.length - _utils__WEBPACK_IMPORTED_MODULE_1__["BINARY_EXTENSION_HEADER_LENGTH"];
						const chunkView = new DataView(data, _utils__WEBPACK_IMPORTED_MODULE_1__["BINARY_EXTENSION_HEADER_LENGTH"]);
						let chunkIndex = 0;

						while (chunkIndex < chunkContentsLength) {

							const chunkLength = chunkView.getUint32(chunkIndex, true);
							chunkIndex += 4;

							const chunkType = chunkView.getUint32(chunkIndex, true);
							chunkIndex += 4;

							if (chunkType === _utils__WEBPACK_IMPORTED_MODULE_1__["BINARY_EXTENSION_CHUNK_TYPES"].JSON) {

								const contentArray = new Uint8Array(data, _utils__WEBPACK_IMPORTED_MODULE_1__["BINARY_EXTENSION_HEADER_LENGTH"] + chunkIndex, chunkLength);
								this.content = _LoaderUtils__WEBPACK_IMPORTED_MODULE_0__["LoaderUtils"].decodeText(contentArray);

							} else if (chunkType === _utils__WEBPACK_IMPORTED_MODULE_1__["BINARY_EXTENSION_CHUNK_TYPES"].BIN) {

								const byteOffset = _utils__WEBPACK_IMPORTED_MODULE_1__["BINARY_EXTENSION_HEADER_LENGTH"] + chunkIndex;
								this.body = data.slice(byteOffset, byteOffset + chunkLength);

							}

							// Clients must ignore chunks with unknown types.

							chunkIndex += chunkLength;
						}

						if (this.content === null) {
							throw new Error('THREE.GLTFLoader: JSON content not found.');
						}

					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFCubicSplineInterpolant.js":
/*!***************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFCubicSplineInterpolant.js ***!
  \***************************************************************/
/*! exports provided: GLTFCubicSplineInterpolant */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFCubicSplineInterpolant", function () { return GLTFCubicSplineInterpolant; });
/* harmony import */ var _math_Interpolant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Interpolant */ "./libs/three/math/Interpolant.js");


				// Spline Interpolation
				// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
				class GLTFCubicSplineInterpolant extends _math_Interpolant__WEBPACK_IMPORTED_MODULE_0__["Interpolant"] {

					// constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {

					// 	super(parameterPositions, sampleValues, sampleSize, resultBuffer);

					// }

					copySampleValue_(index) {

						// Copies a sample value to the result buffer. See description of glTF
						// CUBICSPLINE values layout in interpolate_() function below.

						const result = this.resultBuffer;
						const values = this.sampleValues;
						const { valueSize } = this;
						const offset = index * valueSize * 3 + valueSize;

						for (let i = 0; i !== valueSize; i++) {
							result[i] = values[offset + i];
						}

						return result;

					}

				}

				GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

				GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

				GLTFCubicSplineInterpolant.prototype.interpolate_ = (i1, t0, t, t1) => {

					const result = undefined.resultBuffer;
					const values = undefined.sampleValues;
					const stride = undefined.valueSize;

					const stride2 = stride * 2;
					const stride3 = stride * 3;

					const td = t1 - t0;

					const p = (t - t0) / td;
					const pp = p * p;
					const ppp = pp * p;

					const offset1 = i1 * stride3;
					const offset0 = offset1 - stride3;

					const s2 = - 2 * ppp + 3 * pp;
					const s3 = ppp - pp;
					const s0 = 1 - s2;
					const s1 = s3 - pp + p;

					// Layout of keyframe output values for CUBICSPLINE animations:
					//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
					for (let i = 0; i !== stride; i++) {

						const p0 = values[offset0 + i + stride]; // splineVertex_k
						const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)
						const p1 = values[offset1 + i + stride]; // splineVertex_k+1
						const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

						result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

					}

					return result;

				};

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFCubicSplineQuaternionInterpolant.js":
/*!*************************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFCubicSplineQuaternionInterpolant.js ***!
  \*************************************************************************/
/*! exports provided: GLTFCubicSplineQuaternionInterpolant */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFCubicSplineQuaternionInterpolant", function () { return GLTFCubicSplineQuaternionInterpolant; });
/* harmony import */ var _math_Quaternion__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Quaternion */ "./libs/three/math/Quaternion.js");
/* harmony import */ var _GLTFCubicSplineInterpolant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GLTFCubicSplineInterpolant */ "./libs/three/loaders/gltf/GLTFCubicSplineInterpolant.js");



				const _q = new _math_Quaternion__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

				class GLTFCubicSplineQuaternionInterpolant extends _GLTFCubicSplineInterpolant__WEBPACK_IMPORTED_MODULE_1__["GLTFCubicSplineInterpolant"] {
					interpolate_(i1, t0, t, t1) {
						const result = super.interpolate_(i1, t0, t, t1);
						_q.fromArray(result).normalize().toArray(result);
						return result;
					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFDracoMeshCompressionExtension.js":
/*!**********************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFDracoMeshCompressionExtension.js ***!
  \**********************************************************************/
/*! exports provided: GLTFDracoMeshCompressionExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFDracoMeshCompressionExtension", function () { return GLTFDracoMeshCompressionExtension; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");


				/**
				 * DRACO Mesh Compression Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
				 */
				class GLTFDracoMeshCompressionExtension {

					constructor(json, dracoLoader) {

						if (!dracoLoader) {
							throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
						}

						this.name = _utils__WEBPACK_IMPORTED_MODULE_0__["EXTENSIONS"].KHR_DRACO_MESH_COMPRESSION;
						this.json = json;
						this.dracoLoader = dracoLoader;
						this.dracoLoader.preload();

					}

					decodePrimitive(primitive, parser) {

						const { json, dracoLoader } = this;
						const bufferViewIndex = primitive.extensions[this.name].bufferView;
						const gltfAttributeMap = primitive.extensions[this.name].attributes;
						const threeAttributeMap = {};
						const attributeNormalizedMap = {};
						const attributeTypeMap = {};

						for (const attributeName in gltfAttributeMap) {

							const threeAttributeName = _utils__WEBPACK_IMPORTED_MODULE_0__["ATTRIBUTES"][attributeName] || attributeName.toLowerCase();

							threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];

						}

						for (const attributeName in primitive.attributes) {

							const threeAttributeName = _utils__WEBPACK_IMPORTED_MODULE_0__["ATTRIBUTES"][attributeName] || attributeName.toLowerCase();

							if (gltfAttributeMap[attributeName] !== undefined) {

								const accessorDef = json.accessors[primitive.attributes[attributeName]];
								const componentType = _utils__WEBPACK_IMPORTED_MODULE_0__["WEBGL_COMPONENT_TYPES"][accessorDef.componentType];

								attributeTypeMap[threeAttributeName] = componentType;
								attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;

							}

						}

						return parser.getDependency('bufferView', bufferViewIndex).then(bufferView => new Promise((resolve) => {
							dracoLoader.decodeDracoFile(bufferView, geometry => {
								for (const attributeName in geometry.attributes) {
									const attribute = geometry.attributes[attributeName];
									const normalized = attributeNormalizedMap[attributeName];
									if (normalized !== undefined) attribute.normalized = normalized;
								}
								resolve(geometry);
							}, threeAttributeMap, attributeTypeMap);
						})
						);
					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFLightsExtension.js":
/*!********************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFLightsExtension.js ***!
  \********************************************************/
/*! exports provided: GLTFLightsExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFLightsExtension", function () { return GLTFLightsExtension; });
/* harmony import */ var _lights_DirectionalLight__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lights/DirectionalLight */ "./libs/three/lights/DirectionalLight.js");
/* harmony import */ var _lights_PointLight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../lights/PointLight */ "./libs/three/lights/PointLight.js");
/* harmony import */ var _lights_SpotLight__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../lights/SpotLight */ "./libs/three/lights/SpotLight.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Color */ "./libs/three/math/Color.js");






				/**
				 * Punctual Lights Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
				 */
				class GLTFLightsExtension {

					constructor(parser) {

						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_LIGHTS_PUNCTUAL;

						// Object3D instance caches
						this.cache = { refs: {}, uses: {} };

					}

					_markDefs() {

						const { parser } = this;
						const nodeDefs = this.parser.json.nodes || [];

						for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {

							const nodeDef = nodeDefs[nodeIndex];

							if (nodeDef.extensions
								&& nodeDef.extensions[this.name]
								&& nodeDef.extensions[this.name].light !== undefined) {

								parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);

							}

						}

					}

					_loadLight(lightIndex) {

						const { parser } = this;
						const cacheKey = `light:${lightIndex}`;
						let dependency = parser.cache.get(cacheKey);

						if (dependency) return dependency;

						const { json } = parser;
						const extensions = (json.extensions && json.extensions[this.name]) || {};
						const lightDefs = extensions.lights || [];
						const lightDef = lightDefs[lightIndex];
						let lightNode;

						const color = new _math_Color__WEBPACK_IMPORTED_MODULE_4__["Color"](0xffffff);

						if (lightDef.color !== undefined) color.fromArray(lightDef.color);

						const range = lightDef.range !== undefined ? lightDef.range : 0;

						switch (lightDef.type) {

							case 'directional':
								lightNode = new _lights_DirectionalLight__WEBPACK_IMPORTED_MODULE_0__["DirectionalLight"](color);
								lightNode.target.position.set(0, 0, - 1);
								lightNode.add(lightNode.target);
								break;

							case 'point':
								lightNode = new _lights_PointLight__WEBPACK_IMPORTED_MODULE_1__["PointLight"](color);
								lightNode.distance = range;
								break;

							case 'spot':
								lightNode = new _lights_SpotLight__WEBPACK_IMPORTED_MODULE_2__["SpotLight"](color);
								lightNode.distance = range;
								// Handle spotlight properties.
								lightDef.spot = lightDef.spot || {};
								lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
								lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
								lightNode.angle = lightDef.spot.outerConeAngle;
								lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
								lightNode.target.position.set(0, 0, - 1);
								lightNode.add(lightNode.target);
								break;

							default:
								throw new Error(`THREE.GLTFLoader: Unexpected light type: ${lightDef.type}`);
						}

						// Some lights (e.g. spot) default to a position other than the origin. Reset the position
						// here, because node-level parsing will only override position if explicitly specified.
						lightNode.position.set(0, 0, 0);
						lightNode.decay = 2;

						if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;

						lightNode.name = parser.createUniqueName(lightDef.name || (`light_${lightIndex}`));

						dependency = Promise.resolve(lightNode);
						parser.cache.add(cacheKey, dependency);
						return dependency;
					}

					createNodeAttachment(nodeIndex) {

						const { parser } = this;
						const { json } = parser;
						const nodeDef = json.nodes[nodeIndex];
						const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {};
						const lightIndex = lightDef.light;

						if (lightIndex === undefined) return null;

						return this._loadLight(lightIndex).then(light => parser._getNodeRef(this.cache, lightIndex, light));
					}

				}


				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMaterialsClearcoatExtension.js":
/*!********************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMaterialsClearcoatExtension.js ***!
  \********************************************************************/
/*! exports provided: GLTFMaterialsClearcoatExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialsClearcoatExtension", function () { return GLTFMaterialsClearcoatExtension; });
/* harmony import */ var _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../materials/MeshPhysicalMaterial */ "./libs/three/materials/MeshPhysicalMaterial.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2 */ "./libs/three/math/Vector2.js");




				/**
				 * Clearcoat Materials Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
				 */
				class GLTFMaterialsClearcoatExtension {

					constructor(parser) {

						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_1__["EXTENSIONS"].KHR_MATERIALS_CLEARCOAT;

					}

					getMaterialType(materialIndex) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

						return _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_0__["MeshPhysicalMaterial"];

					}

					extendMaterialParams(materialIndex, materialParams) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) {
							return Promise.resolve();
						}

						const pending = [];

						const extension = materialDef.extensions[this.name];

						if (extension.clearcoatFactor !== undefined) {
							materialParams.clearcoat = extension.clearcoatFactor;
						}

						if (extension.clearcoatTexture !== undefined) {
							pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));
						}

						if (extension.clearcoatRoughnessFactor !== undefined) {
							materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
						}

						if (extension.clearcoatRoughnessTexture !== undefined) {
							pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));
						}

						if (extension.clearcoatNormalTexture !== undefined) {

							pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));

							if (extension.clearcoatNormalTexture.scale !== undefined) {

								const { scale } = extension.clearcoatNormalTexture;

								materialParams.clearcoatNormalScale = new _math_Vector2__WEBPACK_IMPORTED_MODULE_2__["Vector2"](scale, scale);

							}

						}

						return Promise.all(pending);

					}

				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMaterialsIorExtension.js":
/*!**************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMaterialsIorExtension.js ***!
  \**************************************************************/
/*! exports provided: GLTFMaterialsIorExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialsIorExtension", function () { return GLTFMaterialsIorExtension; });
/* harmony import */ var _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../materials/MeshPhysicalMaterial */ "./libs/three/materials/MeshPhysicalMaterial.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");



				/**
				 * Materials ior Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
				 */
				class GLTFMaterialsIorExtension {

					constructor(parser) {

						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_1__["EXTENSIONS"].KHR_MATERIALS_IOR;

					}

					getMaterialType(materialIndex) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

						return _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_0__["MeshPhysicalMaterial"];

					}

					extendMaterialParams(materialIndex, materialParams) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) {

							return Promise.resolve();

						}

						const extension = materialDef.extensions[this.name];

						materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

						return Promise.resolve();

					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMaterialsPbrSpecularGlossinessExtension.js":
/*!********************************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMaterialsPbrSpecularGlossinessExtension.js ***!
  \********************************************************************************/
/*! exports provided: GLTFMaterialsPbrSpecularGlossinessExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialsPbrSpecularGlossinessExtension", function () { return GLTFMaterialsPbrSpecularGlossinessExtension; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants */ "./libs/three/constants.js");
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Color */ "./libs/three/math/Color.js");
/* harmony import */ var _GLTFMeshStandardSGMaterial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GLTFMeshStandardSGMaterial */ "./libs/three/loaders/gltf/GLTFMeshStandardSGMaterial.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");





				class GLTFMaterialsPbrSpecularGlossinessExtension {

					constructor() {
						this.name = _utils__WEBPACK_IMPORTED_MODULE_3__["EXTENSIONS"].KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;
						this.specularGlossinessParams = [
							'color',
							'map',
							'lightMap',
							'lightMapIntensity',
							'aoMap',
							'aoMapIntensity',
							'emissive',
							'emissiveIntensity',
							'emissiveMap',
							'bumpMap',
							'bumpScale',
							'normalMap',
							'normalMapType',
							'displacementMap',
							'displacementScale',
							'displacementBias',
							'specularMap',
							'specular',
							'glossinessMap',
							'glossiness',
							'alphaMap',
							'envMap',
							'envMapIntensity',
							'refractionRatio'
						];
					}

					getMaterialType() {
						return _GLTFMeshStandardSGMaterial__WEBPACK_IMPORTED_MODULE_2__["GLTFMeshStandardSGMaterial"];
					}

					extendParams(materialParams, materialDef, parser) {

						const pbrSpecularGlossiness = materialDef.extensions[this.name];

						materialParams.color = new _math_Color__WEBPACK_IMPORTED_MODULE_1__["Color"](1.0, 1.0, 1.0);
						materialParams.opacity = 1.0;

						const pending = [];

						if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
							const array = pbrSpecularGlossiness.diffuseFactor;

							materialParams.color.fromArray(array);
							materialParams.opacity = array[3];
						}

						if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
							pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
						}

						materialParams.emissive = new _math_Color__WEBPACK_IMPORTED_MODULE_1__["Color"](0.0, 0.0, 0.0);
						materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
						materialParams.specular = new _math_Color__WEBPACK_IMPORTED_MODULE_1__["Color"](1.0, 1.0, 1.0);

						if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
							materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
						}

						if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
							const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
							pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
							pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
						}

						return Promise.all(pending);
					}

					createMaterial(materialParams) {

						const material = new _GLTFMeshStandardSGMaterial__WEBPACK_IMPORTED_MODULE_2__["GLTFMeshStandardSGMaterial"](materialParams);
						material.fog = true;

						material.color = materialParams.color;

						material.map = materialParams.map === undefined ? null : materialParams.map;

						material.lightMap = null;
						material.lightMapIntensity = 1.0;

						material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
						material.aoMapIntensity = 1.0;

						material.emissive = materialParams.emissive;
						material.emissiveIntensity = 1.0;
						material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

						material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
						material.bumpScale = 1;

						material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
						material.normalMapType = _constants__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"];

						if (materialParams.normalScale) material.normalScale = materialParams.normalScale;

						material.displacementMap = null;
						material.displacementScale = 1;
						material.displacementBias = 0;

						material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
						material.specular = materialParams.specular;

						material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
						material.glossiness = materialParams.glossiness;

						material.alphaMap = null;

						material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
						material.envMapIntensity = 1.0;

						material.refractionRatio = 0.98;

						return material;
					}
				}


				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMaterialsSheenExtension.js":
/*!****************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMaterialsSheenExtension.js ***!
  \****************************************************************/
/*! exports provided: GLTFMaterialsSheenExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialsSheenExtension", function () { return GLTFMaterialsSheenExtension; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Color */ "./libs/three/math/Color.js");
/* harmony import */ var _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../materials/MeshPhysicalMaterial */ "./libs/three/materials/MeshPhysicalMaterial.js");




				/**
				 * Sheen Materials Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
				 */
				class GLTFMaterialsSheenExtension {

					constructor(parser) {

						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_0__["EXTENSIONS"].KHR_MATERIALS_SHEEN;

					}

					getMaterialType(materialIndex) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

						return _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_2__["MeshPhysicalMaterial"];

					}

					extendMaterialParams(materialIndex, materialParams) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) {

							return Promise.resolve();

						}

						const pending = [];

						materialParams.sheenColor = new _math_Color__WEBPACK_IMPORTED_MODULE_1__["Color"](0, 0, 0);
						materialParams.sheenRoughness = 0;
						materialParams.sheen = 1;

						const extension = materialDef.extensions[this.name];

						if (extension.sheenColorFactor !== undefined) {

							materialParams.sheenColor.fromArray(extension.sheenColorFactor);

						}

						if (extension.sheenRoughnessFactor !== undefined) {

							materialParams.sheenRoughness = extension.sheenRoughnessFactor;

						}

						if (extension.sheenColorTexture !== undefined) {

							pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture));

						}

						if (extension.sheenRoughnessTexture !== undefined) {

							pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture));

						}

						return Promise.all(pending);

					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMaterialsSpecularExtension.js":
/*!*******************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMaterialsSpecularExtension.js ***!
  \*******************************************************************/
/*! exports provided: GLTFMaterialsSpecularExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialsSpecularExtension", function () { return GLTFMaterialsSpecularExtension; });
/* harmony import */ var _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../materials/MeshPhysicalMaterial */ "./libs/three/materials/MeshPhysicalMaterial.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Color */ "./libs/three/math/Color.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants */ "./libs/three/constants.js");





				/**
				 * Materials specular Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
				 */
				class GLTFMaterialsSpecularExtension {

					constructor(parser) {
						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_1__["EXTENSIONS"].KHR_MATERIALS_SPECULAR;
					}

					getMaterialType(materialIndex) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

						return _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_0__["MeshPhysicalMaterial"];

					}

					extendMaterialParams(materialIndex, materialParams) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) {

							return Promise.resolve();

						}

						const pending = [];

						const extension = materialDef.extensions[this.name];

						materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

						if (extension.specularTexture !== undefined) {

							pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture));

						}

						const colorArray = extension.specularColorFactor || [1, 1, 1];
						materialParams.specularColor = new _math_Color__WEBPACK_IMPORTED_MODULE_2__["Color"](colorArray[0], colorArray[1], colorArray[2]);

						if (extension.specularColorTexture !== undefined) {

							pending.push(parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture).then(texture => {
								texture.encoding = _constants__WEBPACK_IMPORTED_MODULE_3__["sRGBEncoding"];
							}));
						}

						return Promise.all(pending);

					}
				}


				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMaterialsTransmissionExtension.js":
/*!***********************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMaterialsTransmissionExtension.js ***!
  \***********************************************************************/
/*! exports provided: GLTFMaterialsTransmissionExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialsTransmissionExtension", function () { return GLTFMaterialsTransmissionExtension; });
/* harmony import */ var _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../materials/MeshPhysicalMaterial */ "./libs/three/materials/MeshPhysicalMaterial.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");



				/**
				 * Transmission Materials Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
				 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
				 */
				class GLTFMaterialsTransmissionExtension {

					constructor(parser) {
						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_1__["EXTENSIONS"].KHR_MATERIALS_TRANSMISSION;
					}

					getMaterialType(materialIndex) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

						return _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_0__["MeshPhysicalMaterial"];

					}

					extendMaterialParams(materialIndex, materialParams) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) {

							return Promise.resolve();

						}

						const pending = [];

						const extension = materialDef.extensions[this.name];

						if (extension.transmissionFactor !== undefined) {

							materialParams.transmission = extension.transmissionFactor;

						}

						if (extension.transmissionTexture !== undefined) {

							pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));

						}

						return Promise.all(pending);

					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMaterialsUnlitExtension.js":
/*!****************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMaterialsUnlitExtension.js ***!
  \****************************************************************/
/*! exports provided: GLTFMaterialsUnlitExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialsUnlitExtension", function () { return GLTFMaterialsUnlitExtension; });
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Color */ "./libs/three/math/Color.js");
/* harmony import */ var _materials_MeshBasicMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../materials/MeshBasicMaterial */ "./libs/three/materials/MeshBasicMaterial.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");




				/**
				 * Unlit Materials Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
				 */
				class GLTFMaterialsUnlitExtension {

					constructor() {
						this.name = _utils__WEBPACK_IMPORTED_MODULE_2__["EXTENSIONS"].KHR_MATERIALS_UNLIT;
					}

					getMaterialType() {
						return _materials_MeshBasicMaterial__WEBPACK_IMPORTED_MODULE_1__["MeshBasicMaterial"];
					}

					extendParams(materialParams, materialDef, parser) {

						const pending = [];

						materialParams.color = new _math_Color__WEBPACK_IMPORTED_MODULE_0__["Color"](1.0, 1.0, 1.0);
						materialParams.opacity = 1.0;

						const metallicRoughness = materialDef.pbrMetallicRoughness;

						if (metallicRoughness) {

							if (Array.isArray(metallicRoughness.baseColorFactor)) {

								const array = metallicRoughness.baseColorFactor;

								materialParams.color.fromArray(array);
								materialParams.opacity = array[3];

							}

							if (metallicRoughness.baseColorTexture !== undefined) {
								pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
							}
						}

						return Promise.all(pending);

					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMaterialsVolumeExtension.js":
/*!*****************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMaterialsVolumeExtension.js ***!
  \*****************************************************************/
/*! exports provided: GLTFMaterialsVolumeExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMaterialsVolumeExtension", function () { return GLTFMaterialsVolumeExtension; });
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Color */ "./libs/three/math/Color.js");
/* harmony import */ var _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../materials/MeshPhysicalMaterial */ "./libs/three/materials/MeshPhysicalMaterial.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");




				/**
				 * Materials Volume Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
				 */
				class GLTFMaterialsVolumeExtension {

					constructor(parser) {

						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_2__["EXTENSIONS"].KHR_MATERIALS_VOLUME;

					}

					getMaterialType(materialIndex) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;

						return _materials_MeshPhysicalMaterial__WEBPACK_IMPORTED_MODULE_1__["MeshPhysicalMaterial"];

					}

					extendMaterialParams(materialIndex, materialParams) {

						const { parser } = this;
						const materialDef = parser.json.materials[materialIndex];

						if (!materialDef.extensions || !materialDef.extensions[this.name]) {

							return Promise.resolve();

						}

						const pending = [];

						const extension = materialDef.extensions[this.name];

						materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

						if (extension.thicknessTexture !== undefined) {
							pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture));
						}

						materialParams.attenuationDistance = extension.attenuationDistance || 0;

						const colorArray = extension.attenuationColor || [1, 1, 1];
						materialParams.attenuationColor = new _math_Color__WEBPACK_IMPORTED_MODULE_0__["Color"](colorArray[0], colorArray[1], colorArray[2]);

						return Promise.all(pending);
					}

				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMeshQuantizationExtension.js":
/*!******************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMeshQuantizationExtension.js ***!
  \******************************************************************/
/*! exports provided: GLTFMeshQuantizationExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMeshQuantizationExtension", function () { return GLTFMeshQuantizationExtension; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");


				/**
				 * Mesh Quantization Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
				 */
				class GLTFMeshQuantizationExtension {
					constructor() {
						this.name = _utils__WEBPACK_IMPORTED_MODULE_0__["EXTENSIONS"].KHR_MESH_QUANTIZATION;
					}
				}


				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMeshStandardSGMaterial.js":
/*!***************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMeshStandardSGMaterial.js ***!
  \***************************************************************/
/*! exports provided: GLTFMeshStandardSGMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMeshStandardSGMaterial", function () { return GLTFMeshStandardSGMaterial; });
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Color */ "./libs/three/math/Color.js");
/* harmony import */ var _materials_MeshStandardMaterial__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../materials/MeshStandardMaterial */ "./libs/three/materials/MeshStandardMaterial.js");

				/**
				 * Specular-Glossiness Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
				 */




				/**
				 * A sub class of StandardMaterial with some of the functionality
				 * changed via the `onBeforeCompile` callback
				 * @pailhead
				 */
				class GLTFMeshStandardSGMaterial extends _materials_MeshStandardMaterial__WEBPACK_IMPORTED_MODULE_1__["MeshStandardMaterial"] {

					constructor(params) {
						super();
						this.isGLTFSpecularGlossinessMaterial = true;
						// various chunks that need replacing
						const specularMapParsFragmentChunk = [
							'#ifdef USE_SPECULARMAP',
							'	uniform sampler2D specularMap;',
							'#endif'
						].join('\n');

						const glossinessMapParsFragmentChunk = [
							'#ifdef USE_GLOSSINESSMAP',
							'	uniform sampler2D glossinessMap;',
							'#endif'
						].join('\n');

						const specularMapFragmentChunk = [
							'vec3 specularFactor = specular;',
							'#ifdef USE_SPECULARMAP',
							'	vec4 texelSpecular = texture2D( specularMap, vUv );',
							'	texelSpecular = sRGBToLinear( texelSpecular );',
							'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
							'	specularFactor *= texelSpecular.rgb;',
							'#endif'
						].join('\n');

						const glossinessMapFragmentChunk = [
							'float glossinessFactor = glossiness;',
							'#ifdef USE_GLOSSINESSMAP',
							'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
							'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
							'	glossinessFactor *= texelGlossiness.a;',
							'#endif'
						].join('\n');

						const lightPhysicalFragmentChunk = [
							'PhysicalMaterial material;',
							'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
							'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
							'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
							'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
							'material.roughness += geometryRoughness;',
							'material.roughness = min( material.roughness, 1.0 );',
							'material.specularColor = specularFactor;'
						].join('\n');

						const uniforms = {
							specular: { value: new _math_Color__WEBPACK_IMPORTED_MODULE_0__["Color"]().setHex(0xffffff) },
							glossiness: { value: 1 },
							specularMap: { value: null },
							glossinessMap: { value: null }
						};

						this._extraUniforms = uniforms;

						this.onBeforeCompile = shader => {

							for (const uniformName in uniforms) {
								shader.uniforms[uniformName] = uniforms[uniformName];
							}

							shader.fragmentShader = shader.fragmentShader
								.replace('uniform float roughness;', 'uniform vec3 specular;')
								.replace('uniform float metalness;', 'uniform float glossiness;')
								.replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk)
								.replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk)
								.replace('#include <roughnessmap_fragment>', specularMapFragmentChunk)
								.replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk)
								.replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
						};

						Object.defineProperties(this, {

							specular: {
								get: () => uniforms.specular.value,
								set: v => {
									uniforms.specular.value = v;
								}
							},

							specularMap: {
								get: () => uniforms.specularMap.value,
								set: v => {
									uniforms.specularMap.value = v;
									if (v) {
										this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps
									} else {
										delete this.defines.USE_SPECULARMAP;
									}
								}
							},

							glossiness: {
								get: () => uniforms.glossiness.value,
								set: v => {
									uniforms.glossiness.value = v;
								}
							},

							glossinessMap: {
								get: () => uniforms.glossinessMap.value,
								set: v => {
									uniforms.glossinessMap.value = v;
									if (v) {
										this.defines.USE_GLOSSINESSMAP = '';
										this.defines.USE_UV = '';
									} else {
										delete this.defines.USE_GLOSSINESSMAP;
										delete this.defines.USE_UV;
									}
								}
							}
						});

						delete this.metalness;
						delete this.roughness;
						delete this.metalnessMap;
						delete this.roughnessMap;

						this.setValues(params);
					}

					copy(source) {
						super.copy(source);

						this.specularMap = source.specularMap;
						this.specular.copy(source.specular);
						this.glossinessMap = source.glossinessMap;
						this.glossiness = source.glossiness;
						delete this.metalness;
						delete this.roughness;
						delete this.metalnessMap;
						delete this.roughnessMap;
						return this;
					}

				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFMeshoptCompression.js":
/*!***********************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFMeshoptCompression.js ***!
  \***********************************************************/
/*! exports provided: GLTFMeshoptCompression */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFMeshoptCompression", function () { return GLTFMeshoptCompression; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");


				/**
				 * meshopt BufferView Compression Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
				 */
				class GLTFMeshoptCompression {
					constructor(parser) {
						this.name = _utils__WEBPACK_IMPORTED_MODULE_0__["EXTENSIONS"].EXT_MESHOPT_COMPRESSION;
						this.parser = parser;
					}

					loadBufferView(index) {

						const { json } = this.parser;
						const bufferView = json.bufferViews[index];

						if (bufferView.extensions && bufferView.extensions[this.name]) {

							const extensionDef = bufferView.extensions[this.name];

							const buffer = this.parser.getDependency('buffer', extensionDef.buffer);
							const decoder = this.parser.options.meshoptDecoder;

							if (!decoder || !decoder.supported) {

								if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {

									throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files');

								} else {

									// Assumes that the extension is optional and that fallback buffer data is present
									return null;

								}

							}

							return Promise.all([buffer, decoder.ready]).then(res => {

								const byteOffset = extensionDef.byteOffset || 0;
								const byteLength = extensionDef.byteLength || 0;

								const { count } = extensionDef;
								const stride = extensionDef.byteStride;

								const result = new ArrayBuffer(count * stride);
								const source = new Uint8Array(res[0], byteOffset, byteLength);

								decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
								return result;

							});

						}
						return null;
					}
				}


				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFParser.js":
/*!***********************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFParser.js ***!
  \***********************************************/
/*! exports provided: GLTFParser */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFParser", function () { return GLTFParser; });
/* harmony import */ var _animation_AnimationClip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../animation/AnimationClip */ "./libs/three/animation/AnimationClip.js");
/* harmony import */ var _objects_Bone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../objects/Bone */ "./libs/three/objects/Bone.js");
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Color */ "./libs/three/math/Color.js");
/* harmony import */ var _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../core/BufferAttribute */ "./libs/three/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/BufferGeometry */ "./libs/three/core/BufferGeometry.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../constants */ "./libs/three/constants.js");
/* harmony import */ var _objects_Group__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../objects/Group */ "./libs/three/objects/Group.js");
/* harmony import */ var _ImageBitmapLoader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ImageBitmapLoader */ "./libs/three/loaders/ImageBitmapLoader.js");
/* harmony import */ var _core_InterleavedBuffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../core/InterleavedBuffer */ "./libs/three/core/InterleavedBuffer.js");
/* harmony import */ var _core_InterleavedBufferAttribute__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../core/InterleavedBufferAttribute */ "./libs/three/core/InterleavedBufferAttribute.js");
/* harmony import */ var _objects_Line__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../objects/Line */ "./libs/three/objects/Line.js");
/* harmony import */ var _materials_LineBasicMaterial__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../materials/LineBasicMaterial */ "./libs/three/materials/LineBasicMaterial.js");
/* harmony import */ var _objects_LineLoop__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../../objects/LineLoop */ "./libs/three/objects/LineLoop.js");
/* harmony import */ var _objects_LineSegments__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../objects/LineSegments */ "./libs/three/objects/LineSegments.js");
/* harmony import */ var _materials_Material__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../materials/Material */ "./libs/three/materials/Material.js");
/* harmony import */ var _objects_Mesh__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../../objects/Mesh */ "./libs/three/objects/Mesh.js");
/* harmony import */ var _animation_tracks_NumberKeyframeTrack__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../../animation/tracks/NumberKeyframeTrack */ "./libs/three/animation/tracks/NumberKeyframeTrack.js");
/* harmony import */ var _core_Object3D__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../../core/Object3D */ "./libs/three/core/Object3D.js");
/* harmony import */ var _cameras_OrthographicCamera__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../../cameras/OrthographicCamera */ "./libs/three/cameras/OrthographicCamera.js");
/* harmony import */ var _cameras_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../../cameras/PerspectiveCamera */ "./libs/three/cameras/PerspectiveCamera.js");
/* harmony import */ var _objects_Points__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../../objects/Points */ "./libs/three/objects/Points.js");
/* harmony import */ var _materials_PointsMaterial__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../../materials/PointsMaterial */ "./libs/three/materials/PointsMaterial.js");
/* harmony import */ var _animation_PropertyBinding__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../../animation/PropertyBinding */ "./libs/three/animation/PropertyBinding.js");
/* harmony import */ var _animation_tracks_QuaternionKeyframeTrack__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../../animation/tracks/QuaternionKeyframeTrack */ "./libs/three/animation/tracks/QuaternionKeyframeTrack.js");
/* harmony import */ var _objects_SkinnedMesh__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../../objects/SkinnedMesh */ "./libs/three/objects/SkinnedMesh.js");
/* harmony import */ var _textures_Texture__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ../../textures/Texture */ "./libs/three/textures/Texture.js");
/* harmony import */ var _TextureLoader__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ../TextureLoader */ "./libs/three/loaders/TextureLoader.js");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ../../math/Vector2 */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_MathUtils__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ../../math/MathUtils */ "./libs/three/math/MathUtils.js");
/* harmony import */ var _animation_tracks_VectorKeyframeTrack__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ../../animation/tracks/VectorKeyframeTrack */ "./libs/three/animation/tracks/VectorKeyframeTrack.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");
/* harmony import */ var _FileLoader__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ../FileLoader */ "./libs/three/loaders/FileLoader.js");
/* harmony import */ var _LoaderUtils__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ../LoaderUtils */ "./libs/three/loaders/LoaderUtils.js");
/* harmony import */ var _materials_MeshStandardMaterial__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../../materials/MeshStandardMaterial */ "./libs/three/materials/MeshStandardMaterial.js");
/* harmony import */ var _materials_MeshBasicMaterial__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../../materials/MeshBasicMaterial */ "./libs/three/materials/MeshBasicMaterial.js");
/* harmony import */ var _GLTFMeshStandardSGMaterial__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./GLTFMeshStandardSGMaterial */ "./libs/three/loaders/gltf/GLTFMeshStandardSGMaterial.js");
/* harmony import */ var _math_Matrix4__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ../../math/Matrix4 */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _GLTFCubicSplineInterpolant__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./GLTFCubicSplineInterpolant */ "./libs/three/loaders/gltf/GLTFCubicSplineInterpolant.js");
/* harmony import */ var _GLTFCubicSplineQuaternionInterpolant__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./GLTFCubicSplineQuaternionInterpolant */ "./libs/three/loaders/gltf/GLTFCubicSplineQuaternionInterpolant.js");










































				class GLTFParser {
					constructor(json = {}, options = {}) {
						this.json = json;
						this.extensions = {};
						this.plugins = {};
						this.options = options;

						// loader object cache
						this.cache = new _utils__WEBPACK_IMPORTED_MODULE_30__["GLTFRegistry"]();

						// associations between Three.js objects and glTF elements
						this.associations = new Map();

						// BufferGeometry caching
						this.primitiveCache = {};

						// Object3D instance caches
						this.meshCache = { refs: {}, uses: {} };
						this.cameraCache = { refs: {}, uses: {} };
						this.lightCache = { refs: {}, uses: {} };

						this.textureCache = {};

						// Track node names, to ensure no duplicates
						this.nodeNamesUsed = {};

						// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
						// expensive work of uploading a texture to the GPU off the main thread.
						// 淘宝不支持  都别用这种好了
						// if (
						//   typeof createImageBitmap !== 'undefined' &&
						//   /Firefox/.test(navigator.userAgent) === false
						// ) {
						//   this.textureLoader = new ImageBitmapLoader(this.options.manager);
						// } else {
						this.textureLoader = new _TextureLoader__WEBPACK_IMPORTED_MODULE_26__["TextureLoader"](this.options.manager);
						// }

						this.textureLoader.setRequestHeader(this.options.requestHeader);

						this.fileLoader = new _FileLoader__WEBPACK_IMPORTED_MODULE_31__["FileLoader"](this.options.manager);
						this.fileLoader.setResponseType('arraybuffer');
					}

					setExtensions(extensions) {
						this.extensions = extensions;
					}

					setPlugins(plugins) {
						this.plugins = plugins;
					}

					parse(onLoad, onError) {
						const parser = this;
						const { json } = this;
						const { extensions } = this;

						// Clear the loader cache
						this.cache.removeAll();

						// Mark the special nodes/meshes in json for efficient parse
						this._invokeAll(ext => ext._markDefs && ext._markDefs());
						Promise.all(this._invokeAll(ext => ext.beforeRoot && ext.beforeRoot()))
							.then(async () => {
								// 正常为并行解析，大部件改为串行
								// console.log("编译环境", this.options.complieEnv)
								// if (this.options.complieEnv == "bigCard") {
								//   let scene = await parser.getDependencies('scene')
								//   let animation = await parser.getDependencies('animation')
								//   let camera = await parser.getDependencies('camera')
								//   return [scene, animation, camera]
								// } else {
								return Promise.all([
									parser.getDependencies('scene'),
									parser.getDependencies('animation'),
									parser.getDependencies('camera')
								])
								// }
							})
							.then(dependencies => {
								const result = {
									scene: dependencies[0][json.scene || 0],
									scenes: dependencies[0],
									animations: dependencies[1],
									cameras: dependencies[2],
									asset: json.asset,
									parser,
									userData: {}
								};
								Object(_utils__WEBPACK_IMPORTED_MODULE_30__["addUnknownExtensionsToUserData"])(extensions, result, json);

								Object(_utils__WEBPACK_IMPORTED_MODULE_30__["assignExtrasToUserData"])(result, json);

								Promise.all(
									parser._invokeAll(ext => ext.afterRoot && ext.afterRoot(result))
								).then(() => {

									onLoad(result);
								});
							})
							.catch(onError);
					}

					/**
					 * Marks the special nodes/meshes in json for efficient parse.
					 */
					_markDefs() {
						const nodeDefs = this.json.nodes || [];
						const skinDefs = this.json.skins || [];
						const meshDefs = this.json.meshes || [];

						// Nothing in the node definition indicates whether it is a Bone or an
						// Object3D. Use the skins' joint references to mark bones.
						for (
							let skinIndex = 0, skinLength = skinDefs.length;
							skinIndex < skinLength;
							skinIndex++
						) {
							const { joints } = skinDefs[skinIndex];

							for (let i = 0, il = joints.length; i < il; i++) {
								nodeDefs[joints[i]].isBone = true;
							}
						}

						// Iterate over all nodes, marking references to shared resources,
						// as well as skeleton joints.
						for (
							let nodeIndex = 0, nodeLength = nodeDefs.length;
							nodeIndex < nodeLength;
							nodeIndex++
						) {
							const nodeDef = nodeDefs[nodeIndex];

							if (nodeDef.mesh !== undefined) {
								this._addNodeRef(this.meshCache, nodeDef.mesh);

								// Nothing in the mesh definition indicates whether it is
								// a SkinnedMesh or Mesh. Use the node's mesh reference
								// to mark SkinnedMesh if node has skin.
								if (nodeDef.skin !== undefined) {
									meshDefs[nodeDef.mesh].isSkinnedMesh = true;
								}
							}

							if (nodeDef.camera !== undefined) {
								this._addNodeRef(this.cameraCache, nodeDef.camera);
							}
						}
					}

					/**
					 * Counts references to shared node / Object3D resources. These resources
					 * can be reused, or "instantiated", at multiple nodes in the scene
					 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
					 * be marked. Non-scenegraph resources (like Materials, Geometries, and
					 * Textures) can be reused directly and are not marked here.
					 *
					 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
					 */
					_addNodeRef(cache, index) {
						if (index === undefined) return;

						if (cache.refs[index] === undefined) {
							cache.refs[index] = 0;
							cache.uses[index] = 0;
						}
						cache.refs[index]++;
					}

					/** Returns a reference to a shared resource, cloning it if necessary. */
					_getNodeRef(cache, index, object) {
						if (cache.refs[index] <= 1) return object;

						const ref = object.clone();

						// Propagates mappings to the cloned object, prevents mappings on the
						// original object from being lost.
						const updateMappings = (original, clone) => {
							const mappings = this.associations.get(original);
							if (mappings != null) {
								this.associations.set(clone, mappings);
							}

							for (const [i, child] of original.children.entries()) {
								updateMappings(child, clone.children[i]);
							}
						};

						updateMappings(object, ref);

						ref.name += `_instance_${cache.uses[index]++}`;

						return ref;
					}

					_invokeOne(func) {
						const extensions = Object.values(this.plugins);
						extensions.push(this);

						for (let i = 0; i < extensions.length; i++) {
							const result = func(extensions[i]);
							if (result) return result;
						}

						return null;
					}

					_invokeAll(func) {
						const extensions = Object.values(this.plugins);
						extensions.unshift(this);

						const pending = [];

						for (let i = 0; i < extensions.length; i++) {
							const result = func(extensions[i]);
							if (result) pending.push(result);
						}

						return pending;
					}

					/**
					 * Requests the specified dependency asynchronously, with caching.
					 * @param {string} type
					 * @param {number} index
					 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
					 */
					async getDependency(type, index) {
						const cacheKey = `${type}:${index}`;
						let dependency = this.cache.get(cacheKey);

						if (!dependency) {
							switch (type) {
								case 'scene':
									dependency = this.loadScene(index);
									break;
								case 'node':
									dependency = this.loadNode(index);
									break;
								case 'mesh':
									dependency = this._invokeOne(
										ext => ext.loadMesh && ext.loadMesh(index)
									);
									break;
								case 'accessor':
									dependency = this.loadAccessor(index);
									break;
								case 'bufferView':
									dependency = this._invokeOne(
										ext => ext.loadBufferView && ext.loadBufferView(index)
									);
									break;
								case 'buffer':
									dependency = this.loadBuffer(index);
									break;
								case 'material':
									dependency = this._invokeOne(
										ext => ext.loadMaterial && ext.loadMaterial(index)
									);
									break;
								case 'texture':
									dependency = this._invokeOne(
										ext => ext.loadTexture && ext.loadTexture(index)
									);
									break;
								case 'skin':
									dependency = this.loadSkin(index);
									break;
								case 'animation':
									dependency = this.loadAnimation(index);
									break;
								case 'camera':
									dependency = this.loadCamera(index);
									break;
								default:
									throw new Error(`Unknown type: ${type}`);
							}

							this.cache.add(cacheKey, dependency);
						}

						return dependency;
					}

					/**
					 * Requests all dependencies of the specified type asynchronously, with caching.
					 * @param {string} type
					 * @return {Promise<Array<Object>>}
					 */
					getDependencies(type) {
						// if( type == "scene" ){
						// console.log(dependencies,this.cache,this.cache.get(type));
						// }
						let dependencies = this.cache.get(type) || null;

						if (!dependencies) {
							const parser = this;
							const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
							// console.log(defs,this.json['meshes'])
							dependencies = Promise.all(
								defs.map((def, index) => parser.getDependency(type, index))
							);
							this.cache.add(type, dependencies);
						}

						return dependencies;
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
					 * @param {number} bufferIndex
					 * @return {Promise<ArrayBuffer>}
					 */
					loadBuffer(bufferIndex) {
						const bufferDef = this.json.buffers[bufferIndex];
						const loader = this.fileLoader;

						if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
							throw new Error(
								`THREE.GLTFLoader: ${bufferDef.type} buffer type is not supported.`
							);
						}

						// If present, GLB container is required to be the first buffer.
						if (bufferDef.uri === undefined && bufferIndex === 0) {
							return Promise.resolve(this.extensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_BINARY_GLTF].body);
						}

						const { options } = this;
						return new Promise((resolve, reject) => {
							loader.load(
								_LoaderUtils__WEBPACK_IMPORTED_MODULE_32__["LoaderUtils"].resolveURL(bufferDef.uri + "?_t=" + Date.now(), options.path),
								resolve,
								undefined,
								() => {
									reject(
										new Error(
											`THREE.GLTFLoader: Failed to load buffer ${bufferDef.uri}.`
										)
									);
								}
							);
						});
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
					 * @param {number} bufferViewIndex
					 * @return {Promise<ArrayBuffer>}
					 */
					loadBufferView(bufferViewIndex) {
						const bufferViewDef = this.json.bufferViews[bufferViewIndex];

						return this.getDependency('buffer', bufferViewDef.buffer).then(buffer => {
							const byteLength = bufferViewDef.byteLength || 0;
							const byteOffset = bufferViewDef.byteOffset || 0;
							return buffer.slice(byteOffset, byteOffset + byteLength);
						});
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
					 * @param {number} accessorIndex
					 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
					 */
					loadAccessor(accessorIndex) {
						const parser = this;
						const { json } = this;

						const accessorDef = this.json.accessors[accessorIndex];

						if (
							accessorDef.bufferView === undefined &&
							accessorDef.sparse === undefined
						) {
							// Ignore empty accessors, which may be used to declare runtime
							// information about attributes coming from another source (e.g. Draco
							// compression extension).
							return Promise.resolve(null);
						}

						const pendingBufferViews = [];

						if (accessorDef.bufferView !== undefined) {
							pendingBufferViews.push(
								this.getDependency('bufferView', accessorDef.bufferView)
							);
						} else {
							pendingBufferViews.push(null);
						}

						if (accessorDef.sparse !== undefined) {
							pendingBufferViews.push(
								this.getDependency('bufferView', accessorDef.sparse.indices.bufferView)
							);
							pendingBufferViews.push(
								this.getDependency('bufferView', accessorDef.sparse.values.bufferView)
							);
						}

						return Promise.all(pendingBufferViews).then(bufferViews => {
							const bufferView = bufferViews[0];

							const itemSize = _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_TYPE_SIZES"][accessorDef.type];
							const TypedArray = _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_COMPONENT_TYPES"][accessorDef.componentType];

							// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
							const elementBytes = TypedArray.BYTES_PER_ELEMENT;
							const itemBytes = elementBytes * itemSize;
							const byteOffset = accessorDef.byteOffset || 0;
							const byteStride =
								accessorDef.bufferView !== undefined
									? json.bufferViews[accessorDef.bufferView].byteStride
									: undefined;
							const normalized = accessorDef.normalized === true;
							let array;
							let bufferAttribute;

							// The buffer is not interleaved if the stride is the item size in bytes.
							if (byteStride && byteStride !== itemBytes) {
								// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
								// This makes sure that IBA.count reflects accessor.count properly
								const ibSlice = Math.floor(byteOffset / byteStride);
								const ibCacheKey = `InterleavedBuffer: ${accessorDef.bufferView}:${accessorDef.componentType
									}:${ibSlice}:${accessorDef.count}`;
								let ib = parser.cache.get(ibCacheKey);

								if (!ib) {
									array = new TypedArray(
										bufferView,
										ibSlice * byteStride,
										(accessorDef.count * byteStride) / elementBytes
									);
									// Integer parameters to IB/IBA are in array elements, not bytes.
									ib = new _core_InterleavedBuffer__WEBPACK_IMPORTED_MODULE_8__["InterleavedBuffer"](array, byteStride / elementBytes);
									parser.cache.add(ibCacheKey, ib);
								}

								bufferAttribute = new _core_InterleavedBufferAttribute__WEBPACK_IMPORTED_MODULE_9__["InterleavedBufferAttribute"](
									ib,
									itemSize,
									(byteOffset % byteStride) / elementBytes,
									normalized
								);
							} else {
								if (bufferView === null) {
									array = new TypedArray(accessorDef.count * itemSize);
								} else {
									array = new TypedArray(
										bufferView,
										byteOffset,
										accessorDef.count * itemSize
									);
								}
								bufferAttribute = new _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_3__["BufferAttribute"](array, itemSize, normalized);
							}

							// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
							if (accessorDef.sparse !== undefined) {
								const itemSizeIndices = _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_TYPE_SIZES"].SCALAR;
								const TypedArrayIndices =
									_utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_COMPONENT_TYPES"][accessorDef.sparse.indices.componentType];

								const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
								const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

								const sparseIndices = new TypedArrayIndices(
									bufferViews[1],
									byteOffsetIndices,
									accessorDef.sparse.count * itemSizeIndices
								);
								const sparseValues = new TypedArray(
									bufferViews[2],
									byteOffsetValues,
									accessorDef.sparse.count * itemSize
								);

								if (bufferView !== null) {
									// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
									bufferAttribute = new _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_3__["BufferAttribute"](
										bufferAttribute.array.slice(),
										bufferAttribute.itemSize,
										bufferAttribute.normalized
									);
								}

								for (let i = 0, il = sparseIndices.length; i < il; i++) {
									const index = sparseIndices[i];
									bufferAttribute.setX(index, sparseValues[i * itemSize]);
									if (itemSize >= 2)
										bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
									if (itemSize >= 3)
										bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
									if (itemSize >= 4)
										bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
									if (itemSize >= 5)
										throw new Error(
											'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.'
										);
								}
							}

							return bufferAttribute;
						});
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
					 * @param {number} textureIndex
					 * @return {Promise<THREE.Texture>}
					 */
					loadTexture(textureIndex) {
						const { json } = this;
						const { options } = this;
						const textureDef = json.textures[textureIndex];
						const source = json.images[textureDef.source];

						let loader = this.textureLoader;

						if (source.uri) {
							const handler = options.manager.getHandler(source.uri);
							if (handler !== null) loader = handler;
						}

						return this.loadTextureImage(textureIndex, source, loader);
					}

					loadTextureImage(textureIndex, source, loader) {
						const { json, options } = this;

						const textureDef = json.textures[textureIndex];

						const cacheKey = `${source.uri || source.bufferView}:${textureDef.sampler}`;

						if (this.textureCache[cacheKey]) {
							// See https://github.com/mrdoob/three.js/issues/21559.
							return this.textureCache[cacheKey];
						}

						const promise = new Promise(async (resolve, reject) => {
							const onLoad = texture => {
								texture.flipY = false;
								if (textureDef.name) texture.name = textureDef.name;

								const samplers = json.samplers || {};
								const sampler = samplers[textureDef.sampler] || {};

								texture.magFilter = _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_FILTERS"][sampler.magFilter] || _constants__WEBPACK_IMPORTED_MODULE_5__["LinearFilter"];
								texture.minFilter =
									_utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_FILTERS"][sampler.minFilter] || _constants__WEBPACK_IMPORTED_MODULE_5__["LinearMipmapLinearFilter"];
								texture.wrapS = _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_WRAPPINGS"][sampler.wrapS] || _constants__WEBPACK_IMPORTED_MODULE_5__["RepeatWrapping"];
								texture.wrapT = _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_WRAPPINGS"][sampler.wrapT] || _constants__WEBPACK_IMPORTED_MODULE_5__["RepeatWrapping"];

								this.associations.set(texture, { textures: textureIndex });
								resolve(texture);
							};

							const onError = err => {
								console.error(err);
								console.error(
									"THREE.GLTFLoader: Couldn't load texture",
									source.bufferView
								);
								reject(err);
								return null;
							};
							if (source.bufferView === 0 || source.bufferView) {
								// .glb
								const imageArrayBuffer = await this.getDependency(
									'bufferView',
									source.bufferView
								);
								// console.time('glb texture base64 convert');
								// const imageBase64 = `data:${
								//   source.mimeType
								// };base64,${my.arrayBufferToBase64(imageArrayBuffer)}`;
								// console.timeEnd('glb texture base64 convert');

								// TODO optimize the performance of glb image texture converting
								loader.load(imageArrayBuffer, onLoad, undefined, onError);
							} else if (source.uri) {
								// .gltf 加载图片资源加上时间戳拿最新的
								loader.load(
									_LoaderUtils__WEBPACK_IMPORTED_MODULE_32__["LoaderUtils"].resolveURL(source.uri + "?_t=" + Date.now(), options.path),
									onLoad,
									undefined,
									onError
								);
							}
						});

						this.textureCache[cacheKey] = promise;
						return promise;
					}

					/**
					 * Asynchronously assigns a texture to the given material parameters.
					 * @param {Object} materialParams
					 * @param {string} mapName
					 * @param {Object} mapDef
					 * @return {Promise<Texture>}
					 */
					assignTexture(materialParams, mapName, mapDef) {
						const parser = this;

						return this.getDependency('texture', mapDef.index).then(texture => {
							// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
							// However, we will copy UV set 0 to UV set 1 on demand for aoMap
							if (
								mapDef.texCoord !== undefined &&
								mapDef.texCoord != 0 &&
								!(mapName === 'aoMap' && mapDef.texCoord == 1)
							) {
								console.warn(
									`THREE.GLTFLoader: Custom UV set ${mapDef.texCoord
									} for texture ${mapName} not yet supported.`
								);
							}

							if (parser.extensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_TEXTURE_TRANSFORM]) {
								const transform =
									mapDef.extensions !== undefined
										? mapDef.extensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_TEXTURE_TRANSFORM]
										: undefined;
								if (transform) {
									const gltfReference = parser.associations.get(texture);
									texture = parser.extensions[
										_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_TEXTURE_TRANSFORM
									].extendTexture(texture, transform);
									parser.associations.set(texture, gltfReference);
								}
							}
							materialParams[mapName] = texture;
							return texture;
						});
					}

					/**
					 * Assigns final material to a Mesh, Line, or Points instance. The instance
					 * already has a material (generated from the glTF material options alone)
					 * but reuse of the same glTF material may require multiple threejs materials
					 * to accommodate different primitive types, defines, etc. New materials will
					 * be created if necessary, and reused from a cache.
					 * @param  {Object3D} mesh Mesh, Line, or Points instance.
					 */
					assignFinalMaterial(mesh) {
						const { geometry } = mesh;
						let { material } = mesh;

						const useDerivativeTangents = geometry.attributes.tangent === undefined;
						const useVertexColors = geometry.attributes.color !== undefined;
						const useFlatShading = geometry.attributes.normal === undefined;

						if (mesh.isPoints) {
							const cacheKey = `PointsMaterial:${material.uuid}`;
							let pointsMaterial = this.cache.get(cacheKey);
							if (!pointsMaterial) {
								pointsMaterial = new _materials_PointsMaterial__WEBPACK_IMPORTED_MODULE_21__["PointsMaterial"]();
								_materials_Material__WEBPACK_IMPORTED_MODULE_14__["Material"].prototype.copy.call(pointsMaterial, material);
								pointsMaterial.color.copy(material.color);
								pointsMaterial.map = material.map;
								pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

								this.cache.add(cacheKey, pointsMaterial);
							}

							material = pointsMaterial;
						} else if (mesh.isLine) {
							const cacheKey = `LineBasicMaterial:${material.uuid}`;

							let lineMaterial = this.cache.get(cacheKey);

							if (!lineMaterial) {
								lineMaterial = new _materials_LineBasicMaterial__WEBPACK_IMPORTED_MODULE_11__["LineBasicMaterial"]();
								_materials_Material__WEBPACK_IMPORTED_MODULE_14__["Material"].prototype.copy.call(lineMaterial, material);
								lineMaterial.color.copy(material.color);

								this.cache.add(cacheKey, lineMaterial);
							}

							material = lineMaterial;
						}

						// Clone the material if it will be modified
						if (useDerivativeTangents || useVertexColors || useFlatShading) {
							let cacheKey = `ClonedMaterial:${material.uuid}:`;

							if (material.isGLTFSpecularGlossinessMaterial)
								cacheKey += 'specular-glossiness:';
							if (useDerivativeTangents) cacheKey += 'derivative-tangents:';
							if (useVertexColors) cacheKey += 'vertex-colors:';
							if (useFlatShading) cacheKey += 'flat-shading:';

							let cachedMaterial = this.cache.get(cacheKey);

							if (!cachedMaterial) {
								cachedMaterial = material.clone();
								if (useVertexColors) cachedMaterial.vertexColors = true;
								if (useFlatShading) cachedMaterial.flatShading = true;
								if (useDerivativeTangents) {
									// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
									if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
									if (cachedMaterial.clearcoatNormalScale)
										cachedMaterial.clearcoatNormalScale.y *= -1;
								}

								this.cache.add(cacheKey, cachedMaterial);
								this.associations.set(cachedMaterial, this.associations.get(material));
							}

							material = cachedMaterial;
						}

						// workarounds for mesh and geometry

						if (
							material.aoMap &&
							geometry.attributes.uv2 === undefined &&
							geometry.attributes.uv !== undefined
						) {
							geometry.setAttribute('uv2', geometry.attributes.uv);
						}

						mesh.material = material;
					}

					getMaterialType(/* materialIndex */) {
						return _materials_MeshStandardMaterial__WEBPACK_IMPORTED_MODULE_33__["MeshStandardMaterial"];
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
					 * @param {number} materialIndex
					 * @return {Promise<Material>}
					 */
					loadMaterial(materialIndex) {
						const parser = this;
						const { json } = this;
						const { extensions } = this;
						const materialDef = json.materials[materialIndex];

						let MaterialType;
						const materialParams = {};
						const materialExtensions = materialDef.extensions || {};

						const pending = [];

						if (materialExtensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
							const sgExtension =
								extensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
							MaterialType = sgExtension.getMaterialType();
							pending.push(
								sgExtension.extendParams(materialParams, materialDef, parser)
							);
						} else if (materialExtensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_MATERIALS_UNLIT]) {
							const kmuExtension = extensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_MATERIALS_UNLIT];
							MaterialType = kmuExtension.getMaterialType();
							pending.push(
								kmuExtension.extendParams(materialParams, materialDef, parser)
							);
						} else {
							// Specification:
							// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

							const metallicRoughness = materialDef.pbrMetallicRoughness || {};

							materialParams.color = new _math_Color__WEBPACK_IMPORTED_MODULE_2__["Color"](1.0, 1.0, 1.0);
							materialParams.opacity = 1.0;

							if (Array.isArray(metallicRoughness.baseColorFactor)) {
								const array = metallicRoughness.baseColorFactor;

								materialParams.color.fromArray(array);
								materialParams.opacity = array[3];
							}

							if (metallicRoughness.baseColorTexture !== undefined) {
								pending.push(
									parser.assignTexture(
										materialParams,
										'map',
										metallicRoughness.baseColorTexture
									)
								);
							}

							materialParams.metalness =
								metallicRoughness.metallicFactor !== undefined
									? metallicRoughness.metallicFactor
									: 1.0;
							materialParams.roughness =
								metallicRoughness.roughnessFactor !== undefined
									? metallicRoughness.roughnessFactor
									: 1.0;

							if (metallicRoughness.metallicRoughnessTexture !== undefined) {
								pending.push(
									parser.assignTexture(
										materialParams,
										'metalnessMap',
										metallicRoughness.metallicRoughnessTexture
									)
								);
								pending.push(
									parser.assignTexture(
										materialParams,
										'roughnessMap',
										metallicRoughness.metallicRoughnessTexture
									)
								);
							}

							MaterialType = this._invokeOne(
								ext => ext.getMaterialType && ext.getMaterialType(materialIndex)
							);

							pending.push(
								Promise.all(
									this._invokeAll(
										ext =>
											ext.extendMaterialParams &&
											ext.extendMaterialParams(materialIndex, materialParams)
									)
								)
							);
						}

						if (materialDef.doubleSided === true) {
							materialParams.side = _constants__WEBPACK_IMPORTED_MODULE_5__["DoubleSide"];
						}

						const alphaMode = materialDef.alphaMode || _utils__WEBPACK_IMPORTED_MODULE_30__["ALPHA_MODES"].OPAQUE;

						if (alphaMode === _utils__WEBPACK_IMPORTED_MODULE_30__["ALPHA_MODES"].BLEND) {
							materialParams.transparent = true;
							// See: https://github.com/mrdoob/three.js/issues/17706
							materialParams.depthWrite = false;
						} else {
							materialParams.format = _constants__WEBPACK_IMPORTED_MODULE_5__["RGBFormat"];
							materialParams.transparent = false;
							if (alphaMode === _utils__WEBPACK_IMPORTED_MODULE_30__["ALPHA_MODES"].MASK) {
								materialParams.alphaTest =
									materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
							}
						}

						if (
							materialDef.normalTexture !== undefined &&
							MaterialType !== _materials_MeshBasicMaterial__WEBPACK_IMPORTED_MODULE_34__["MeshBasicMaterial"]
						) {
							pending.push(
								parser.assignTexture(
									materialParams,
									'normalMap',
									materialDef.normalTexture
								)
							);

							materialParams.normalScale = new _math_Vector2__WEBPACK_IMPORTED_MODULE_27__["Vector2"](1, 1);

							if (materialDef.normalTexture.scale !== undefined) {
								const { scale } = materialDef.normalTexture;
								materialParams.normalScale.set(scale, scale);
							}
						}

						if (
							materialDef.occlusionTexture !== undefined &&
							MaterialType !== _materials_MeshBasicMaterial__WEBPACK_IMPORTED_MODULE_34__["MeshBasicMaterial"]
						) {
							pending.push(
								parser.assignTexture(
									materialParams,
									'aoMap',
									materialDef.occlusionTexture
								)
							);
							if (materialDef.occlusionTexture.strength !== undefined) {
								materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
							}
						}

						if (
							materialDef.emissiveFactor !== undefined &&
							MaterialType !== _materials_MeshBasicMaterial__WEBPACK_IMPORTED_MODULE_34__["MeshBasicMaterial"]
						) {
							materialParams.emissive = new _math_Color__WEBPACK_IMPORTED_MODULE_2__["Color"]().fromArray(
								materialDef.emissiveFactor
							);
						}

						if (
							materialDef.emissiveTexture !== undefined &&
							MaterialType !== _materials_MeshBasicMaterial__WEBPACK_IMPORTED_MODULE_34__["MeshBasicMaterial"]
						) {
							pending.push(
								parser.assignTexture(
									materialParams,
									'emissiveMap',
									materialDef.emissiveTexture
								)
							);
						}

						return Promise.all(pending).then(() => {
							let material;

							if (MaterialType === _GLTFMeshStandardSGMaterial__WEBPACK_IMPORTED_MODULE_35__["GLTFMeshStandardSGMaterial"]) {
								material = extensions[
									_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
								].createMaterial(materialParams);
							} else {
								material = new MaterialType(materialParams);
							}

							if (materialDef.name) material.name = materialDef.name;

							// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
							if (material.map) material.map.encoding = _constants__WEBPACK_IMPORTED_MODULE_5__["sRGBEncoding"];
							if (material.emissiveMap) material.emissiveMap.encoding = _constants__WEBPACK_IMPORTED_MODULE_5__["sRGBEncoding"];

							Object(_utils__WEBPACK_IMPORTED_MODULE_30__["assignExtrasToUserData"])(material, materialDef);

							parser.associations.set(material, { materials: materialIndex });

							if (materialDef.extensions)
								Object(_utils__WEBPACK_IMPORTED_MODULE_30__["addUnknownExtensionsToUserData"])(extensions, material, materialDef);

							return material;
						});
					}

					/** When Object3D instances are targeted by animation, they need unique names. */
					createUniqueName(originalName) {
						const sanitizedName = _animation_PropertyBinding__WEBPACK_IMPORTED_MODULE_22__["PropertyBinding"].sanitizeNodeName(originalName || '');

						let name = sanitizedName;

						for (let i = 1; this.nodeNamesUsed[name]; ++i) {
							name = `${sanitizedName}_${i}`;
						}
						this.nodeNamesUsed[name] = true;
						return name;
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
					 *
					 * Creates BufferGeometries from primitives.
					 *
					 * @param {Array<GLTF.Primitive>} primitives
					 * @return {Promise<Array<BufferGeometry>>}
					 */
					loadGeometries(primitives) {
						const parser = this;
						const { extensions } = this;
						const cache = this.primitiveCache;

						function createDracoPrimitive(primitive) {
							return extensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_DRACO_MESH_COMPRESSION]
								.decodePrimitive(primitive, parser)
								.then(geometry => Object(_utils__WEBPACK_IMPORTED_MODULE_30__["addPrimitiveAttributes"])(geometry, primitive, parser));
						}

						const pending = [];

						for (let i = 0, il = primitives.length; i < il; i++) {
							const primitive = primitives[i];
							const cacheKey = Object(_utils__WEBPACK_IMPORTED_MODULE_30__["createPrimitiveKey"])(primitive);

							// See if we've already created this geometry
							const cached = cache[cacheKey];

							if (cached) {
								// Use the cached geometry if it exists
								pending.push(cached.promise);
							} else {
								let geometryPromise;
								if (
									primitive.extensions &&
									primitive.extensions[_utils__WEBPACK_IMPORTED_MODULE_30__["EXTENSIONS"].KHR_DRACO_MESH_COMPRESSION]
								) {
									// Use DRACO geometry if available
									geometryPromise = createDracoPrimitive(primitive);
								} else {
									// Otherwise create a new geometry
									geometryPromise = Object(_utils__WEBPACK_IMPORTED_MODULE_30__["addPrimitiveAttributes"])(
										new _core_BufferGeometry__WEBPACK_IMPORTED_MODULE_4__["BufferGeometry"](),
										primitive,
										parser
									);
								}

								// Cache this geometry
								cache[cacheKey] = { primitive, promise: geometryPromise };
								pending.push(geometryPromise);
							}
						}

						return Promise.all(pending);
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
					 * @param {number} meshIndex
					 * @return {Promise<Group|Mesh|SkinnedMesh>}
					 */
					loadMesh(meshIndex) {
						const parser = this;
						const { json } = this;
						const { extensions } = this;

						const meshDef = json.meshes[meshIndex];
						const { primitives } = meshDef;

						const pending = [];

						for (let i = 0, il = primitives.length; i < il; i++) {
							const material =
								primitives[i].material === undefined
									? Object(_utils__WEBPACK_IMPORTED_MODULE_30__["createDefaultMaterial"])(this.cache)
									: this.getDependency('material', primitives[i].material);

							pending.push(material);
						}

						pending.push(parser.loadGeometries(primitives));

						return Promise.all(pending).then(results => {
							const materials = results.slice(0, results.length - 1);
							const geometries = results[results.length - 1];

							const meshes = [];

							for (let i = 0, il = geometries.length; i < il; i++) {
								const geometry = geometries[i];
								const primitive = primitives[i];

								// 1. create Mesh

								let mesh;

								const material = materials[i];

								if (
									primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].TRIANGLES ||
									primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].TRIANGLE_STRIP ||
									primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].TRIANGLE_FAN ||
									primitive.mode === undefined
								) {
									// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
									mesh =
										meshDef.isSkinnedMesh === true
											? new _objects_SkinnedMesh__WEBPACK_IMPORTED_MODULE_24__["SkinnedMesh"](geometry, material)
											: new _objects_Mesh__WEBPACK_IMPORTED_MODULE_15__["Mesh"](geometry, material);

									if (
										mesh.isSkinnedMesh === true &&
										!mesh.geometry.attributes.skinWeight.normalized
									) {
										// we normalize floating point skin weight array to fix malformed assets (see #15319)
										// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
										mesh.normalizeSkinWeights();
									}

									if (primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].TRIANGLE_STRIP) {
										mesh.geometry = Object(_utils__WEBPACK_IMPORTED_MODULE_30__["toTrianglesDrawMode"])(
											mesh.geometry,
											_constants__WEBPACK_IMPORTED_MODULE_5__["TriangleStripDrawMode"]
										);
									} else if (primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].TRIANGLE_FAN) {
										mesh.geometry = Object(_utils__WEBPACK_IMPORTED_MODULE_30__["toTrianglesDrawMode"])(
											mesh.geometry,
											_constants__WEBPACK_IMPORTED_MODULE_5__["TriangleFanDrawMode"]
										);
									}
								} else if (primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].LINES) {
									mesh = new _objects_LineSegments__WEBPACK_IMPORTED_MODULE_13__["LineSegments"](geometry, material);
								} else if (primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].LINE_STRIP) {
									mesh = new _objects_Line__WEBPACK_IMPORTED_MODULE_10__["Line"](geometry, material);
								} else if (primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].LINE_LOOP) {
									mesh = new _objects_LineLoop__WEBPACK_IMPORTED_MODULE_12__["LineLoop"](geometry, material);
								} else if (primitive.mode === _utils__WEBPACK_IMPORTED_MODULE_30__["WEBGL_CONSTANTS"].POINTS) {
									mesh = new _objects_Points__WEBPACK_IMPORTED_MODULE_20__["Points"](geometry, material);
								} else {
									throw new Error(
										`THREE.GLTFLoader: Primitive mode unsupported: ${primitive.mode}`
									);
								}

								if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
									Object(_utils__WEBPACK_IMPORTED_MODULE_30__["updateMorphTargets"])(mesh, meshDef);
								}

								mesh.name = parser.createUniqueName(
									meshDef.name || `mesh_${meshIndex}`
								);

								Object(_utils__WEBPACK_IMPORTED_MODULE_30__["assignExtrasToUserData"])(mesh, meshDef);

								if (primitive.extensions)
									Object(_utils__WEBPACK_IMPORTED_MODULE_30__["addUnknownExtensionsToUserData"])(extensions, mesh, primitive);

								parser.assignFinalMaterial(mesh);
								meshes.push(mesh);
							}

							for (let i = 0, il = meshes.length; i < il; i++) {
								parser.associations.set(meshes[i], {
									meshes: meshIndex,
									primitives: i
								});
							}

							if (meshes.length === 1) {
								return meshes[0];
							}

							const group = new _objects_Group__WEBPACK_IMPORTED_MODULE_6__["Group"]();

							parser.associations.set(group, { meshes: meshIndex });

							for (let i = 0, il = meshes.length; i < il; i++) {
								group.add(meshes[i]);
							}

							return group;
						});
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
					 * @param {number} cameraIndex
					 * @return {Promise<THREE.Camera>}
					 */
					loadCamera(cameraIndex) {
						let camera;
						const cameraDef = this.json.cameras[cameraIndex];
						const params = cameraDef[cameraDef.type];

						if (!params) {
							console.warn('THREE.GLTFLoader: Missing camera parameters.');
							return;
						}

						if (cameraDef.type === 'perspective') {
							camera = new _cameras_PerspectiveCamera__WEBPACK_IMPORTED_MODULE_19__["PerspectiveCamera"](
								_math_MathUtils__WEBPACK_IMPORTED_MODULE_28__["radToDeg"](params.yfov),
								params.aspectRatio || 1,
								params.znear || 1,
								params.zfar || 2e6
							);
						} else if (cameraDef.type === 'orthographic') {
							camera = new _cameras_OrthographicCamera__WEBPACK_IMPORTED_MODULE_18__["OrthographicCamera"](
								-params.xmag,
								params.xmag,
								params.ymag,
								-params.ymag,
								params.znear,
								params.zfar
							);
						}

						if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);

						Object(_utils__WEBPACK_IMPORTED_MODULE_30__["assignExtrasToUserData"])(camera, cameraDef);

						return Promise.resolve(camera);
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
					 * @param {number} skinIndex
					 * @return {Promise<Object>}
					 */
					loadSkin(skinIndex) {
						const skinDef = this.json.skins[skinIndex];

						const skinEntry = { joints: skinDef.joints };

						if (skinDef.inverseBindMatrices === undefined) {
							return Promise.resolve(skinEntry);
						}

						return this.getDependency('accessor', skinDef.inverseBindMatrices).then(
							accessor => {
								skinEntry.inverseBindMatrices = accessor;
								return skinEntry;
							}
						);
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
					 * @param {number} animationIndex
					 * @return {Promise<AnimationClip>}
					 */
					loadAnimation(animationIndex) {
						const { json } = this;

						const animationDef = json.animations[animationIndex];

						const pendingNodes = [];
						const pendingInputAccessors = [];
						const pendingOutputAccessors = [];
						const pendingSamplers = [];
						const pendingTargets = [];

						for (let i = 0, il = animationDef.channels.length; i < il; i++) {
							const channel = animationDef.channels[i];
							const sampler = animationDef.samplers[channel.sampler];
							const { target } = channel;
							const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
							const input =
								animationDef.parameters !== undefined
									? animationDef.parameters[sampler.input]
									: sampler.input;
							const output =
								animationDef.parameters !== undefined
									? animationDef.parameters[sampler.output]
									: sampler.output;

							pendingNodes.push(this.getDependency('node', name));
							pendingInputAccessors.push(this.getDependency('accessor', input));
							pendingOutputAccessors.push(this.getDependency('accessor', output));
							pendingSamplers.push(sampler);
							pendingTargets.push(target);
						}

						return Promise.all([
							Promise.all(pendingNodes),
							Promise.all(pendingInputAccessors),
							Promise.all(pendingOutputAccessors),
							Promise.all(pendingSamplers),
							Promise.all(pendingTargets)
						]).then(dependencies => {
							const nodes = dependencies[0];
							const inputAccessors = dependencies[1];
							const outputAccessors = dependencies[2];
							const samplers = dependencies[3];
							const targets = dependencies[4];

							const tracks = [];

							for (let i = 0, il = nodes.length; i < il; i++) {
								const node = nodes[i];
								const inputAccessor = inputAccessors[i];
								const outputAccessor = outputAccessors[i];
								const sampler = samplers[i];
								const target = targets[i];

								if (node === undefined) continue;

								node.updateMatrix();
								node.matrixAutoUpdate = true;

								let TypedKeyframeTrack;

								switch (_utils__WEBPACK_IMPORTED_MODULE_30__["PATH_PROPERTIES"][target.path]) {
									case _utils__WEBPACK_IMPORTED_MODULE_30__["PATH_PROPERTIES"].weights:
										TypedKeyframeTrack = _animation_tracks_NumberKeyframeTrack__WEBPACK_IMPORTED_MODULE_16__["NumberKeyframeTrack"];
										break;

									case _utils__WEBPACK_IMPORTED_MODULE_30__["PATH_PROPERTIES"].rotation:
										TypedKeyframeTrack = _animation_tracks_QuaternionKeyframeTrack__WEBPACK_IMPORTED_MODULE_23__["QuaternionKeyframeTrack"];
										break;

									case _utils__WEBPACK_IMPORTED_MODULE_30__["PATH_PROPERTIES"].position:
									case _utils__WEBPACK_IMPORTED_MODULE_30__["PATH_PROPERTIES"].scale:
									default:
										TypedKeyframeTrack = _animation_tracks_VectorKeyframeTrack__WEBPACK_IMPORTED_MODULE_29__["VectorKeyframeTrack"];
										break;
								}

								const targetName = node.name ? node.name : node.uuid;

								const interpolation =
									sampler.interpolation !== undefined
										? _utils__WEBPACK_IMPORTED_MODULE_30__["INTERPOLATION"][sampler.interpolation]
										: _constants__WEBPACK_IMPORTED_MODULE_5__["InterpolateLinear"];

								const targetNames = [];

								if (_utils__WEBPACK_IMPORTED_MODULE_30__["PATH_PROPERTIES"][target.path] === _utils__WEBPACK_IMPORTED_MODULE_30__["PATH_PROPERTIES"].weights) {
									// Node may be a Group (glTF mesh with several primitives) or a Mesh.
									node.traverse(object => {
										if (object.isMesh === true && object.morphTargetInfluences) {
											targetNames.push(object.name ? object.name : object.uuid);
										}
									});
								} else {
									targetNames.push(targetName);
								}

								let outputArray = outputAccessor.array;

								if (outputAccessor.normalized) {
									const scale = Object(_utils__WEBPACK_IMPORTED_MODULE_30__["getNormalizedComponentScale"])(outputArray.constructor);
									const scaled = new Float32Array(outputArray.length);

									for (let j = 0, jl = outputArray.length; j < jl; j++) {
										scaled[j] = outputArray[j] * scale;
									}

									outputArray = scaled;
								}

								for (let j = 0, jl = targetNames.length; j < jl; j++) {
									const track = new TypedKeyframeTrack(
										`${targetNames[j]}.${_utils__WEBPACK_IMPORTED_MODULE_30__["PATH_PROPERTIES"][target.path]}`,
										inputAccessor.array,
										outputArray,
										interpolation
									);

									// Override interpolation with custom factory method.
									if (sampler.interpolation === 'CUBICSPLINE') {
										track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(
											result
										) {
											// A CUBICSPLINE keyframe in glTF has three output values for each input value,
											// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
											// must be divided by three to get the interpolant's sampleSize argument.
											const InterpolantType =
												this instanceof _animation_tracks_QuaternionKeyframeTrack__WEBPACK_IMPORTED_MODULE_23__["QuaternionKeyframeTrack"]
													? _GLTFCubicSplineQuaternionInterpolant__WEBPACK_IMPORTED_MODULE_38__["GLTFCubicSplineQuaternionInterpolant"]
													: _GLTFCubicSplineInterpolant__WEBPACK_IMPORTED_MODULE_37__["GLTFCubicSplineInterpolant"];
											return new InterpolantType(
												this.times,
												this.values,
												this.getValueSize() / 3,
												result
											);
										};

										// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
										track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
									}

									tracks.push(track);
								}
							}

							const name = animationDef.name
								? animationDef.name
								: `animation_${animationIndex}`;

							return new _animation_AnimationClip__WEBPACK_IMPORTED_MODULE_0__["AnimationClip"](name, undefined, tracks);
						});
					}

					createNodeMesh(nodeIndex) {
						const { json } = this;
						const parser = this;
						const nodeDef = json.nodes[nodeIndex];

						if (nodeDef.mesh === undefined) return null;

						return parser.getDependency('mesh', nodeDef.mesh).then(mesh => {
							const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);

							// if weights are provided on the node, override weights on the mesh.
							if (nodeDef.weights !== undefined) {
								node.traverse(o => {
									if (!o.isMesh) return;
									for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
										o.morphTargetInfluences[i] = nodeDef.weights[i];
									}
								});
							}

							return node;
						});
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
					 * @param {number} nodeIndex
					 * @return {Promise<Object3D>}
					 */
					loadNode(nodeIndex) {
						const { json } = this;
						const { extensions } = this;
						const parser = this;

						const nodeDef = json.nodes[nodeIndex];

						// reserve node's name before its dependencies, so the root has the intended name.
						const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';
						return (() => {
							const pending = [];
							const meshPromise = parser._invokeOne(
								ext => ext.createNodeMesh && ext.createNodeMesh(nodeIndex)
							);

							if (meshPromise) {
								pending.push(meshPromise);
							}

							if (nodeDef.camera !== undefined) {
								pending.push(
									parser
										.getDependency('camera', nodeDef.camera)
										.then(camera =>
											parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)
										)
								);
							}

							parser
								._invokeAll(
									ext => ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)
								)
								.forEach(promise => {
									pending.push(promise);
								});

							return Promise.all(pending);
						})().then(objects => {
							let node;

							// .isBone isn't in glTF spec. See ._markDefs
							if (nodeDef.isBone === true) {
								node = new _objects_Bone__WEBPACK_IMPORTED_MODULE_1__["Bone"]();
							} else if (objects.length > 1) {
								node = new _objects_Group__WEBPACK_IMPORTED_MODULE_6__["Group"]();
							} else if (objects.length === 1) {
								node = objects[0];
							} else {
								node = new _core_Object3D__WEBPACK_IMPORTED_MODULE_17__["Object3D"]();
							}

							if (node !== objects[0]) {
								for (let i = 0, il = objects.length; i < il; i++) {
									node.add(objects[i]);
								}
							}

							if (nodeDef.name) {
								node.userData.name = nodeDef.name;
								node.name = nodeName;
							}

							Object(_utils__WEBPACK_IMPORTED_MODULE_30__["assignExtrasToUserData"])(node, nodeDef);

							if (nodeDef.extensions)
								Object(_utils__WEBPACK_IMPORTED_MODULE_30__["addUnknownExtensionsToUserData"])(extensions, node, nodeDef);

							if (nodeDef.matrix !== undefined) {
								const matrix = new _math_Matrix4__WEBPACK_IMPORTED_MODULE_36__["Matrix4"]();
								matrix.fromArray(nodeDef.matrix);
								node.applyMatrix4(matrix);
							} else {
								if (nodeDef.translation !== undefined) {
									node.position.fromArray(nodeDef.translation);
								}

								if (nodeDef.rotation !== undefined) {
									node.quaternion.fromArray(nodeDef.rotation);
								}

								if (nodeDef.scale !== undefined) {
									node.scale.fromArray(nodeDef.scale);
								}
							}

							if (!parser.associations.has(node)) {
								parser.associations.set(node, {});
							}

							parser.associations.get(node).nodes = nodeIndex;
							return node;
						});
					}

					/**
					 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
					 * @param {number} sceneIndex
					 * @return {Promise<Group>}
					 */
					loadScene(sceneIndex) {
						const { json } = this;
						const { extensions } = this;
						const sceneDef = this.json.scenes[sceneIndex];
						const parser = this;
						// console.log("666")
						// Loader returns Group, not Scene.
						// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
						const scene = new _objects_Group__WEBPACK_IMPORTED_MODULE_6__["Group"]();
						if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);

						Object(_utils__WEBPACK_IMPORTED_MODULE_30__["assignExtrasToUserData"])(scene, sceneDef);

						if (sceneDef.extensions)
							Object(_utils__WEBPACK_IMPORTED_MODULE_30__["addUnknownExtensionsToUserData"])(extensions, scene, sceneDef);

						const nodeIds = sceneDef.nodes || [];
						const pending = [];

						for (let i = 0, il = nodeIds.length; i < il; i++) {
							pending.push(Object(_utils__WEBPACK_IMPORTED_MODULE_30__["buildNodeHierarchy"])(nodeIds[i], scene, json, parser));
						}
						// console.log("fff",pending);

						return Promise.all(pending).then(() => {
							// Removes dangling associations, associations that reference a node that
							// didn't make it into the scene.

							const reduceAssociations = node => {
								const reducedAssociations = new Map();

								for (const [key, value] of parser.associations) {
									if (key instanceof _materials_Material__WEBPACK_IMPORTED_MODULE_14__["Material"] || key instanceof _textures_Texture__WEBPACK_IMPORTED_MODULE_25__["Texture"]) {
										reducedAssociations.set(key, value);
									}
								}

								node.traverse(nodeItem => {
									const mappings = parser.associations.get(nodeItem);
									if (mappings != null) {
										reducedAssociations.set(nodeItem, mappings);
									}
								});
								return reducedAssociations;
							};

							parser.associations = reduceAssociations(scene);

							return scene;
						}).catch(e => {
							console.log("err", e);
						});
					}
				}


				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFTextureBasisUExtension.js":
/*!***************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFTextureBasisUExtension.js ***!
  \***************************************************************/
/*! exports provided: GLTFTextureBasisUExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFTextureBasisUExtension", function () { return GLTFTextureBasisUExtension; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");


				/**
				 * BasisU Texture Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
				 */
				class GLTFTextureBasisUExtension {

					constructor(parser) {

						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_0__["EXTENSIONS"].KHR_TEXTURE_BASISU;

					}

					loadTexture(textureIndex) {

						const { parser } = this;
						const { json } = parser;

						const textureDef = json.textures[textureIndex];

						if (!textureDef.extensions || !textureDef.extensions[this.name]) {

							return null;

						}

						const extension = textureDef.extensions[this.name];
						const source = json.images[extension.source];
						const loader = parser.options.ktx2Loader;

						if (!loader) {

							if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {

								throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');

							} else {
								// Assumes that the extension is optional and that a fallback texture is present
								return null;
							}

						}

						return parser.loadTextureImage(textureIndex, source, loader);
					}

				}


				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFTextureTransformExtension.js":
/*!******************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFTextureTransformExtension.js ***!
  \******************************************************************/
/*! exports provided: GLTFTextureTransformExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFTextureTransformExtension", function () { return GLTFTextureTransformExtension; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");


				/**
				 * Texture Transform Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
				 */
				class GLTFTextureTransformExtension {

					constructor() {
						this.name = _utils__WEBPACK_IMPORTED_MODULE_0__["EXTENSIONS"].KHR_TEXTURE_TRANSFORM;
					}

					extendTexture(texture, transform) {

						if (transform.texCoord !== undefined) {
							console.warn(`THREE.GLTFLoader: Custom UV sets in ${this.name} extension not yet supported.`);
						}

						if (transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {
							// See https://github.com/mrdoob/three.js/issues/21819.
							return texture;
						}

						texture = texture.clone();

						if (transform.offset !== undefined) {
							texture.offset.fromArray(transform.offset);
						}

						if (transform.rotation !== undefined) {
							texture.rotation = transform.rotation;
						}

						if (transform.scale !== undefined) {
							texture.repeat.fromArray(transform.scale);
						}

						texture.needsUpdate = true;
						return texture;
					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/GLTFTextureWebPExtension.js":
/*!*************************************************************!*\
  !*** ./libs/three/loaders/gltf/GLTFTextureWebPExtension.js ***!
  \*************************************************************/
/*! exports provided: GLTFTextureWebPExtension */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFTextureWebPExtension", function () { return GLTFTextureWebPExtension; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./libs/three/loaders/gltf/utils.js");


				/**
				 * WebP Texture Extension
				 *
				 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
				 */
				class GLTFTextureWebPExtension {

					constructor(parser) {

						this.parser = parser;
						this.name = _utils__WEBPACK_IMPORTED_MODULE_0__["EXTENSIONS"].EXT_TEXTURE_WEBP;
						this.isSupported = null;

					}

					loadTexture(textureIndex) {

						const { name } = this;
						const { parser } = this;
						const { json } = parser;

						const textureDef = json.textures[textureIndex];

						if (!textureDef.extensions || !textureDef.extensions[name]) {

							return null;

						}

						const extension = textureDef.extensions[name];
						const source = json.images[extension.source];

						let loader = parser.textureLoader;
						if (source.uri) {

							const handler = parser.options.manager.getHandler(source.uri);
							if (handler !== null) loader = handler;

						}

						return this.detectSupport().then(isSupported => {

							if (isSupported) return parser.loadTextureImage(textureIndex, source, loader);

							if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
								throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.');
							}

							// Fall back to PNG or JPEG.
							return parser.loadTexture(textureIndex);

						});

					}

					detectSupport() {

						if (!this.isSupported) {

							this.isSupported = new Promise((resolve) => {

								const image = new Image();

								// Lossy test image. Support for lossy images doesn't guarantee support for all
								// WebP images, unfortunately.
								image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

								image.onload = () => {
									resolve(image.height === 1);
								};
								image.onerror = () => {
									resolve(image.height === 1);
								};
							});
						}

						return this.isSupported;
					}
				}

				/***/
}),

/***/ "./libs/three/loaders/gltf/utils.js":
/*!******************************************!*\
  !*** ./libs/three/loaders/gltf/utils.js ***!
  \******************************************/
/*! exports provided: BINARY_EXTENSION_HEADER_MAGIC, BINARY_EXTENSION_HEADER_LENGTH, BINARY_EXTENSION_CHUNK_TYPES, EXTENSIONS, GLTFRegistry, addUnknownExtensionsToUserData, assignExtrasToUserData, WEBGL_CONSTANTS, WEBGL_COMPONENT_TYPES, WEBGL_FILTERS, WEBGL_WRAPPINGS, WEBGL_TYPE_SIZES, ATTRIBUTES, PATH_PROPERTIES, INTERPOLATION, ALPHA_MODES, createDefaultMaterial, addMorphTargets, updateMorphTargets, createAttributesKey, createPrimitiveKey, getNormalizedComponentScale, buildNodeHierarchy, computeBounds, addPrimitiveAttributes, toTrianglesDrawMode */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BINARY_EXTENSION_HEADER_MAGIC", function () { return BINARY_EXTENSION_HEADER_MAGIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BINARY_EXTENSION_HEADER_LENGTH", function () { return BINARY_EXTENSION_HEADER_LENGTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BINARY_EXTENSION_CHUNK_TYPES", function () { return BINARY_EXTENSION_CHUNK_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENSIONS", function () { return EXTENSIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GLTFRegistry", function () { return GLTFRegistry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addUnknownExtensionsToUserData", function () { return addUnknownExtensionsToUserData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assignExtrasToUserData", function () { return assignExtrasToUserData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL_CONSTANTS", function () { return WEBGL_CONSTANTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL_COMPONENT_TYPES", function () { return WEBGL_COMPONENT_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL_FILTERS", function () { return WEBGL_FILTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL_WRAPPINGS", function () { return WEBGL_WRAPPINGS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL_TYPE_SIZES", function () { return WEBGL_TYPE_SIZES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTES", function () { return ATTRIBUTES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PATH_PROPERTIES", function () { return PATH_PROPERTIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "INTERPOLATION", function () { return INTERPOLATION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALPHA_MODES", function () { return ALPHA_MODES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createDefaultMaterial", function () { return createDefaultMaterial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addMorphTargets", function () { return addMorphTargets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateMorphTargets", function () { return updateMorphTargets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createAttributesKey", function () { return createAttributesKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createPrimitiveKey", function () { return createPrimitiveKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNormalizedComponentScale", function () { return getNormalizedComponentScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildNodeHierarchy", function () { return buildNodeHierarchy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeBounds", function () { return computeBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addPrimitiveAttributes", function () { return addPrimitiveAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toTrianglesDrawMode", function () { return toTrianglesDrawMode; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants */ "./libs/three/constants.js");
/* harmony import */ var _math_Box3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Box3 */ "./libs/three/math/Box3.js");
/* harmony import */ var _math_Matrix4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Matrix4 */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _objects_Skeleton__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../objects/Skeleton */ "./libs/three/objects/Skeleton.js");
/* harmony import */ var _math_Sphere__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Sphere */ "./libs/three/math/Sphere.js");
/* harmony import */ var _math_Vector3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/Vector3 */ "./libs/three/math/Vector3.js");
/* harmony import */ var _materials_MeshStandardMaterial__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../materials/MeshStandardMaterial */ "./libs/three/materials/MeshStandardMaterial.js");








				const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
				const BINARY_EXTENSION_HEADER_LENGTH = 12;
				const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

				const EXTENSIONS = {
					KHR_BINARY_GLTF: 'KHR_binary_glTF',
					KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
					KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
					KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
					KHR_MATERIALS_IOR: 'KHR_materials_ior',
					KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
					KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
					KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
					KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
					KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
					KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
					KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
					KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
					KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
					EXT_TEXTURE_WEBP: 'EXT_texture_webp',
					EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
				};


				/* GLTFREGISTRY */

				function GLTFRegistry() {
					let objects = {};

					return {
						get: key => objects[key],
						add: (key, object) => {
							objects[key] = object
						},
						remove: (key) => delete objects[key],
						removeAll: () => {
							objects = {};
						}
					};
				}


				function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {

					// Add unknown glTF extensions to an object's userData.
					for (const name in objectDef.extensions) {
						if (knownExtensions[name] === undefined) {
							object.userData.gltfExtensions = object.userData.gltfExtensions || {};
							object.userData.gltfExtensions[name] = objectDef.extensions[name];
						}

					}

				}


				/**
				 * @param {Object3D|Material|BufferGeometry} object
				 * @param {GLTF.definition} gltfDef
				 */
				function assignExtrasToUserData(object, gltfDef) {

					if (gltfDef.extras !== undefined) {

						if (typeof gltfDef.extras === 'object') {

							Object.assign(object.userData, gltfDef.extras);

						} else {

							console.warn(`THREE.GLTFLoader: Ignoring primitive type .extras, ${gltfDef.extras}`);

						}

					}

				}

				const WEBGL_CONSTANTS = {
					FLOAT: 5126,
					// FLOAT_MAT2: 35674,
					FLOAT_MAT3: 35675,
					FLOAT_MAT4: 35676,
					FLOAT_VEC2: 35664,
					FLOAT_VEC3: 35665,
					FLOAT_VEC4: 35666,
					LINEAR: 9729,
					REPEAT: 10497,
					SAMPLER_2D: 35678,
					POINTS: 0,
					LINES: 1,
					LINE_LOOP: 2,
					LINE_STRIP: 3,
					TRIANGLES: 4,
					TRIANGLE_STRIP: 5,
					TRIANGLE_FAN: 6,
					UNSIGNED_BYTE: 5121,
					UNSIGNED_SHORT: 5123
				};

				const WEBGL_COMPONENT_TYPES = {
					5120: Int8Array,
					5121: Uint8Array,
					5122: Int16Array,
					5123: Uint16Array,
					5125: Uint32Array,
					5126: Float32Array
				};

				const WEBGL_FILTERS = {
					9728: _constants__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
					9729: _constants__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"],
					9984: _constants__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapNearestFilter"],
					9985: _constants__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapNearestFilter"],
					9986: _constants__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapLinearFilter"],
					9987: _constants__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"]
				};

				const WEBGL_WRAPPINGS = {
					33071: _constants__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"],
					33648: _constants__WEBPACK_IMPORTED_MODULE_0__["MirroredRepeatWrapping"],
					10497: _constants__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"]
				};

				const WEBGL_TYPE_SIZES = {
					'SCALAR': 1,
					'VEC2': 2,
					'VEC3': 3,
					'VEC4': 4,
					'MAT2': 4,
					'MAT3': 9,
					'MAT4': 16
				};

				const ATTRIBUTES = {
					POSITION: 'position',
					NORMAL: 'normal',
					TANGENT: 'tangent',
					TEXCOORD_0: 'uv',
					TEXCOORD_1: 'uv2',
					COLOR_0: 'color',
					WEIGHTS_0: 'skinWeight',
					JOINTS_0: 'skinIndex'
				};

				const PATH_PROPERTIES = {
					scale: 'scale',
					translation: 'position',
					rotation: 'quaternion',
					weights: 'morphTargetInfluences'
				};

				const INTERPOLATION = {
					CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
					// keyframe track will be initialized with a default interpolation type, then modified.
					LINEAR: _constants__WEBPACK_IMPORTED_MODULE_0__["InterpolateLinear"],
					STEP: _constants__WEBPACK_IMPORTED_MODULE_0__["InterpolateDiscrete"]
				};

				const ALPHA_MODES = {
					OPAQUE: 'OPAQUE',
					MASK: 'MASK',
					BLEND: 'BLEND'
				};

				/**
				 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
				 */
				function createDefaultMaterial(cache) {

					if (cache.DefaultMaterial === undefined) {

						cache.DefaultMaterial = new _materials_MeshStandardMaterial__WEBPACK_IMPORTED_MODULE_6__["MeshStandardMaterial"]({
							color: 0xFFFFFF,
							emissive: 0x000000,
							metalness: 1,
							roughness: 1,
							transparent: false,
							depthTest: true,
							side: _constants__WEBPACK_IMPORTED_MODULE_0__["FrontSide"]
						});

					}

					return cache.DefaultMaterial;

				}



				/**
				 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
				 *
				 * @param {BufferGeometry} geometry
				 * @param {Array<GLTF.Target>} targets
				 * @param {GLTFParser} parser
				 * @return {Promise<BufferGeometry>}
				 */
				function addMorphTargets(geometry, targets, parser) {

					let hasMorphPosition = false;
					let hasMorphNormal = false;

					for (let i = 0, il = targets.length; i < il; i++) {

						const target = targets[i];

						if (target.POSITION !== undefined) hasMorphPosition = true;
						if (target.NORMAL !== undefined) hasMorphNormal = true;

						if (hasMorphPosition && hasMorphNormal) break;

					}

					if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);

					const pendingPositionAccessors = [];
					const pendingNormalAccessors = [];

					for (let i = 0, il = targets.length; i < il; i++) {

						const target = targets[i];

						if (hasMorphPosition) {

							const pendingAccessor = target.POSITION !== undefined
								? parser.getDependency('accessor', target.POSITION)
								: geometry.attributes.position;

							pendingPositionAccessors.push(pendingAccessor);

						}

						if (hasMorphNormal) {

							const pendingAccessor = target.NORMAL !== undefined
								? parser.getDependency('accessor', target.NORMAL)
								: geometry.attributes.normal;

							pendingNormalAccessors.push(pendingAccessor);

						}

					}

					return Promise.all([
						Promise.all(pendingPositionAccessors),
						Promise.all(pendingNormalAccessors)
					]).then(accessors => {

						const morphPositions = accessors[0];
						const morphNormals = accessors[1];

						if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
						if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
						geometry.morphTargetsRelative = true;

						return geometry;

					});

				}

				/**
				 * @param {Mesh} mesh
				 * @param {GLTF.Mesh} meshDef
				 */
				function updateMorphTargets(mesh, meshDef) {

					mesh.updateMorphTargets();

					if (meshDef.weights !== undefined) {

						for (let i = 0, il = meshDef.weights.length; i < il; i++) {
							mesh.morphTargetInfluences[i] = meshDef.weights[i];
						}

					}

					// .extras has user-defined data, so check that .extras.targetNames is an array.
					if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {

						const { targetNames } = meshDef.extras;

						if (mesh.morphTargetInfluences.length === targetNames.length) {

							mesh.morphTargetDictionary = {};

							for (let i = 0, il = targetNames.length; i < il; i++) {
								mesh.morphTargetDictionary[targetNames[i]] = i;
							}

						} else {

							console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');

						}
					}
				}

				function createAttributesKey(attributes) {
					let attributesKey = '';

					const keys = Object.keys(attributes).sort();

					for (let i = 0, il = keys.length; i < il; i++) {
						attributesKey += `${keys[i]}:${attributes[keys[i]]};`;
					}

					return attributesKey;
				}

				function createPrimitiveKey(primitiveDef) {
					const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
					let geometryKey;

					if (dracoExtension) {
						geometryKey = `draco:${dracoExtension.bufferView}:${dracoExtension.indices}:${createAttributesKey(dracoExtension.attributes)}`;
					} else {
						geometryKey = `${primitiveDef.indices}:${createAttributesKey(primitiveDef.attributes)}:${primitiveDef.mode}`;
					}

					return geometryKey;
				}


				function getNormalizedComponentScale(constructor) {

					// Reference:
					// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

					switch (constructor) {

						case Int8Array:
							return 1 / 127;

						case Uint8Array:
							return 1 / 255;

						case Int16Array:
							return 1 / 32767;

						case Uint16Array:
							return 1 / 65535;

						default:
							throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.');

					}

				}


				function buildNodeHierarchy(nodeId, parentObject, json, parser) {

					const nodeDef = json.nodes[nodeId];
					return parser.getDependency('node', nodeId).then(node => {
						if (nodeDef.skin === undefined) return node;
						// build skeleton here as well

						let skinEntry;

						return parser.getDependency('skin', nodeDef.skin).then(skin => {
							skinEntry = skin;
							const pendingJoints = [];

							for (let i = 0, il = skinEntry.joints.length; i < il; i++) {
								pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
							}
							let pp = Promise.all(pendingJoints);
							return pp.catch(() => { console.log("ddddddddd"); });

						}).then(jointNodes => {
							node.traverse(mesh => {
								if (!mesh.isMesh) return;

								const bones = [];
								const boneInverses = [];

								for (let j = 0, jl = jointNodes.length; j < jl; j++) {
									const jointNode = jointNodes[j];
									if (jointNode) {
										bones.push(jointNode);
										const mat = new _math_Matrix4__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
										if (skinEntry.inverseBindMatrices !== undefined) {
											mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
										}

										boneInverses.push(mat);
									} else {
										console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
									}

								}

								mesh.bind(new _objects_Skeleton__WEBPACK_IMPORTED_MODULE_3__["Skeleton"](bones, boneInverses), mesh.matrixWorld);
							});

							return node;
						});

					}).then(node => {

						// build node hierachy

						parentObject.add(node);
						const pending = [];

						if (nodeDef.children) {
							const { children } = nodeDef;

							for (let i = 0, il = children.length; i < il; i++) {
								const child = children[i];
								pending.push(buildNodeHierarchy(child, node, json, parser));
							}

						}
						return Promise.all(pending);
					});

				}

				/**
				 * @param {BufferGeometry} geometry
				 * @param {GLTF.Primitive} primitiveDef
				 * @param {GLTFParser} parser
				 */
				function computeBounds(geometry, primitiveDef, parser) {

					const { attributes } = primitiveDef;

					const box = new _math_Box3__WEBPACK_IMPORTED_MODULE_1__["Box3"]();

					if (attributes.POSITION !== undefined) {
						const accessor = parser.json.accessors[attributes.POSITION];
						const { min, max } = accessor;

						// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

						if (min !== undefined && max !== undefined) {
							box.set(
								new _math_Vector3__WEBPACK_IMPORTED_MODULE_5__["Vector3"](min[0], min[1], min[2]),
								new _math_Vector3__WEBPACK_IMPORTED_MODULE_5__["Vector3"](max[0], max[1], max[2])
							);
							if (accessor.normalized) {
								const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
								box.min.multiplyScalar(boxScale);
								box.max.multiplyScalar(boxScale);
							}

						} else {
							console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
							return;
						}

					} else {
						return;
					}

					const { targets } = primitiveDef;

					if (targets !== undefined) {

						const maxDisplacement = new _math_Vector3__WEBPACK_IMPORTED_MODULE_5__["Vector3"]();
						const vector = new _math_Vector3__WEBPACK_IMPORTED_MODULE_5__["Vector3"]();

						for (let i = 0, il = targets.length; i < il; i++) {

							const target = targets[i];

							if (target.POSITION !== undefined) {
								const accessor = parser.json.accessors[target.POSITION];
								const { min, max } = accessor;
								// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

								if (min !== undefined && max !== undefined) {
									// we need to get max of absolute components because target weight is [-1,1]
									vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
									vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
									vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));

									if (accessor.normalized) {
										const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
										vector.multiplyScalar(boxScale);
									}

									// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
									// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
									// are used to implement key-frame animations and as such only two are active at a time - this results in very large
									// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
									maxDisplacement.max(vector);

								} else {
									console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
								}

							}

						}

						// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
						box.expandByVector(maxDisplacement);
					}

					geometry.boundingBox = box;

					const sphere = new _math_Sphere__WEBPACK_IMPORTED_MODULE_4__["Sphere"]();

					box.getCenter(sphere.center);
					sphere.radius = box.min.distanceTo(box.max) / 2;

					geometry.boundingSphere = sphere;
				}

				/**
				 * @param {BufferGeometry} geometry
				 * @param {GLTF.Primitive} primitiveDef
				 * @param {GLTFParser} parser
				 * @return {Promise<BufferGeometry>}
				 */
				function addPrimitiveAttributes(geometry, primitiveDef, parser) {

					const { attributes } = primitiveDef;

					const pending = [];
					function assignAttributeAccessor(accessorIndex, attributeName) {

						return parser.getDependency('accessor', accessorIndex)
							.then(accessor => {
								geometry.setAttribute(attributeName, accessor);
							});
					}

					for (const gltfAttributeName in attributes) {
						const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
						// Skip attributes already provided by e.g. Draco extension.
						if (threeAttributeName in geometry.attributes) continue;
						pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
					}

					if (primitiveDef.indices !== undefined && !geometry.index) {
						const accessor = parser.getDependency('accessor', primitiveDef.indices).then(accessor => {
							geometry.setIndex(accessor);
						});

						pending.push(accessor);
					}

					assignExtrasToUserData(geometry, primitiveDef);

					computeBounds(geometry, primitiveDef, parser);

					return Promise.all(pending).then(() =>
						primitiveDef.targets !== undefined
							? addMorphTargets(geometry, primitiveDef.targets, parser)
							: geometry
					);
				}

				/**
				 * @param {BufferGeometry} geometry
				 * @param {Number} drawMode
				 * @return {BufferGeometry}
				 */
				function toTrianglesDrawMode(geometry, drawMode) {
					let index = geometry.getIndex();

					// generate index if not present
					if (index === null) {
						const indices = [];
						const position = geometry.getAttribute('position');
						if (position !== undefined) {
							for (let i = 0; i < position.count; i++) {
								indices.push(i);
							}
							geometry.setIndex(indices);
							index = geometry.getIndex();
						} else {
							console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
							return geometry;
						}
					}

					//

					const numberOfTriangles = index.count - 2;
					const newIndices = [];

					if (drawMode === _constants__WEBPACK_IMPORTED_MODULE_0__["TriangleFanDrawMode"]) {
						// gl.TRIANGLE_FAN
						for (let i = 1; i <= numberOfTriangles; i++) {
							newIndices.push(index.getX(0));
							newIndices.push(index.getX(i));
							newIndices.push(index.getX(i + 1));
						}
					} else {
						// gl.TRIANGLE_STRIP
						for (let i = 0; i < numberOfTriangles; i++) {
							if (i % 2 === 0) {
								newIndices.push(index.getX(i));
								newIndices.push(index.getX(i + 1));
								newIndices.push(index.getX(i + 2));
							} else {
								newIndices.push(index.getX(i + 2));
								newIndices.push(index.getX(i + 1));
								newIndices.push(index.getX(i));
							}
						}
					}

					if ((newIndices.length / 3) !== numberOfTriangles) {
						console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
					}

					// build final geometry

					const newGeometry = geometry.clone();
					newGeometry.setIndex(newIndices);

					return newGeometry;
				}

				/***/
}),

/***/ "./libs/three/loaders/meshopt_decoder.asm.module.js":
/*!**********************************************************!*\
  !*** ./libs/three/loaders/meshopt_decoder.asm.module.js ***!
  \**********************************************************/
/*! exports provided: MeshoptDecoder */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshoptDecoder", function () { return MeshoptDecoder; });
/* harmony import */ var _decoder_base_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./decoder_base.js */ "./libs/three/loaders/decoder_base.js");
				// This file is part of meshoptimizer library and is distributed under the terms of MIT License.
				// Copyright (C) 2016-2020, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)


				var MeshoptDecoder = (function () {
					'use strict';

					var instance = { exports: _decoder_base_js__WEBPACK_IMPORTED_MODULE_0__ };

					function arrayBufferToBase64(buffer) {
						//第一步，将ArrayBuffer转为二进制字符串
						var binary = '';
						var bytes = new Uint8Array(buffer);
						for (var len = bytes.byteLength, i = 0; i < len; i++) {
							binary += String.fromCharCode(bytes[i]);
						}
						//将二进制字符串转为base64字符串
						return window.btoa(binary);
					}

					function base64ToArrayBuffer(base64) {
						const binaryStr = window.atob(base64);
						const byteLength = binaryStr.length;
						const bytes = new Uint8Array(byteLength);
						for (let i = 0; i < byteLength; i++) {
							bytes[i] = binaryStr.charCodeAt(i);
						}
						return bytes.buffer;
					}

					function decode(fun, target, count, size, source, filter) {
						// console.log(`%c======decode Start======`,"color:red;")
						var sbrk = instance.exports.sbrk;
						var count4 = (count + 3) & ~3; // pad for SIMD filter
						var tp = sbrk(count4 * size);
						var sp = sbrk(source.length);

						var heap = new Uint8Array(instance.exports.memory.buffer);
						// let base64 = arrayBufferToBase64(instance.exports.memory.buffer);
						// let buffer = base64ToArrayBuffer(base64);
						// console.log(buffer,instance.exports.memory.buffer+""==buffer+"");

						// console.log( count, heap);
						heap.set(source, sp);
						// console.log( heap);
						// var res = fun(25616, 40140, 2, 105896, 14825);
						var res = fun(tp, count, size, sp, source.length);
						// console.log(`%c======decode End======`,"color:red;")
						if (res == 0 && filter) {
							filter(tp, count4, size);
						}
						target.set(heap.subarray(tp, tp + count * size));
						sbrk(tp - sbrk(0));
						if (res != 0) {
							throw new Error('Malformed buffer data: ' + res);
						}
					}

					var filters = {
						// legacy index-based enums for glTF
						0: '',
						1: 'meshopt_decodeFilterOct',
						2: 'meshopt_decodeFilterQuat',
						3: 'meshopt_decodeFilterExp',
						// string-based enums for glTF
						NONE: '',
						OCTAHEDRAL: 'meshopt_decodeFilterOct',
						QUATERNION: 'meshopt_decodeFilterQuat',
						EXPONENTIAL: 'meshopt_decodeFilterExp',
					};

					var decoders = {
						// legacy index-based enums for glTF
						0: 'meshopt_decodeVertexBuffer',
						1: 'meshopt_decodeIndexBuffer',
						2: 'meshopt_decodeIndexSequence',
						// string-based enums for glTF
						ATTRIBUTES: 'meshopt_decodeVertexBuffer',
						TRIANGLES: 'meshopt_decodeIndexBuffer',
						INDICES: 'meshopt_decodeIndexSequence',
					};

					return {
						ready: Promise.resolve(),
						supported: true,
						decodeVertexBuffer: function (target, count, size, source, filter) {
							decode(
								instance.exports.meshopt_decodeVertexBuffer,
								target,
								count,
								size,
								source,
								instance.exports[filters[filter]],
							);
						},
						decodeIndexBuffer: function (target, count, size, source) {
							decode(
								instance.exports.meshopt_decodeIndexBuffer,
								target,
								count,
								size,
								source,
							);
						},
						decodeIndexSequence: function (target, count, size, source) {
							decode(
								instance.exports.meshopt_decodeIndexSequence,
								target,
								count,
								size,
								source,
							);
						},
						decodeGltfBuffer: function (target, count, size, source, mode, filter) {
							decode(
								instance.exports[decoders[mode]],
								target,
								count,
								size,
								source,
								instance.exports[filters[filter]],
							);
						},
					};
				})();




				/***/
}),

/***/ "./libs/three/materials/LineBasicMaterial.js":
/*!***************************************************!*\
  !*** ./libs/three/materials/LineBasicMaterial.js ***!
  \***************************************************/
/*! exports provided: LineBasicMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function () { return LineBasicMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "./libs/three/materials/Material.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "./libs/three/math/Color.js");



				/**
				 * parameters = {
				 *  color: <hex>,
				 *  opacity: <float>,
				 *
				 *  linewidth: <float>,
				 *  linecap: "round",
				 *  linejoin: "round"
				 * }
				 */

				class LineBasicMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {
					constructor(parameters) {
						super();

						this.type = 'LineBasicMaterial';

						this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"](0xffffff);

						this.linewidth = 1;
						this.linecap = 'round';
						this.linejoin = 'round';

						this.setValues(parameters);
					}

					copy(source) {
						super.copy(source);

						this.color.copy(source.color);

						this.linewidth = source.linewidth;
						this.linecap = source.linecap;
						this.linejoin = source.linejoin;

						return this;
					}
				}

				LineBasicMaterial.prototype.isLineBasicMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/Material.js":
/*!******************************************!*\
  !*** ./libs/three/materials/Material.js ***!
  \******************************************/
/*! exports provided: Material */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function () { return Material; });
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher.js */ "./libs/three/core/EventDispatcher.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");




				let materialId = 0;

				class Material extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"] {
					constructor() {
						super();

						Object.defineProperty(this, 'id', { value: materialId++ });

						this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["generateUUID"]();

						this.name = '';
						this.type = 'Material';

						this.fog = true;

						this.blending = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NormalBlending"];
						this.side = _constants_js__WEBPACK_IMPORTED_MODULE_1__["FrontSide"];
						this.vertexColors = false;

						this.opacity = 1;
						this.format = _constants_js__WEBPACK_IMPORTED_MODULE_1__["RGBAFormat"];
						this.transparent = false;

						this.blendSrc = _constants_js__WEBPACK_IMPORTED_MODULE_1__["SrcAlphaFactor"];
						this.blendDst = _constants_js__WEBPACK_IMPORTED_MODULE_1__["OneMinusSrcAlphaFactor"];
						this.blendEquation = _constants_js__WEBPACK_IMPORTED_MODULE_1__["AddEquation"];
						this.blendSrcAlpha = null;
						this.blendDstAlpha = null;
						this.blendEquationAlpha = null;

						this.depthFunc = _constants_js__WEBPACK_IMPORTED_MODULE_1__["LessEqualDepth"];
						this.depthTest = true;
						this.depthWrite = true;

						this.stencilWriteMask = 0xff;
						this.stencilFunc = _constants_js__WEBPACK_IMPORTED_MODULE_1__["AlwaysStencilFunc"];
						this.stencilRef = 0;
						this.stencilFuncMask = 0xff;
						this.stencilFail = _constants_js__WEBPACK_IMPORTED_MODULE_1__["KeepStencilOp"];
						this.stencilZFail = _constants_js__WEBPACK_IMPORTED_MODULE_1__["KeepStencilOp"];
						this.stencilZPass = _constants_js__WEBPACK_IMPORTED_MODULE_1__["KeepStencilOp"];
						this.stencilWrite = false;

						this.clippingPlanes = null;
						this.clipIntersection = false;
						this.clipShadows = false;

						this.shadowSide = null;

						this.colorWrite = true;

						this.precision = null; // override the renderer's default precision for this material

						this.polygonOffset = false;
						this.polygonOffsetFactor = 0;
						this.polygonOffsetUnits = 0;

						this.dithering = false;

						this.alphaToCoverage = false;
						this.premultipliedAlpha = false;

						this.visible = true;

						this.toneMapped = true;

						this.userData = {};

						this.version = 0;

						this._alphaTest = 0;
					}

					get alphaTest() {
						return this._alphaTest;
					}

					set alphaTest(value) {
						if (this._alphaTest > 0 !== value > 0) {
							this.version++;
						}

						this._alphaTest = value;
					}

					onBuild(/* shaderobject, renderer */) { }

					onBeforeRender(/* renderer, scene, camera, geometry, object, group */) { }

					onBeforeCompile(/* shaderobject, renderer */) { }

					customProgramCacheKey() {
						return this.onBeforeCompile.toString();
					}

					setValues(values) {
						if (values === undefined) return;

						for (const key in values) {
							const newValue = values[key];

							if (newValue === undefined) {
								console.warn("THREE.Material: '" + key + "' parameter is undefined.");
								continue;
							}

							// for backward compatability if shading is set in the constructor
							if (key === 'shading') {
								console.warn(
									'THREE.' +
									this.type +
									': .shading has been removed. Use the boolean .flatShading instead.'
								);
								this.flatShading = newValue === _constants_js__WEBPACK_IMPORTED_MODULE_1__["FlatShading"] ? true : false;
								continue;
							}

							const currentValue = this[key];

							if (currentValue === undefined) {
								console.warn(
									'THREE.' +
									this.type +
									": '" +
									key +
									"' is not a property of this material."
								);
								continue;
							}

							if (currentValue && currentValue.isColor) {
								currentValue.set(newValue);
							} else if (
								currentValue &&
								currentValue.isVector3 &&
								(newValue && newValue.isVector3)
							) {
								currentValue.copy(newValue);
							} else {
								this[key] = newValue;
							}
						}
					}

					toJSON(meta) {
						const isRoot = meta === undefined || typeof meta === 'string';

						if (isRoot) {
							meta = {
								textures: {},
								images: {}
							};
						}

						const data = {
							metadata: {
								version: 4.5,
								type: 'Material',
								generator: 'Material.toJSON'
							}
						};

						// standard Material serialization
						data.uuid = this.uuid;
						data.type = this.type;

						if (this.name !== '') data.name = this.name;

						if (this.color && this.color.isColor) data.color = this.color.getHex();

						if (this.roughness !== undefined) data.roughness = this.roughness;
						if (this.metalness !== undefined) data.metalness = this.metalness;

						if (this.sheen !== undefined) data.sheen = this.sheen;
						if (this.sheenColor && this.sheenColor.isColor)
							data.sheenColor = this.sheenColor.getHex();
						if (this.sheenRoughness !== undefined)
							data.sheenRoughness = this.sheenRoughness;
						if (this.emissive && this.emissive.isColor)
							data.emissive = this.emissive.getHex();
						if (this.emissiveIntensity && this.emissiveIntensity !== 1)
							data.emissiveIntensity = this.emissiveIntensity;

						if (this.specular && this.specular.isColor)
							data.specular = this.specular.getHex();
						if (this.specularIntensity !== undefined)
							data.specularIntensity = this.specularIntensity;
						if (this.specularColor && this.specularColor.isColor)
							data.specularColor = this.specularColor.getHex();
						if (this.shininess !== undefined) data.shininess = this.shininess;
						if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
						if (this.clearcoatRoughness !== undefined)
							data.clearcoatRoughness = this.clearcoatRoughness;

						if (this.clearcoatMap && this.clearcoatMap.isTexture) {
							data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
						}

						if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
							data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
						}

						if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
							data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
							data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
						}

						if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
						if (this.matcap && this.matcap.isTexture)
							data.matcap = this.matcap.toJSON(meta).uuid;
						if (this.alphaMap && this.alphaMap.isTexture)
							data.alphaMap = this.alphaMap.toJSON(meta).uuid;

						if (this.lightMap && this.lightMap.isTexture) {
							data.lightMap = this.lightMap.toJSON(meta).uuid;
							data.lightMapIntensity = this.lightMapIntensity;
						}

						if (this.aoMap && this.aoMap.isTexture) {
							data.aoMap = this.aoMap.toJSON(meta).uuid;
							data.aoMapIntensity = this.aoMapIntensity;
						}

						if (this.bumpMap && this.bumpMap.isTexture) {
							data.bumpMap = this.bumpMap.toJSON(meta).uuid;
							data.bumpScale = this.bumpScale;
						}

						if (this.normalMap && this.normalMap.isTexture) {
							data.normalMap = this.normalMap.toJSON(meta).uuid;
							data.normalMapType = this.normalMapType;
							data.normalScale = this.normalScale.toArray();
						}

						if (this.displacementMap && this.displacementMap.isTexture) {
							data.displacementMap = this.displacementMap.toJSON(meta).uuid;
							data.displacementScale = this.displacementScale;
							data.displacementBias = this.displacementBias;
						}

						if (this.roughnessMap && this.roughnessMap.isTexture)
							data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
						if (this.metalnessMap && this.metalnessMap.isTexture)
							data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;

						if (this.emissiveMap && this.emissiveMap.isTexture)
							data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
						if (this.specularMap && this.specularMap.isTexture)
							data.specularMap = this.specularMap.toJSON(meta).uuid;
						if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
							data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
						if (this.specularColorMap && this.specularColorMap.isTexture)
							data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;

						if (this.envMap && this.envMap.isTexture) {
							data.envMap = this.envMap.toJSON(meta).uuid;

							if (this.combine !== undefined) data.combine = this.combine;
						}

						if (this.envMapIntensity !== undefined)
							data.envMapIntensity = this.envMapIntensity;
						if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
						if (this.refractionRatio !== undefined)
							data.refractionRatio = this.refractionRatio;

						if (this.gradientMap && this.gradientMap.isTexture) {
							data.gradientMap = this.gradientMap.toJSON(meta).uuid;
						}

						if (this.transmission !== undefined) data.transmission = this.transmission;
						if (this.transmissionMap && this.transmissionMap.isTexture)
							data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
						if (this.thickness !== undefined) data.thickness = this.thickness;
						if (this.thicknessMap && this.thicknessMap.isTexture)
							data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
						if (this.attenuationDistance !== undefined)
							data.attenuationDistance = this.attenuationDistance;
						if (this.attenuationColor !== undefined)
							data.attenuationColor = this.attenuationColor.getHex();

						if (this.size !== undefined) data.size = this.size;
						if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
						if (this.sizeAttenuation !== undefined)
							data.sizeAttenuation = this.sizeAttenuation;

						if (this.blending !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["NormalBlending"]) data.blending = this.blending;
						if (this.side !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["FrontSide"]) data.side = this.side;
						if (this.vertexColors) data.vertexColors = true;

						if (this.opacity < 1) data.opacity = this.opacity;
						if (this.format !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["RGBAFormat"]) data.format = this.format;
						if (this.transparent === true) data.transparent = this.transparent;

						data.depthFunc = this.depthFunc;
						data.depthTest = this.depthTest;
						data.depthWrite = this.depthWrite;
						data.colorWrite = this.colorWrite;

						data.stencilWrite = this.stencilWrite;
						data.stencilWriteMask = this.stencilWriteMask;
						data.stencilFunc = this.stencilFunc;
						data.stencilRef = this.stencilRef;
						data.stencilFuncMask = this.stencilFuncMask;
						data.stencilFail = this.stencilFail;
						data.stencilZFail = this.stencilZFail;
						data.stencilZPass = this.stencilZPass;

						// rotation (SpriteMaterial)
						if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;

						if (this.polygonOffset === true) data.polygonOffset = true;
						if (this.polygonOffsetFactor !== 0)
							data.polygonOffsetFactor = this.polygonOffsetFactor;
						if (this.polygonOffsetUnits !== 0)
							data.polygonOffsetUnits = this.polygonOffsetUnits;

						if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
						if (this.dashSize !== undefined) data.dashSize = this.dashSize;
						if (this.gapSize !== undefined) data.gapSize = this.gapSize;
						if (this.scale !== undefined) data.scale = this.scale;

						if (this.dithering === true) data.dithering = true;

						if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
						if (this.alphaToCoverage === true)
							data.alphaToCoverage = this.alphaToCoverage;
						if (this.premultipliedAlpha === true)
							data.premultipliedAlpha = this.premultipliedAlpha;

						if (this.wireframe === true) data.wireframe = this.wireframe;
						if (this.wireframeLinewidth > 1)
							data.wireframeLinewidth = this.wireframeLinewidth;
						if (this.wireframeLinecap !== 'round')
							data.wireframeLinecap = this.wireframeLinecap;
						if (this.wireframeLinejoin !== 'round')
							data.wireframeLinejoin = this.wireframeLinejoin;

						if (this.flatShading === true) data.flatShading = this.flatShading;

						if (this.visible === false) data.visible = false;

						if (this.toneMapped === false) data.toneMapped = false;

						if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData;

						// TODO: Copied from Object3D.toJSON

						function extractFromCache(cache) {
							const values = [];

							for (const key in cache) {
								const data = cache[key];
								delete data.metadata;
								values.push(data);
							}

							return values;
						}

						if (isRoot) {
							const textures = extractFromCache(meta.textures);
							const images = extractFromCache(meta.images);

							if (textures.length > 0) data.textures = textures;
							if (images.length > 0) data.images = images;
						}

						return data;
					}

					clone() {
						return new this.constructor().copy(this);
					}

					copy(source) {
						this.name = source.name;

						this.fog = source.fog;

						this.blending = source.blending;
						this.side = source.side;
						this.vertexColors = source.vertexColors;

						this.opacity = source.opacity;
						this.format = source.format;
						this.transparent = source.transparent;

						this.blendSrc = source.blendSrc;
						this.blendDst = source.blendDst;
						this.blendEquation = source.blendEquation;
						this.blendSrcAlpha = source.blendSrcAlpha;
						this.blendDstAlpha = source.blendDstAlpha;
						this.blendEquationAlpha = source.blendEquationAlpha;

						this.depthFunc = source.depthFunc;
						this.depthTest = source.depthTest;
						this.depthWrite = source.depthWrite;

						this.stencilWriteMask = source.stencilWriteMask;
						this.stencilFunc = source.stencilFunc;
						this.stencilRef = source.stencilRef;
						this.stencilFuncMask = source.stencilFuncMask;
						this.stencilFail = source.stencilFail;
						this.stencilZFail = source.stencilZFail;
						this.stencilZPass = source.stencilZPass;
						this.stencilWrite = source.stencilWrite;

						const srcPlanes = source.clippingPlanes;
						let dstPlanes = null;

						if (srcPlanes !== null) {
							const n = srcPlanes.length;
							dstPlanes = new Array(n);

							for (let i = 0; i !== n; ++i) {
								dstPlanes[i] = srcPlanes[i].clone();
							}
						}

						this.clippingPlanes = dstPlanes;
						this.clipIntersection = source.clipIntersection;
						this.clipShadows = source.clipShadows;

						this.shadowSide = source.shadowSide;

						this.colorWrite = source.colorWrite;

						this.precision = source.precision;

						this.polygonOffset = source.polygonOffset;
						this.polygonOffsetFactor = source.polygonOffsetFactor;
						this.polygonOffsetUnits = source.polygonOffsetUnits;

						this.dithering = source.dithering;

						this.alphaTest = source.alphaTest;
						this.alphaToCoverage = source.alphaToCoverage;
						this.premultipliedAlpha = source.premultipliedAlpha;

						this.visible = source.visible;

						this.toneMapped = source.toneMapped;

						this.userData = JSON.parse(JSON.stringify(source.userData));

						return this;
					}

					dispose() {
						this.dispatchEvent({ type: 'dispose' });
					}

					set needsUpdate(value) {
						if (value === true) this.version++;
					}
				}

				Material.prototype.isMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/MeshBasicMaterial.js":
/*!***************************************************!*\
  !*** ./libs/three/materials/MeshBasicMaterial.js ***!
  \***************************************************/
/*! exports provided: MeshBasicMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function () { return MeshBasicMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "./libs/three/materials/Material.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Color.js */ "./libs/three/math/Color.js");




				/**
				 * parameters = {
				 *  color: <hex>,
				 *  opacity: <float>,
				 *  map: new THREE.Texture( <Image> ),
				 *
				 *  lightMap: new THREE.Texture( <Image> ),
				 *  lightMapIntensity: <float>
				 *
				 *  aoMap: new THREE.Texture( <Image> ),
				 *  aoMapIntensity: <float>
				 *
				 *  specularMap: new THREE.Texture( <Image> ),
				 *
				 *  alphaMap: new THREE.Texture( <Image> ),
				 *
				 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
				 *  combine: THREE.Multiply,
				 *  reflectivity: <float>,
				 *  refractionRatio: <float>,
				 *
				 *  depthTest: <bool>,
				 *  depthWrite: <bool>,
				 *
				 *  wireframe: <boolean>,
				 *  wireframeLinewidth: <float>,
				 * }
				 */

				class MeshBasicMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {
					constructor(parameters) {
						super();

						this.type = 'MeshBasicMaterial';

						this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"](0xffffff); // emissive

						this.map = null;

						this.lightMap = null;
						this.lightMapIntensity = 1.0;

						this.aoMap = null;
						this.aoMapIntensity = 1.0;

						this.specularMap = null;

						this.alphaMap = null;

						this.envMap = null;
						this.combine = _constants_js__WEBPACK_IMPORTED_MODULE_1__["MultiplyOperation"];
						this.reflectivity = 1;
						this.refractionRatio = 0.98;

						this.wireframe = false;
						this.wireframeLinewidth = 1;
						this.wireframeLinecap = 'round';
						this.wireframeLinejoin = 'round';

						this.setValues(parameters);
					}

					copy(source) {
						super.copy(source);

						this.color.copy(source.color);

						this.map = source.map;

						this.lightMap = source.lightMap;
						this.lightMapIntensity = source.lightMapIntensity;

						this.aoMap = source.aoMap;
						this.aoMapIntensity = source.aoMapIntensity;

						this.specularMap = source.specularMap;

						this.alphaMap = source.alphaMap;

						this.envMap = source.envMap;
						this.combine = source.combine;
						this.reflectivity = source.reflectivity;
						this.refractionRatio = source.refractionRatio;

						this.wireframe = source.wireframe;
						this.wireframeLinewidth = source.wireframeLinewidth;
						this.wireframeLinecap = source.wireframeLinecap;
						this.wireframeLinejoin = source.wireframeLinejoin;

						return this;
					}
				}

				MeshBasicMaterial.prototype.isMeshBasicMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/MeshDepthMaterial.js":
/*!***************************************************!*\
  !*** ./libs/three/materials/MeshDepthMaterial.js ***!
  \***************************************************/
/*! exports provided: MeshDepthMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function () { return MeshDepthMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "./libs/three/materials/Material.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");



				/**
				 * parameters = {
				 *
				 *  opacity: <float>,
				 *
				 *  map: new THREE.Texture( <Image> ),
				 *
				 *  alphaMap: new THREE.Texture( <Image> ),
				 *
				 *  displacementMap: new THREE.Texture( <Image> ),
				 *  displacementScale: <float>,
				 *  displacementBias: <float>,
				 *
				 *  wireframe: <boolean>,
				 *  wireframeLinewidth: <float>
				 * }
				 */

				class MeshDepthMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {
					constructor(parameters) {
						super();

						this.type = 'MeshDepthMaterial';

						this.depthPacking = _constants_js__WEBPACK_IMPORTED_MODULE_1__["BasicDepthPacking"];

						this.map = null;

						this.alphaMap = null;

						this.displacementMap = null;
						this.displacementScale = 1;
						this.displacementBias = 0;

						this.wireframe = false;
						this.wireframeLinewidth = 1;

						this.fog = false;

						this.setValues(parameters);
					}

					copy(source) {
						super.copy(source);

						this.depthPacking = source.depthPacking;

						this.map = source.map;

						this.alphaMap = source.alphaMap;

						this.displacementMap = source.displacementMap;
						this.displacementScale = source.displacementScale;
						this.displacementBias = source.displacementBias;

						this.wireframe = source.wireframe;
						this.wireframeLinewidth = source.wireframeLinewidth;

						return this;
					}
				}

				MeshDepthMaterial.prototype.isMeshDepthMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/MeshDistanceMaterial.js":
/*!******************************************************!*\
  !*** ./libs/three/materials/MeshDistanceMaterial.js ***!
  \******************************************************/
/*! exports provided: MeshDistanceMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function () { return MeshDistanceMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "./libs/three/materials/Material.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");



				/**
				 * parameters = {
				 *
				 *  referencePosition: <float>,
				 *  nearDistance: <float>,
				 *  farDistance: <float>,
				 *
				 *  map: new THREE.Texture( <Image> ),
				 *
				 *  alphaMap: new THREE.Texture( <Image> ),
				 *
				 *  displacementMap: new THREE.Texture( <Image> ),
				 *  displacementScale: <float>,
				 *  displacementBias: <float>
				 *
				 * }
				 */

				class MeshDistanceMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {
					constructor(parameters) {
						super();

						this.type = 'MeshDistanceMaterial';

						this.referencePosition = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
						this.nearDistance = 1;
						this.farDistance = 1000;

						this.map = null;

						this.alphaMap = null;

						this.displacementMap = null;
						this.displacementScale = 1;
						this.displacementBias = 0;

						this.fog = false;

						this.setValues(parameters);
					}

					copy(source) {
						super.copy(source);

						this.referencePosition.copy(source.referencePosition);
						this.nearDistance = source.nearDistance;
						this.farDistance = source.farDistance;

						this.map = source.map;

						this.alphaMap = source.alphaMap;

						this.displacementMap = source.displacementMap;
						this.displacementScale = source.displacementScale;
						this.displacementBias = source.displacementBias;

						return this;
					}
				}

				MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/MeshPhysicalMaterial.js":
/*!******************************************************!*\
  !*** ./libs/three/materials/MeshPhysicalMaterial.js ***!
  \******************************************************/
/*! exports provided: MeshPhysicalMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function () { return MeshPhysicalMaterial; });
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _MeshStandardMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MeshStandardMaterial.js */ "./libs/three/materials/MeshStandardMaterial.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Color.js */ "./libs/three/math/Color.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");





				/**
				 * parameters = {
				 *  clearcoat: <float>,
				 *  clearcoatMap: new THREE.Texture( <Image> ),
				 *  clearcoatRoughness: <float>,
				 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
				 *  clearcoatNormalScale: <Vector2>,
				 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
				 *
				 *  ior: <float>,
				 *  reflectivity: <float>,
				 *
				 *  sheen: <float>,
				 *  sheenColor: <Color>,
				 *  sheenColorMap: new THREE.Texture( <Image> ),
				 *  sheenRoughness: <float>,
				 *  sheenRoughnessMap: new THREE.Texture( <Image> ),
				 *
				 *  transmission: <float>,
				 *  transmissionMap: new THREE.Texture( <Image> ),
				 *
				 *  thickness: <float>,
				 *  thicknessMap: new THREE.Texture( <Image> ),
				 *  attenuationDistance: <float>,
				 *  attenuationColor: <Color>,
				 *
				 *  specularIntensity: <float>,
				 *  specularIntensityMap: new THREE.Texture( <Image> ),
				 *  specularColor: <Color>,
				 *  specularColorMap: new THREE.Texture( <Image> )
				 * }
				 */

				class MeshPhysicalMaterial extends _MeshStandardMaterial_js__WEBPACK_IMPORTED_MODULE_1__["MeshStandardMaterial"] {
					constructor(parameters) {
						super();

						this.defines = {
							STANDARD: '',
							PHYSICAL: ''
						};

						this.type = 'MeshPhysicalMaterial';

						this.clearcoatMap = null;
						this.clearcoatRoughness = 0.0;
						this.clearcoatRoughnessMap = null;
						this.clearcoatNormalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1, 1);
						this.clearcoatNormalMap = null;

						this.ior = 1.5;

						Object.defineProperty(this, 'reflectivity', {
							get: function () {
								return _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["clamp"]((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
							},
							set: function (reflectivity) {
								this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
							}
						});

						this.sheenColor = new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"](0x000000);
						this.sheenColorMap = null;
						this.sheenRoughness = 1.0;
						this.sheenRoughnessMap = null;

						this.transmissionMap = null;

						this.thickness = 0.01;
						this.thicknessMap = null;
						this.attenuationDistance = 0.0;
						this.attenuationColor = new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"](1, 1, 1);

						this.specularIntensity = 1.0;
						this.specularIntensityMap = null;
						this.specularColor = new _math_Color_js__WEBPACK_IMPORTED_MODULE_2__["Color"](1, 1, 1);
						this.specularColorMap = null;

						this._sheen = 0.0;
						this._clearcoat = 0;
						this._transmission = 0;

						this.setValues(parameters);
					}

					get sheen() {
						return this._sheen;
					}

					set sheen(value) {
						if (this._sheen > 0 !== value > 0) {
							this.version++;
						}

						this._sheen = value;
					}

					get clearcoat() {
						return this._clearcoat;
					}

					set clearcoat(value) {
						if (this._clearcoat > 0 !== value > 0) {
							this.version++;
						}

						this._clearcoat = value;
					}

					get transmission() {
						return this._transmission;
					}

					set transmission(value) {
						if (this._transmission > 0 !== value > 0) {
							this.version++;
						}

						this._transmission = value;
					}

					copy(source) {
						super.copy(source);

						this.defines = {
							STANDARD: '',
							PHYSICAL: ''
						};

						this.clearcoat = source.clearcoat;
						this.clearcoatMap = source.clearcoatMap;
						this.clearcoatRoughness = source.clearcoatRoughness;
						this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
						this.clearcoatNormalMap = source.clearcoatNormalMap;
						this.clearcoatNormalScale.copy(source.clearcoatNormalScale);

						this.ior = source.ior;

						this.sheen = source.sheen;
						this.sheenColor.copy(source.sheenColor);
						this.sheenColorMap = source.sheenColorMap;
						this.sheenRoughness = source.sheenRoughness;
						this.sheenRoughnessMap = source.sheenRoughnessMap;

						this.transmission = source.transmission;
						this.transmissionMap = source.transmissionMap;

						this.thickness = source.thickness;
						this.thicknessMap = source.thicknessMap;
						this.attenuationDistance = source.attenuationDistance;
						this.attenuationColor.copy(source.attenuationColor);

						this.specularIntensity = source.specularIntensity;
						this.specularIntensityMap = source.specularIntensityMap;
						this.specularColor.copy(source.specularColor);
						this.specularColorMap = source.specularColorMap;

						return this;
					}
				}

				MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/MeshStandardMaterial.js":
/*!******************************************************!*\
  !*** ./libs/three/materials/MeshStandardMaterial.js ***!
  \******************************************************/
/*! exports provided: MeshStandardMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function () { return MeshStandardMaterial; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Material.js */ "./libs/three/materials/Material.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Color.js */ "./libs/three/math/Color.js");





				/**
				 * parameters = {
				 *  color: <hex>,
				 *  roughness: <float>,
				 *  metalness: <float>,
				 *  opacity: <float>,
				 *
				 *  map: new THREE.Texture( <Image> ),
				 *
				 *  lightMap: new THREE.Texture( <Image> ),
				 *  lightMapIntensity: <float>
				 *
				 *  aoMap: new THREE.Texture( <Image> ),
				 *  aoMapIntensity: <float>
				 *
				 *  emissive: <hex>,
				 *  emissiveIntensity: <float>
				 *  emissiveMap: new THREE.Texture( <Image> ),
				 *
				 *  bumpMap: new THREE.Texture( <Image> ),
				 *  bumpScale: <float>,
				 *
				 *  normalMap: new THREE.Texture( <Image> ),
				 *  normalMapType: THREE.TangentSpaceNormalMap,
				 *  normalScale: <Vector2>,
				 *
				 *  displacementMap: new THREE.Texture( <Image> ),
				 *  displacementScale: <float>,
				 *  displacementBias: <float>,
				 *
				 *  roughnessMap: new THREE.Texture( <Image> ),
				 *
				 *  metalnessMap: new THREE.Texture( <Image> ),
				 *
				 *  alphaMap: new THREE.Texture( <Image> ),
				 *
				 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
				 *  envMapIntensity: <float>
				 *
				 *  refractionRatio: <float>,
				 *
				 *  wireframe: <boolean>,
				 *  wireframeLinewidth: <float>,
				 *
				 *  flatShading: <bool>
				 * }
				 */

				class MeshStandardMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_1__["Material"] {
					constructor(parameters) {
						super();

						this.defines = { STANDARD: '' };

						this.type = 'MeshStandardMaterial';

						this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"](0xffffff); // diffuse
						this.roughness = 1.0;
						this.metalness = 0.0;

						this.map = null;

						this.lightMap = null;
						this.lightMapIntensity = 1.0;

						this.aoMap = null;
						this.aoMapIntensity = 1.0;

						this.emissive = new _math_Color_js__WEBPACK_IMPORTED_MODULE_3__["Color"](0x000000);
						this.emissiveIntensity = 1.0;
						this.emissiveMap = null;

						this.bumpMap = null;
						this.bumpScale = 1;

						this.normalMap = null;
						this.normalMapType = _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"];
						this.normalScale = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](1, 1);

						this.displacementMap = null;
						this.displacementScale = 1;
						this.displacementBias = 0;

						this.roughnessMap = null;

						this.metalnessMap = null;

						this.alphaMap = null;

						this.envMap = null;
						this.envMapIntensity = 1.0;

						this.refractionRatio = 0.98;

						this.wireframe = false;
						this.wireframeLinewidth = 1;
						this.wireframeLinecap = 'round';
						this.wireframeLinejoin = 'round';

						this.flatShading = false;

						this.setValues(parameters);
					}

					copy(source) {
						super.copy(source);

						this.defines = { STANDARD: '' };

						this.color.copy(source.color);
						this.roughness = source.roughness;
						this.metalness = source.metalness;

						this.map = source.map;

						this.lightMap = source.lightMap;
						this.lightMapIntensity = source.lightMapIntensity;

						this.aoMap = source.aoMap;
						this.aoMapIntensity = source.aoMapIntensity;

						this.emissive.copy(source.emissive);
						this.emissiveMap = source.emissiveMap;
						this.emissiveIntensity = source.emissiveIntensity;

						this.bumpMap = source.bumpMap;
						this.bumpScale = source.bumpScale;

						this.normalMap = source.normalMap;
						this.normalMapType = source.normalMapType;
						this.normalScale.copy(source.normalScale);

						this.displacementMap = source.displacementMap;
						this.displacementScale = source.displacementScale;
						this.displacementBias = source.displacementBias;

						this.roughnessMap = source.roughnessMap;

						this.metalnessMap = source.metalnessMap;

						this.alphaMap = source.alphaMap;

						this.envMap = source.envMap;
						this.envMapIntensity = source.envMapIntensity;

						this.refractionRatio = source.refractionRatio;

						this.wireframe = source.wireframe;
						this.wireframeLinewidth = source.wireframeLinewidth;
						this.wireframeLinecap = source.wireframeLinecap;
						this.wireframeLinejoin = source.wireframeLinejoin;

						this.flatShading = source.flatShading;

						return this;
					}
				}

				MeshStandardMaterial.prototype.isMeshStandardMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/PointsMaterial.js":
/*!************************************************!*\
  !*** ./libs/three/materials/PointsMaterial.js ***!
  \************************************************/
/*! exports provided: PointsMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function () { return PointsMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "./libs/three/materials/Material.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Color.js */ "./libs/three/math/Color.js");



				/**
				 * parameters = {
				 *  color: <hex>,
				 *  opacity: <float>,
				 *  map: new THREE.Texture( <Image> ),
				 *  alphaMap: new THREE.Texture( <Image> ),
				 *
				 *  size: <float>,
				 *  sizeAttenuation: <bool>
				 *
				 * }
				 */

				class PointsMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {
					constructor(parameters) {
						super();

						this.type = 'PointsMaterial';

						this.color = new _math_Color_js__WEBPACK_IMPORTED_MODULE_1__["Color"](0xffffff);

						this.map = null;

						this.alphaMap = null;

						this.size = 1;
						this.sizeAttenuation = true;

						this.setValues(parameters);
					}

					copy(source) {
						super.copy(source);

						this.color.copy(source.color);

						this.map = source.map;

						this.alphaMap = source.alphaMap;

						this.size = source.size;
						this.sizeAttenuation = source.sizeAttenuation;

						return this;
					}
				}

				PointsMaterial.prototype.isPointsMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/RawShaderMaterial.js":
/*!***************************************************!*\
  !*** ./libs/three/materials/RawShaderMaterial.js ***!
  \***************************************************/
/*! exports provided: RawShaderMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function () { return RawShaderMaterial; });
/* harmony import */ var _ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderMaterial.js */ "./libs/three/materials/ShaderMaterial.js");


				class RawShaderMaterial extends _ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"] {
					constructor(parameters) {
						super(parameters);

						this.type = 'RawShaderMaterial';
					}
				}

				RawShaderMaterial.prototype.isRawShaderMaterial = true;




				/***/
}),

/***/ "./libs/three/materials/ShaderMaterial.js":
/*!************************************************!*\
  !*** ./libs/three/materials/ShaderMaterial.js ***!
  \************************************************/
/*! exports provided: ShaderMaterial */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function () { return ShaderMaterial; });
/* harmony import */ var _Material_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Material.js */ "./libs/three/materials/Material.js");
/* harmony import */ var _renderers_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderers/shaders/UniformsUtils.js */ "./libs/three/renderers/shaders/UniformsUtils.js");
/* harmony import */ var _renderers_shaders_ShaderChunk_default_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderers/shaders/ShaderChunk/default_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/default_vertex.glsl.js");
/* harmony import */ var _renderers_shaders_ShaderChunk_default_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderers/shaders/ShaderChunk/default_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/default_fragment.glsl.js");






				/**
				 * parameters = {
				 *  defines: { "label" : "value" },
				 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
				 *
				 *  fragmentShader: <string>,
				 *  vertexShader: <string>,
				 *
				 *  wireframe: <boolean>,
				 *  wireframeLinewidth: <float>,
				 *
				 *  lights: <bool>
				 * }
				 */

				class ShaderMaterial extends _Material_js__WEBPACK_IMPORTED_MODULE_0__["Material"] {
					constructor(parameters) {
						super();

						this.type = 'ShaderMaterial';

						this.defines = {};
						this.uniforms = {};

						this.vertexShader = _renderers_shaders_ShaderChunk_default_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_2__["default"];
						this.fragmentShader = _renderers_shaders_ShaderChunk_default_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_3__["default"];

						this.linewidth = 1;

						this.wireframe = false;
						this.wireframeLinewidth = 1;

						this.fog = false; // set to use scene fog
						this.lights = false; // set to use scene lights
						this.clipping = false; // set to use user-defined clipping planes

						this.extensions = {
							derivatives: false, // set to use derivatives
							fragDepth: false, // set to use fragment depth values
							drawBuffers: false, // set to use draw buffers
							shaderTextureLOD: false // set to use shader texture LOD
						};

						// When rendered geometry doesn't include these attributes but the material does,
						// use these default values in WebGL. This avoids errors when buffer data is missing.
						this.defaultAttributeValues = {
							color: [1, 1, 1],
							uv: [0, 0],
							uv2: [0, 0]
						};

						this.index0AttributeName = undefined;
						this.uniformsNeedUpdate = false;

						this.glslVersion = null;

						if (parameters !== undefined) {
							if (parameters.attributes !== undefined) {
								console.error(
									'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.'
								);
							}

							this.setValues(parameters);
						}
					}

					copy(source) {
						super.copy(source);

						this.fragmentShader = source.fragmentShader;
						this.vertexShader = source.vertexShader;

						this.uniforms = Object(_renderers_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["cloneUniforms"])(source.uniforms);

						this.defines = Object.assign({}, source.defines);

						this.wireframe = source.wireframe;
						this.wireframeLinewidth = source.wireframeLinewidth;

						this.lights = source.lights;
						this.clipping = source.clipping;

						this.extensions = Object.assign({}, source.extensions);

						this.glslVersion = source.glslVersion;

						return this;
					}

					toJSON(meta) {
						const data = super.toJSON(meta);

						data.glslVersion = this.glslVersion;
						data.uniforms = {};

						for (const name in this.uniforms) {
							const uniform = this.uniforms[name];
							const value = uniform.value;

							if (value && value.isTexture) {
								data.uniforms[name] = {
									type: 't',
									value: value.toJSON(meta).uuid
								};
							} else if (value && value.isColor) {
								data.uniforms[name] = {
									type: 'c',
									value: value.getHex()
								};
							} else if (value && value.isVector2) {
								data.uniforms[name] = {
									type: 'v2',
									value: value.toArray()
								};
							} else if (value && value.isVector3) {
								data.uniforms[name] = {
									type: 'v3',
									value: value.toArray()
								};
							} else if (value && value.isVector4) {
								data.uniforms[name] = {
									type: 'v4',
									value: value.toArray()
								};
							} else if (value && value.isMatrix3) {
								data.uniforms[name] = {
									type: 'm3',
									value: value.toArray()
								};
							} else if (value && value.isMatrix4) {
								data.uniforms[name] = {
									type: 'm4',
									value: value.toArray()
								};
							} else {
								data.uniforms[name] = {
									value: value
								};

								// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
							}
						}

						if (Object.keys(this.defines).length > 0) data.defines = this.defines;

						data.vertexShader = this.vertexShader;
						data.fragmentShader = this.fragmentShader;

						const extensions = {};

						for (const key in this.extensions) {
							if (this.extensions[key] === true) extensions[key] = true;
						}

						if (Object.keys(extensions).length > 0) data.extensions = extensions;

						return data;
					}
				}

				ShaderMaterial.prototype.isShaderMaterial = true;




				/***/
}),

/***/ "./libs/three/math/Box3.js":
/*!*********************************!*\
  !*** ./libs/three/math/Box3.js ***!
  \*********************************/
/*! exports provided: Box3 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function () { return Box3; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./libs/three/math/Vector3.js");


				class Box3 {
					constructor(
						min = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](+Infinity, +Infinity, +Infinity),
						max = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](-Infinity, -Infinity, -Infinity)
					) {
						this.min = min;
						this.max = max;
					}

					set(min, max) {
						this.min.copy(min);
						this.max.copy(max);

						return this;
					}

					setFromArray(array) {
						let minX = +Infinity;
						let minY = +Infinity;
						let minZ = +Infinity;

						let maxX = -Infinity;
						let maxY = -Infinity;
						let maxZ = -Infinity;

						for (let i = 0, l = array.length; i < l; i += 3) {
							const x = array[i];
							const y = array[i + 1];
							const z = array[i + 2];

							if (x < minX) minX = x;
							if (y < minY) minY = y;
							if (z < minZ) minZ = z;

							if (x > maxX) maxX = x;
							if (y > maxY) maxY = y;
							if (z > maxZ) maxZ = z;
						}

						this.min.set(minX, minY, minZ);
						this.max.set(maxX, maxY, maxZ);

						return this;
					}

					setFromBufferAttribute(attribute) {
						let minX = +Infinity;
						let minY = +Infinity;
						let minZ = +Infinity;

						let maxX = -Infinity;
						let maxY = -Infinity;
						let maxZ = -Infinity;

						for (let i = 0, l = attribute.count; i < l; i++) {
							const x = attribute.getX(i);
							const y = attribute.getY(i);
							const z = attribute.getZ(i);

							if (x < minX) minX = x;
							if (y < minY) minY = y;
							if (z < minZ) minZ = z;

							if (x > maxX) maxX = x;
							if (y > maxY) maxY = y;
							if (z > maxZ) maxZ = z;
						}

						this.min.set(minX, minY, minZ);
						this.max.set(maxX, maxY, maxZ);

						return this;
					}

					setFromPoints(points) {
						this.makeEmpty();

						for (let i = 0, il = points.length; i < il; i++) {
							this.expandByPoint(points[i]);
						}

						return this;
					}

					setFromCenterAndSize(center, size) {
						const halfSize = _vector.copy(size).multiplyScalar(0.5);

						this.min.copy(center).sub(halfSize);
						this.max.copy(center).add(halfSize);

						return this;
					}

					setFromObject(object) {
						this.makeEmpty();

						return this.expandByObject(object);
					}

					clone() {
						return new this.constructor().copy(this);
					}

					copy(box) {
						this.min.copy(box.min);
						this.max.copy(box.max);

						return this;
					}

					makeEmpty() {
						this.min.x = this.min.y = this.min.z = +Infinity;
						this.max.x = this.max.y = this.max.z = -Infinity;

						return this;
					}

					isEmpty() {
						// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

						return (
							this.max.x < this.min.x ||
							this.max.y < this.min.y ||
							this.max.z < this.min.z
						);
					}

					getCenter(target) {
						return this.isEmpty()
							? target.set(0, 0, 0)
							: target.addVectors(this.min, this.max).multiplyScalar(0.5);
					}

					getSize(target) {
						return this.isEmpty()
							? target.set(0, 0, 0)
							: target.subVectors(this.max, this.min);
					}

					expandByPoint(point) {
						this.min.min(point);
						this.max.max(point);

						return this;
					}

					expandByVector(vector) {
						this.min.sub(vector);
						this.max.add(vector);

						return this;
					}

					expandByScalar(scalar) {
						this.min.addScalar(-scalar);
						this.max.addScalar(scalar);

						return this;
					}

					expandByObject(object) {
						// Computes the world-axis-aligned bounding box of an object (including its children),
						// accounting for both the object's, and children's, world transforms

						object.updateWorldMatrix(false, false);

						const geometry = object.geometry;

						if (geometry !== undefined) {
							if (geometry.boundingBox === null) {
								geometry.computeBoundingBox();
							}

							_box.copy(geometry.boundingBox);
							_box.applyMatrix4(object.matrixWorld);

							this.union(_box);
						}

						const children = object.children;

						for (let i = 0, l = children.length; i < l; i++) {
							this.expandByObject(children[i]);
						}

						return this;
					}

					containsPoint(point) {
						return point.x < this.min.x ||
							point.x > this.max.x ||
							point.y < this.min.y ||
							point.y > this.max.y ||
							point.z < this.min.z ||
							point.z > this.max.z
							? false
							: true;
					}

					containsBox(box) {
						return (
							this.min.x <= box.min.x &&
							box.max.x <= this.max.x &&
							this.min.y <= box.min.y &&
							box.max.y <= this.max.y &&
							this.min.z <= box.min.z &&
							box.max.z <= this.max.z
						);
					}

					getParameter(point, target) {
						// This can potentially have a divide by zero if the box
						// has a size dimension of 0.

						return target.set(
							(point.x - this.min.x) / (this.max.x - this.min.x),
							(point.y - this.min.y) / (this.max.y - this.min.y),
							(point.z - this.min.z) / (this.max.z - this.min.z)
						);
					}

					intersectsBox(box) {
						// using 6 splitting planes to rule out intersections.
						return box.max.x < this.min.x ||
							box.min.x > this.max.x ||
							box.max.y < this.min.y ||
							box.min.y > this.max.y ||
							box.max.z < this.min.z ||
							box.min.z > this.max.z
							? false
							: true;
					}

					intersectsSphere(sphere) {
						// Find the point on the AABB closest to the sphere center.
						this.clampPoint(sphere.center, _vector);

						// If that point is inside the sphere, the AABB and sphere intersect.
						return (
							_vector.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius
						);
					}

					intersectsPlane(plane) {
						// We compute the minimum and maximum dot product values. If those values
						// are on the same side (back or front) of the plane, then there is no intersection.

						let min, max;

						if (plane.normal.x > 0) {
							min = plane.normal.x * this.min.x;
							max = plane.normal.x * this.max.x;
						} else {
							min = plane.normal.x * this.max.x;
							max = plane.normal.x * this.min.x;
						}

						if (plane.normal.y > 0) {
							min += plane.normal.y * this.min.y;
							max += plane.normal.y * this.max.y;
						} else {
							min += plane.normal.y * this.max.y;
							max += plane.normal.y * this.min.y;
						}

						if (plane.normal.z > 0) {
							min += plane.normal.z * this.min.z;
							max += plane.normal.z * this.max.z;
						} else {
							min += plane.normal.z * this.max.z;
							max += plane.normal.z * this.min.z;
						}

						return min <= -plane.constant && max >= -plane.constant;
					}

					intersectsTriangle(triangle) {
						if (this.isEmpty()) {
							return false;
						}

						// compute box center and extents
						this.getCenter(_center);
						_extents.subVectors(this.max, _center);

						// translate triangle to aabb origin
						_v0.subVectors(triangle.a, _center);
						_v1.subVectors(triangle.b, _center);
						_v2.subVectors(triangle.c, _center);

						// compute edge vectors for triangle
						_f0.subVectors(_v1, _v0);
						_f1.subVectors(_v2, _v1);
						_f2.subVectors(_v0, _v2);

						// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
						// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
						// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
						let axes = [
							0,
							-_f0.z,
							_f0.y,
							0,
							-_f1.z,
							_f1.y,
							0,
							-_f2.z,
							_f2.y,
							_f0.z,
							0,
							-_f0.x,
							_f1.z,
							0,
							-_f1.x,
							_f2.z,
							0,
							-_f2.x,
							-_f0.y,
							_f0.x,
							0,
							-_f1.y,
							_f1.x,
							0,
							-_f2.y,
							_f2.x,
							0
						];
						if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
							return false;
						}

						// test 3 face normals from the aabb
						axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
						if (!satForAxes(axes, _v0, _v1, _v2, _extents)) {
							return false;
						}

						// finally testing the face normal of the triangle
						// use already existing triangle edge vectors here
						_triangleNormal.crossVectors(_f0, _f1);
						axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];

						return satForAxes(axes, _v0, _v1, _v2, _extents);
					}

					clampPoint(point, target) {
						return target.copy(point).clamp(this.min, this.max);
					}

					distanceToPoint(point) {
						const clampedPoint = _vector.copy(point).clamp(this.min, this.max);

						return clampedPoint.sub(point).length();
					}

					getBoundingSphere(target) {
						this.getCenter(target.center);

						target.radius = this.getSize(_vector).length() * 0.5;

						return target;
					}

					intersect(box) {
						this.min.max(box.min);
						this.max.min(box.max);

						// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
						if (this.isEmpty()) this.makeEmpty();

						return this;
					}

					union(box) {
						this.min.min(box.min);
						this.max.max(box.max);

						return this;
					}

					applyMatrix4(matrix) {
						// transform of empty box is an empty box.
						if (this.isEmpty()) return this;

						// NOTE: I am using a binary pattern to specify all 2^3 combinations below
						_points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
						_points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
						_points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
						_points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
						_points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
						_points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
						_points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
						_points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

						this.setFromPoints(_points);

						return this;
					}

					translate(offset) {
						this.min.add(offset);
						this.max.add(offset);

						return this;
					}

					equals(box) {
						return box.min.equals(this.min) && box.max.equals(this.max);
					}
				}

				Box3.prototype.isBox3 = true;

				const _points = [
  /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
  /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]()
				];

				const _vector = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				const _box = /*@__PURE__*/ new Box3();

				// triangle centered vertices

				const _v0 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _v2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				// triangle edge vectors

				const _f0 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _f1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _f2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				const _center = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _extents = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _triangleNormal = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _testAxis = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				function satForAxes(axes, v0, v1, v2, extents) {
					for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
						_testAxis.fromArray(axes, i);
						// project the aabb onto the seperating axis
						const r =
							extents.x * Math.abs(_testAxis.x) +
							extents.y * Math.abs(_testAxis.y) +
							extents.z * Math.abs(_testAxis.z);
						// project all 3 vertices of the triangle onto the seperating axis
						const p0 = v0.dot(_testAxis);
						const p1 = v1.dot(_testAxis);
						const p2 = v2.dot(_testAxis);
						// actual test, basically see if either of the most extreme of the triangle points intersects r
						if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
							// points of the projected triangle are outside the projected half-length of the aabb
							// the axis is seperating and we can exit
							return false;
						}
					}

					return true;
				}




				/***/
}),

/***/ "./libs/three/math/Color.js":
/*!**********************************!*\
  !*** ./libs/three/math/Color.js ***!
  \**********************************/
/*! exports provided: Color */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function () { return Color; });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./libs/three/math/MathUtils.js");


				const _colorKeywords = {
					aliceblue: 0xf0f8ff,
					antiquewhite: 0xfaebd7,
					aqua: 0x00ffff,
					aquamarine: 0x7fffd4,
					azure: 0xf0ffff,
					beige: 0xf5f5dc,
					bisque: 0xffe4c4,
					black: 0x000000,
					blanchedalmond: 0xffebcd,
					blue: 0x0000ff,
					blueviolet: 0x8a2be2,
					brown: 0xa52a2a,
					burlywood: 0xdeb887,
					cadetblue: 0x5f9ea0,
					chartreuse: 0x7fff00,
					chocolate: 0xd2691e,
					coral: 0xff7f50,
					cornflowerblue: 0x6495ed,
					cornsilk: 0xfff8dc,
					crimson: 0xdc143c,
					cyan: 0x00ffff,
					darkblue: 0x00008b,
					darkcyan: 0x008b8b,
					darkgoldenrod: 0xb8860b,
					darkgray: 0xa9a9a9,
					darkgreen: 0x006400,
					darkgrey: 0xa9a9a9,
					darkkhaki: 0xbdb76b,
					darkmagenta: 0x8b008b,
					darkolivegreen: 0x556b2f,
					darkorange: 0xff8c00,
					darkorchid: 0x9932cc,
					darkred: 0x8b0000,
					darksalmon: 0xe9967a,
					darkseagreen: 0x8fbc8f,
					darkslateblue: 0x483d8b,
					darkslategray: 0x2f4f4f,
					darkslategrey: 0x2f4f4f,
					darkturquoise: 0x00ced1,
					darkviolet: 0x9400d3,
					deeppink: 0xff1493,
					deepskyblue: 0x00bfff,
					dimgray: 0x696969,
					dimgrey: 0x696969,
					dodgerblue: 0x1e90ff,
					firebrick: 0xb22222,
					floralwhite: 0xfffaf0,
					forestgreen: 0x228b22,
					fuchsia: 0xff00ff,
					gainsboro: 0xdcdcdc,
					ghostwhite: 0xf8f8ff,
					gold: 0xffd700,
					goldenrod: 0xdaa520,
					gray: 0x808080,
					green: 0x008000,
					greenyellow: 0xadff2f,
					grey: 0x808080,
					honeydew: 0xf0fff0,
					hotpink: 0xff69b4,
					indianred: 0xcd5c5c,
					indigo: 0x4b0082,
					ivory: 0xfffff0,
					khaki: 0xf0e68c,
					lavender: 0xe6e6fa,
					lavenderblush: 0xfff0f5,
					lawngreen: 0x7cfc00,
					lemonchiffon: 0xfffacd,
					lightblue: 0xadd8e6,
					lightcoral: 0xf08080,
					lightcyan: 0xe0ffff,
					lightgoldenrodyellow: 0xfafad2,
					lightgray: 0xd3d3d3,
					lightgreen: 0x90ee90,
					lightgrey: 0xd3d3d3,
					lightpink: 0xffb6c1,
					lightsalmon: 0xffa07a,
					lightseagreen: 0x20b2aa,
					lightskyblue: 0x87cefa,
					lightslategray: 0x778899,
					lightslategrey: 0x778899,
					lightsteelblue: 0xb0c4de,
					lightyellow: 0xffffe0,
					lime: 0x00ff00,
					limegreen: 0x32cd32,
					linen: 0xfaf0e6,
					magenta: 0xff00ff,
					maroon: 0x800000,
					mediumaquamarine: 0x66cdaa,
					mediumblue: 0x0000cd,
					mediumorchid: 0xba55d3,
					mediumpurple: 0x9370db,
					mediumseagreen: 0x3cb371,
					mediumslateblue: 0x7b68ee,
					mediumspringgreen: 0x00fa9a,
					mediumturquoise: 0x48d1cc,
					mediumvioletred: 0xc71585,
					midnightblue: 0x191970,
					mintcream: 0xf5fffa,
					mistyrose: 0xffe4e1,
					moccasin: 0xffe4b5,
					navajowhite: 0xffdead,
					navy: 0x000080,
					oldlace: 0xfdf5e6,
					olive: 0x808000,
					olivedrab: 0x6b8e23,
					orange: 0xffa500,
					orangered: 0xff4500,
					orchid: 0xda70d6,
					palegoldenrod: 0xeee8aa,
					palegreen: 0x98fb98,
					paleturquoise: 0xafeeee,
					palevioletred: 0xdb7093,
					papayawhip: 0xffefd5,
					peachpuff: 0xffdab9,
					peru: 0xcd853f,
					pink: 0xffc0cb,
					plum: 0xdda0dd,
					powderblue: 0xb0e0e6,
					purple: 0x800080,
					rebeccapurple: 0x663399,
					red: 0xff0000,
					rosybrown: 0xbc8f8f,
					royalblue: 0x4169e1,
					saddlebrown: 0x8b4513,
					salmon: 0xfa8072,
					sandybrown: 0xf4a460,
					seagreen: 0x2e8b57,
					seashell: 0xfff5ee,
					sienna: 0xa0522d,
					silver: 0xc0c0c0,
					skyblue: 0x87ceeb,
					slateblue: 0x6a5acd,
					slategray: 0x708090,
					slategrey: 0x708090,
					snow: 0xfffafa,
					springgreen: 0x00ff7f,
					steelblue: 0x4682b4,
					tan: 0xd2b48c,
					teal: 0x008080,
					thistle: 0xd8bfd8,
					tomato: 0xff6347,
					turquoise: 0x40e0d0,
					violet: 0xee82ee,
					wheat: 0xf5deb3,
					white: 0xffffff,
					whitesmoke: 0xf5f5f5,
					yellow: 0xffff00,
					yellowgreen: 0x9acd32
				};

				const _hslA = { h: 0, s: 0, l: 0 };
				const _hslB = { h: 0, s: 0, l: 0 };

				function hue2rgb(p, q, t) {
					if (t < 0) t += 1;
					if (t > 1) t -= 1;
					if (t < 1 / 6) return p + (q - p) * 6 * t;
					if (t < 1 / 2) return q;
					if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
					return p;
				}

				function SRGBToLinear(c) {
					return c < 0.04045
						? c * 0.0773993808
						: Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
				}

				function LinearToSRGB(c) {
					return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
				}

				class Color {
					constructor(r, g, b) {
						if (g === undefined && b === undefined) {
							// r is THREE.Color, hex or string
							return this.set(r);
						}

						return this.setRGB(r, g, b);
					}

					set(value) {
						if (value && value.isColor) {
							this.copy(value);
						} else if (typeof value === 'number') {
							this.setHex(value);
						} else if (typeof value === 'string') {
							this.setStyle(value);
						}

						return this;
					}

					setScalar(scalar) {
						this.r = scalar;
						this.g = scalar;
						this.b = scalar;

						return this;
					}

					setHex(hex) {
						hex = Math.floor(hex);

						this.r = ((hex >> 16) & 255) / 255;
						this.g = ((hex >> 8) & 255) / 255;
						this.b = (hex & 255) / 255;

						return this;
					}

					setRGB(r, g, b) {
						this.r = r;
						this.g = g;
						this.b = b;

						return this;
					}

					setHSL(h, s, l) {
						// h,s,l ranges are in 0.0 - 1.0
						h = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["euclideanModulo"](h, 1);
						s = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["clamp"](s, 0, 1);
						l = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["clamp"](l, 0, 1);

						if (s === 0) {
							this.r = this.g = this.b = l;
						} else {
							const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
							const q = 2 * l - p;

							this.r = hue2rgb(q, p, h + 1 / 3);
							this.g = hue2rgb(q, p, h);
							this.b = hue2rgb(q, p, h - 1 / 3);
						}

						return this;
					}

					setStyle(style) {
						function handleAlpha(string) {
							if (string === undefined) return;

							if (parseFloat(string) < 1) {
								console.warn(
									'THREE.Color: Alpha component of ' + style + ' will be ignored.'
								);
							}
						}

						let m;

						if ((m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style))) {
							// rgb / hsl

							let color;
							const name = m[1];
							const components = m[2];

							switch (name) {
								case 'rgb':
								case 'rgba':
									if (
										(color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
											components
										))
									) {
										// rgb(255,0,0) rgba(255,0,0,0.5)
										this.r = Math.min(255, parseInt(color[1], 10)) / 255;
										this.g = Math.min(255, parseInt(color[2], 10)) / 255;
										this.b = Math.min(255, parseInt(color[3], 10)) / 255;

										handleAlpha(color[4]);

										return this;
									}

									if (
										(color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
											components
										))
									) {
										// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
										this.r = Math.min(100, parseInt(color[1], 10)) / 100;
										this.g = Math.min(100, parseInt(color[2], 10)) / 100;
										this.b = Math.min(100, parseInt(color[3], 10)) / 100;

										handleAlpha(color[4]);

										return this;
									}

									break;

								case 'hsl':
								case 'hsla':
									if (
										(color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
											components
										))
									) {
										// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
										const h = parseFloat(color[1]) / 360;
										const s = parseInt(color[2], 10) / 100;
										const l = parseInt(color[3], 10) / 100;

										handleAlpha(color[4]);

										return this.setHSL(h, s, l);
									}

									break;
							}
						} else if ((m = /^\#([A-Fa-f\d]+)$/.exec(style))) {
							// hex color

							const hex = m[1];
							const size = hex.length;

							if (size === 3) {
								// #ff0
								this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
								this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
								this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;

								return this;
							} else if (size === 6) {
								// #ff0000
								this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
								this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
								this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;

								return this;
							}
						}

						if (style && style.length > 0) {
							return this.setColorName(style);
						}

						return this;
					}

					setColorName(style) {
						// color keywords
						const hex = _colorKeywords[style.toLowerCase()];

						if (hex !== undefined) {
							// red
							this.setHex(hex);
						} else {
							// unknown color
							console.warn('THREE.Color: Unknown color ' + style);
						}

						return this;
					}

					clone() {
						return new this.constructor(this.r, this.g, this.b);
					}

					copy(color) {
						this.r = color.r;
						this.g = color.g;
						this.b = color.b;

						return this;
					}

					copyGammaToLinear(color, gammaFactor = 2.0) {
						this.r = Math.pow(color.r, gammaFactor);
						this.g = Math.pow(color.g, gammaFactor);
						this.b = Math.pow(color.b, gammaFactor);

						return this;
					}

					copyLinearToGamma(color, gammaFactor = 2.0) {
						const safeInverse = gammaFactor > 0 ? 1.0 / gammaFactor : 1.0;

						this.r = Math.pow(color.r, safeInverse);
						this.g = Math.pow(color.g, safeInverse);
						this.b = Math.pow(color.b, safeInverse);

						return this;
					}

					convertGammaToLinear(gammaFactor) {
						this.copyGammaToLinear(this, gammaFactor);

						return this;
					}

					convertLinearToGamma(gammaFactor) {
						this.copyLinearToGamma(this, gammaFactor);

						return this;
					}

					copySRGBToLinear(color) {
						this.r = SRGBToLinear(color.r);
						this.g = SRGBToLinear(color.g);
						this.b = SRGBToLinear(color.b);

						return this;
					}

					copyLinearToSRGB(color) {
						this.r = LinearToSRGB(color.r);
						this.g = LinearToSRGB(color.g);
						this.b = LinearToSRGB(color.b);

						return this;
					}

					convertSRGBToLinear() {
						this.copySRGBToLinear(this);

						return this;
					}

					convertLinearToSRGB() {
						this.copyLinearToSRGB(this);

						return this;
					}

					getHex() {
						return (
							((this.r * 255) << 16) ^ ((this.g * 255) << 8) ^ ((this.b * 255) << 0)
						);
					}

					getHexString() {
						return ('000000' + this.getHex().toString(16)).slice(-6);
					}

					getHSL(target) {
						// h,s,l ranges are in 0.0 - 1.0

						const r = this.r,
							g = this.g,
							b = this.b;

						const max = Math.max(r, g, b);
						const min = Math.min(r, g, b);

						let hue, saturation;
						const lightness = (min + max) / 2.0;

						if (min === max) {
							hue = 0;
							saturation = 0;
						} else {
							const delta = max - min;

							saturation =
								lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);

							switch (max) {
								case r:
									hue = (g - b) / delta + (g < b ? 6 : 0);
									break;
								case g:
									hue = (b - r) / delta + 2;
									break;
								case b:
									hue = (r - g) / delta + 4;
									break;
							}

							hue /= 6;
						}

						target.h = hue;
						target.s = saturation;
						target.l = lightness;

						return target;
					}

					getStyle() {
						return (
							'rgb(' +
							((this.r * 255) | 0) +
							',' +
							((this.g * 255) | 0) +
							',' +
							((this.b * 255) | 0) +
							')'
						);
					}

					offsetHSL(h, s, l) {
						this.getHSL(_hslA);

						_hslA.h += h;
						_hslA.s += s;
						_hslA.l += l;

						this.setHSL(_hslA.h, _hslA.s, _hslA.l);

						return this;
					}

					add(color) {
						this.r += color.r;
						this.g += color.g;
						this.b += color.b;

						return this;
					}

					addColors(color1, color2) {
						this.r = color1.r + color2.r;
						this.g = color1.g + color2.g;
						this.b = color1.b + color2.b;

						return this;
					}

					addScalar(s) {
						this.r += s;
						this.g += s;
						this.b += s;

						return this;
					}

					sub(color) {
						this.r = Math.max(0, this.r - color.r);
						this.g = Math.max(0, this.g - color.g);
						this.b = Math.max(0, this.b - color.b);

						return this;
					}

					multiply(color) {
						this.r *= color.r;
						this.g *= color.g;
						this.b *= color.b;

						return this;
					}

					multiplyScalar(s) {
						this.r *= s;
						this.g *= s;
						this.b *= s;

						return this;
					}

					lerp(color, alpha) {
						this.r += (color.r - this.r) * alpha;
						this.g += (color.g - this.g) * alpha;
						this.b += (color.b - this.b) * alpha;

						return this;
					}

					lerpColors(color1, color2, alpha) {
						this.r = color1.r + (color2.r - color1.r) * alpha;
						this.g = color1.g + (color2.g - color1.g) * alpha;
						this.b = color1.b + (color2.b - color1.b) * alpha;

						return this;
					}

					lerpHSL(color, alpha) {
						this.getHSL(_hslA);
						color.getHSL(_hslB);

						const h = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["lerp"](_hslA.h, _hslB.h, alpha);
						const s = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["lerp"](_hslA.s, _hslB.s, alpha);
						const l = _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["lerp"](_hslA.l, _hslB.l, alpha);

						this.setHSL(h, s, l);

						return this;
					}

					equals(c) {
						return c.r === this.r && c.g === this.g && c.b === this.b;
					}

					fromArray(array, offset = 0) {
						this.r = array[offset];
						this.g = array[offset + 1];
						this.b = array[offset + 2];

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this.r;
						array[offset + 1] = this.g;
						array[offset + 2] = this.b;

						return array;
					}

					fromBufferAttribute(attribute, index) {
						this.r = attribute.getX(index);
						this.g = attribute.getY(index);
						this.b = attribute.getZ(index);

						if (attribute.normalized === true) {
							// assuming Uint8Array

							this.r /= 255;
							this.g /= 255;
							this.b /= 255;
						}

						return this;
					}

					toJSON() {
						return this.getHex();
					}
				}

				Color.NAMES = _colorKeywords;

				Color.prototype.isColor = true;
				Color.prototype.r = 1;
				Color.prototype.g = 1;
				Color.prototype.b = 1;




				/***/
}),

/***/ "./libs/three/math/Euler.js":
/*!**********************************!*\
  !*** ./libs/three/math/Euler.js ***!
  \**********************************/
/*! exports provided: Euler */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function () { return Euler; });
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Quaternion.js */ "./libs/three/math/Quaternion.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MathUtils.js */ "./libs/three/math/MathUtils.js");





				const _matrix = /*@__PURE__*/ new _Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
				const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_0__["Quaternion"]();

				class Euler {
					constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
						this._x = x;
						this._y = y;
						this._z = z;
						this._order = order;
					}

					get x() {
						return this._x;
					}

					set x(value) {
						this._x = value;
						this._onChangeCallback();
					}

					get y() {
						return this._y;
					}

					set y(value) {
						this._y = value;
						this._onChangeCallback();
					}

					get z() {
						return this._z;
					}

					set z(value) {
						this._z = value;
						this._onChangeCallback();
					}

					get order() {
						return this._order;
					}

					set order(value) {
						this._order = value;
						this._onChangeCallback();
					}

					set(x, y, z, order = this._order) {
						this._x = x;
						this._y = y;
						this._z = z;
						this._order = order;

						this._onChangeCallback();

						return this;
					}

					clone() {
						return new this.constructor(this._x, this._y, this._z, this._order);
					}

					copy(euler) {
						this._x = euler._x;
						this._y = euler._y;
						this._z = euler._z;
						this._order = euler._order;

						this._onChangeCallback();

						return this;
					}

					setFromRotationMatrix(m, order = this._order, update = true) {
						// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

						const te = m.elements;
						const m11 = te[0],
							m12 = te[4],
							m13 = te[8];
						const m21 = te[1],
							m22 = te[5],
							m23 = te[9];
						const m31 = te[2],
							m32 = te[6],
							m33 = te[10];

						switch (order) {
							case 'XYZ':
								this._y = Math.asin(Object(_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(m13, -1, 1));

								if (Math.abs(m13) < 0.9999999) {
									this._x = Math.atan2(-m23, m33);
									this._z = Math.atan2(-m12, m11);
								} else {
									this._x = Math.atan2(m32, m22);
									this._z = 0;
								}

								break;

							case 'YXZ':
								this._x = Math.asin(-Object(_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(m23, -1, 1));

								if (Math.abs(m23) < 0.9999999) {
									this._y = Math.atan2(m13, m33);
									this._z = Math.atan2(m21, m22);
								} else {
									this._y = Math.atan2(-m31, m11);
									this._z = 0;
								}

								break;

							case 'ZXY':
								this._x = Math.asin(Object(_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(m32, -1, 1));

								if (Math.abs(m32) < 0.9999999) {
									this._y = Math.atan2(-m31, m33);
									this._z = Math.atan2(-m12, m22);
								} else {
									this._y = 0;
									this._z = Math.atan2(m21, m11);
								}

								break;

							case 'ZYX':
								this._y = Math.asin(-Object(_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(m31, -1, 1));

								if (Math.abs(m31) < 0.9999999) {
									this._x = Math.atan2(m32, m33);
									this._z = Math.atan2(m21, m11);
								} else {
									this._x = 0;
									this._z = Math.atan2(-m12, m22);
								}

								break;

							case 'YZX':
								this._z = Math.asin(Object(_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(m21, -1, 1));

								if (Math.abs(m21) < 0.9999999) {
									this._x = Math.atan2(-m23, m22);
									this._y = Math.atan2(-m31, m11);
								} else {
									this._x = 0;
									this._y = Math.atan2(m13, m33);
								}

								break;

							case 'XZY':
								this._z = Math.asin(-Object(_MathUtils_js__WEBPACK_IMPORTED_MODULE_3__["clamp"])(m12, -1, 1));

								if (Math.abs(m12) < 0.9999999) {
									this._x = Math.atan2(m32, m22);
									this._y = Math.atan2(m13, m11);
								} else {
									this._x = Math.atan2(-m23, m33);
									this._y = 0;
								}

								break;

							default:
								console.warn(
									'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
									order
								);
						}

						this._order = order;

						if (update === true) this._onChangeCallback();

						return this;
					}

					setFromQuaternion(q, order, update) {
						_matrix.makeRotationFromQuaternion(q);

						return this.setFromRotationMatrix(_matrix, order, update);
					}

					setFromVector3(v, order = this._order) {
						return this.set(v.x, v.y, v.z, order);
					}

					reorder(newOrder) {
						// WARNING: this discards revolution information -bhouston

						_quaternion.setFromEuler(this);

						return this.setFromQuaternion(_quaternion, newOrder);
					}

					equals(euler) {
						return (
							euler._x === this._x &&
							euler._y === this._y &&
							euler._z === this._z &&
							euler._order === this._order
						);
					}

					fromArray(array) {
						this._x = array[0];
						this._y = array[1];
						this._z = array[2];
						if (array[3] !== undefined) this._order = array[3];

						this._onChangeCallback();

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this._x;
						array[offset + 1] = this._y;
						array[offset + 2] = this._z;
						array[offset + 3] = this._order;

						return array;
					}

					toVector3(optionalResult) {
						if (optionalResult) {
							return optionalResult.set(this._x, this._y, this._z);
						} else {
							return new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](this._x, this._y, this._z);
						}
					}

					_onChange(callback) {
						this._onChangeCallback = callback;

						return this;
					}

					_onChangeCallback() { }
				}

				Euler.prototype.isEuler = true;

				Euler.DefaultOrder = 'XYZ';
				Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX'];




				/***/
}),

/***/ "./libs/three/math/Frustum.js":
/*!************************************!*\
  !*** ./libs/three/math/Frustum.js ***!
  \************************************/
/*! exports provided: Frustum */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function () { return Frustum; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _Sphere_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Sphere.js */ "./libs/three/math/Sphere.js");
/* harmony import */ var _Plane_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Plane.js */ "./libs/three/math/Plane.js");




				const _sphere = /*@__PURE__*/ new _Sphere_js__WEBPACK_IMPORTED_MODULE_1__["Sphere"]();
				const _vector = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				class Frustum {
					constructor(
						p0 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](),
						p1 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](),
						p2 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](),
						p3 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](),
						p4 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"](),
						p5 = new _Plane_js__WEBPACK_IMPORTED_MODULE_2__["Plane"]()
					) {
						this.planes = [p0, p1, p2, p3, p4, p5];
					}

					set(p0, p1, p2, p3, p4, p5) {
						const planes = this.planes;

						planes[0].copy(p0);
						planes[1].copy(p1);
						planes[2].copy(p2);
						planes[3].copy(p3);
						planes[4].copy(p4);
						planes[5].copy(p5);

						return this;
					}

					copy(frustum) {
						const planes = this.planes;

						for (let i = 0; i < 6; i++) {
							planes[i].copy(frustum.planes[i]);
						}

						return this;
					}

					setFromProjectionMatrix(m) {
						const planes = this.planes;
						const me = m.elements;
						const me0 = me[0],
							me1 = me[1],
							me2 = me[2],
							me3 = me[3];
						const me4 = me[4],
							me5 = me[5],
							me6 = me[6],
							me7 = me[7];
						const me8 = me[8],
							me9 = me[9],
							me10 = me[10],
							me11 = me[11];
						const me12 = me[12],
							me13 = me[13],
							me14 = me[14],
							me15 = me[15];

						planes[0]
							.setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12)
							.normalize();
						planes[1]
							.setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12)
							.normalize();
						planes[2]
							.setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13)
							.normalize();
						planes[3]
							.setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13)
							.normalize();
						planes[4]
							.setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14)
							.normalize();
						planes[5]
							.setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14)
							.normalize();

						return this;
					}

					intersectsObject(object) {
						const geometry = object.geometry;

						if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

						_sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);

						return this.intersectsSphere(_sphere);
					}

					intersectsSprite(sprite) {
						_sphere.center.set(0, 0, 0);
						_sphere.radius = 0.7071067811865476;
						_sphere.applyMatrix4(sprite.matrixWorld);

						return this.intersectsSphere(_sphere);
					}

					intersectsSphere(sphere) {
						const planes = this.planes;
						const center = sphere.center;
						const negRadius = -sphere.radius;

						for (let i = 0; i < 6; i++) {
							const distance = planes[i].distanceToPoint(center);

							if (distance < negRadius) {
								return false;
							}
						}

						return true;
					}

					intersectsBox(box) {
						const planes = this.planes;

						for (let i = 0; i < 6; i++) {
							const plane = planes[i];

							// corner at max distance

							_vector.x = plane.normal.x > 0 ? box.max.x : box.min.x;
							_vector.y = plane.normal.y > 0 ? box.max.y : box.min.y;
							_vector.z = plane.normal.z > 0 ? box.max.z : box.min.z;

							if (plane.distanceToPoint(_vector) < 0) {
								return false;
							}
						}

						return true;
					}

					containsPoint(point) {
						const planes = this.planes;

						for (let i = 0; i < 6; i++) {
							if (planes[i].distanceToPoint(point) < 0) {
								return false;
							}
						}

						return true;
					}

					clone() {
						return new this.constructor().copy(this);
					}
				}




				/***/
}),

/***/ "./libs/three/math/Interpolant.js":
/*!****************************************!*\
  !*** ./libs/three/math/Interpolant.js ***!
  \****************************************/
/*! exports provided: Interpolant */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function () { return Interpolant; });
				/**
				 * Abstract base class of interpolants over parametric samples.
				 *
				 * The parameter domain is one dimensional, typically the time or a path
				 * along a curve defined by the data.
				 *
				 * The sample values can have any dimensionality and derived classes may
				 * apply special interpretations to the data.
				 *
				 * This class provides the interval seek in a Template Method, deferring
				 * the actual interpolation to derived classes.
				 *
				 * Time complexity is O(1) for linear access crossing at most two points
				 * and O(log N) for random access, where N is the number of positions.
				 *
				 * References:
				 *
				 * 		http://www.oodesign.com/template-method-pattern.html
				 *
				 */

				class Interpolant {
					constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
						this.parameterPositions = parameterPositions;
						this._cachedIndex = 0;

						this.resultBuffer =
							resultBuffer !== undefined
								? resultBuffer
								: new sampleValues.constructor(sampleSize);
						this.sampleValues = sampleValues;
						this.valueSize = sampleSize;

						this.settings = null;
						this.DefaultSettings_ = {};
					}

					evaluate(t) {
						const pp = this.parameterPositions;
						let i1 = this._cachedIndex,
							t1 = pp[i1],
							t0 = pp[i1 - 1];

						validate_interval: {
							seek: {
								let right;

								linear_scan: {
									//- See http://jsperf.com/comparison-to-undefined/3
									//- slower code:
									//-
									//- 				if ( t >= t1 || t1 === undefined ) {
									forward_scan: if (!(t < t1)) {
										for (let giveUpAt = i1 + 2; ;) {
											if (t1 === undefined) {
												if (t < t0) break forward_scan;

												// after end

												i1 = pp.length;
												this._cachedIndex = i1;
												return this.afterEnd_(i1 - 1, t, t0);
											}

											if (i1 === giveUpAt) break; // this loop

											t0 = t1;
											t1 = pp[++i1];

											if (t < t1) {
												// we have arrived at the sought interval
												break seek;
											}
										}

										// prepare binary search on the right side of the index
										right = pp.length;
										break linear_scan;
									}

									//- slower code:
									//-					if ( t < t0 || t0 === undefined ) {
									if (!(t >= t0)) {
										// looping?

										const t1global = pp[1];

										if (t < t1global) {
											i1 = 2; // + 1, using the scan for the details
											t0 = t1global;
										}

										// linear reverse scan

										for (let giveUpAt = i1 - 2; ;) {
											if (t0 === undefined) {
												// before start

												this._cachedIndex = 0;
												return this.beforeStart_(0, t, t1);
											}

											if (i1 === giveUpAt) break; // this loop

											t1 = t0;
											t0 = pp[--i1 - 1];

											if (t >= t0) {
												// we have arrived at the sought interval
												break seek;
											}
										}

										// prepare binary search on the left side of the index
										right = i1;
										i1 = 0;
										break linear_scan;
									}

									// the interval is valid

									break validate_interval;
								} // linear scan

								// binary search

								while (i1 < right) {
									const mid = (i1 + right) >>> 1;

									if (t < pp[mid]) {
										right = mid;
									} else {
										i1 = mid + 1;
									}
								}

								t1 = pp[i1];
								t0 = pp[i1 - 1];

								// check boundary cases, again

								if (t0 === undefined) {
									this._cachedIndex = 0;
									return this.beforeStart_(0, t, t1);
								}

								if (t1 === undefined) {
									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_(i1 - 1, t0, t);
								}
							} // seek

							this._cachedIndex = i1;

							this.intervalChanged_(i1, t0, t1);
						} // validate_interval

						return this.interpolate_(i1, t0, t, t1);
					}

					getSettings_() {
						return this.settings || this.DefaultSettings_;
					}

					copySampleValue_(index) {
						// copies a sample value to the result buffer

						const result = this.resultBuffer,
							values = this.sampleValues,
							stride = this.valueSize,
							offset = index * stride;

						for (let i = 0; i !== stride; ++i) {
							result[i] = values[offset + i];
						}

						return result;
					}

					// Template methods for derived classes:

					interpolate_(/* i1, t0, t, t1 */) {
						throw new Error('call to abstract method');
						// implementations shall return this.resultBuffer
					}

					intervalChanged_(/* i1, t0, t1 */) {
						// empty
					}
				}

				// ALIAS DEFINITIONS

				Interpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;
				Interpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;




				/***/
}),

/***/ "./libs/three/math/MathUtils.js":
/*!**************************************!*\
  !*** ./libs/three/math/MathUtils.js ***!
  \**************************************/
/*! exports provided: DEG2RAD, RAD2DEG, generateUUID, clamp, euclideanModulo, mapLinear, inverseLerp, lerp, damp, pingpong, smoothstep, smootherstep, randInt, randFloat, randFloatSpread, seededRandom, degToRad, radToDeg, isPowerOfTwo, ceilPowerOfTwo, floorPowerOfTwo, setQuaternionFromProperEuler */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEG2RAD", function () { return DEG2RAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RAD2DEG", function () { return RAD2DEG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateUUID", function () { return generateUUID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function () { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "euclideanModulo", function () { return euclideanModulo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapLinear", function () { return mapLinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverseLerp", function () { return inverseLerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function () { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "damp", function () { return damp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pingpong", function () { return pingpong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smoothstep", function () { return smoothstep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "smootherstep", function () { return smootherstep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randInt", function () { return randInt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randFloat", function () { return randFloat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randFloatSpread", function () { return randFloatSpread; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "seededRandom", function () { return seededRandom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degToRad", function () { return degToRad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radToDeg", function () { return radToDeg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowerOfTwo", function () { return isPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceilPowerOfTwo", function () { return ceilPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floorPowerOfTwo", function () { return floorPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setQuaternionFromProperEuler", function () { return setQuaternionFromProperEuler; });
				let _seed = 1234567;

				const DEG2RAD = Math.PI / 180;
				const RAD2DEG = 180 / Math.PI;

				//

				const _lut = [];

				for (let i = 0; i < 256; i++) {
					_lut[i] = (i < 16 ? '0' : '') + i.toString(16);
				}

				const hasRandomUUID = typeof crypto !== 'undefined' && 'randomUUID' in crypto;

				function generateUUID() {
					if (hasRandomUUID) {
						return crypto.randomUUID().toUpperCase();
					}

					// TODO Remove this code when crypto.randomUUID() is available everywhere
					// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

					const d0 = (Math.random() * 0xffffffff) | 0;
					const d1 = (Math.random() * 0xffffffff) | 0;
					const d2 = (Math.random() * 0xffffffff) | 0;
					const d3 = (Math.random() * 0xffffffff) | 0;
					const uuid =
						_lut[d0 & 0xff] +
						_lut[(d0 >> 8) & 0xff] +
						_lut[(d0 >> 16) & 0xff] +
						_lut[(d0 >> 24) & 0xff] +
						'-' +
						_lut[d1 & 0xff] +
						_lut[(d1 >> 8) & 0xff] +
						'-' +
						_lut[((d1 >> 16) & 0x0f) | 0x40] +
						_lut[(d1 >> 24) & 0xff] +
						'-' +
						_lut[(d2 & 0x3f) | 0x80] +
						_lut[(d2 >> 8) & 0xff] +
						'-' +
						_lut[(d2 >> 16) & 0xff] +
						_lut[(d2 >> 24) & 0xff] +
						_lut[d3 & 0xff] +
						_lut[(d3 >> 8) & 0xff] +
						_lut[(d3 >> 16) & 0xff] +
						_lut[(d3 >> 24) & 0xff];

					// .toUpperCase() here flattens concatenated strings to save heap memory space.
					return uuid.toUpperCase();
				}

				function clamp(value, min, max) {
					return Math.max(min, Math.min(max, value));
				}

				// compute euclidian modulo of m % n
				// https://en.wikipedia.org/wiki/Modulo_operation
				function euclideanModulo(n, m) {
					return ((n % m) + m) % m;
				}

				// Linear mapping from range <a1, a2> to range <b1, b2>
				function mapLinear(x, a1, a2, b1, b2) {
					return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);
				}

				// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
				function inverseLerp(x, y, value) {
					if (x !== y) {
						return (value - x) / (y - x);
					} else {
						return 0;
					}
				}

				// https://en.wikipedia.org/wiki/Linear_interpolation
				function lerp(x, y, t) {
					return (1 - t) * x + t * y;
				}

				// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
				function damp(x, y, lambda, dt) {
					return lerp(x, y, 1 - Math.exp(-lambda * dt));
				}

				// https://www.desmos.com/calculator/vcsjnyz7x4
				function pingpong(x, length = 1) {
					return length - Math.abs(euclideanModulo(x, length * 2) - length);
				}

				// http://en.wikipedia.org/wiki/Smoothstep
				function smoothstep(x, min, max) {
					if (x <= min) return 0;
					if (x >= max) return 1;

					x = (x - min) / (max - min);

					return x * x * (3 - 2 * x);
				}

				function smootherstep(x, min, max) {
					if (x <= min) return 0;
					if (x >= max) return 1;

					x = (x - min) / (max - min);

					return x * x * x * (x * (x * 6 - 15) + 10);
				}

				// Random integer from <low, high> interval
				function randInt(low, high) {
					return low + Math.floor(Math.random() * (high - low + 1));
				}

				// Random float from <low, high> interval
				function randFloat(low, high) {
					return low + Math.random() * (high - low);
				}

				// Random float from <-range/2, range/2> interval
				function randFloatSpread(range) {
					return range * (0.5 - Math.random());
				}

				// Deterministic pseudo-random float in the interval [ 0, 1 ]
				function seededRandom(s) {
					if (s !== undefined) _seed = s % 2147483647;

					// Park-Miller algorithm

					_seed = (_seed * 16807) % 2147483647;

					return (_seed - 1) / 2147483646;
				}

				function degToRad(degrees) {
					return degrees * DEG2RAD;
				}

				function radToDeg(radians) {
					return radians * RAD2DEG;
				}

				function isPowerOfTwo(value) {
					return (value & (value - 1)) === 0 && value !== 0;
				}

				function ceilPowerOfTwo(value) {
					return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
				}

				function floorPowerOfTwo(value) {
					return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
				}

				function setQuaternionFromProperEuler(q, a, b, c, order) {
					// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

					// rotations are applied to the axes in the order specified by 'order'
					// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
					// angles are in radians

					const cos = Math.cos;
					const sin = Math.sin;

					const c2 = cos(b / 2);
					const s2 = sin(b / 2);

					const c13 = cos((a + c) / 2);
					const s13 = sin((a + c) / 2);

					const c1_3 = cos((a - c) / 2);
					const s1_3 = sin((a - c) / 2);

					const c3_1 = cos((c - a) / 2);
					const s3_1 = sin((c - a) / 2);

					switch (order) {
						case 'XYX':
							q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
							break;

						case 'YZY':
							q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
							break;

						case 'ZXZ':
							q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
							break;

						case 'XZX':
							q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
							break;

						case 'YXY':
							q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
							break;

						case 'ZYZ':
							q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
							break;

						default:
							console.warn(
								'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
								order
							);
					}
				}




				/***/
}),

/***/ "./libs/three/math/Matrix3.js":
/*!************************************!*\
  !*** ./libs/three/math/Matrix3.js ***!
  \************************************/
/*! exports provided: Matrix3 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function () { return Matrix3; });
				class Matrix3 {
					constructor() {
						this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];

						if (arguments.length > 0) {
							console.error(
								'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.'
							);
						}
					}

					set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
						const te = this.elements;

						te[0] = n11;
						te[1] = n21;
						te[2] = n31;
						te[3] = n12;
						te[4] = n22;
						te[5] = n32;
						te[6] = n13;
						te[7] = n23;
						te[8] = n33;

						return this;
					}

					identity() {
						this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);

						return this;
					}

					copy(m) {
						const te = this.elements;
						const me = m.elements;

						te[0] = me[0];
						te[1] = me[1];
						te[2] = me[2];
						te[3] = me[3];
						te[4] = me[4];
						te[5] = me[5];
						te[6] = me[6];
						te[7] = me[7];
						te[8] = me[8];

						return this;
					}

					extractBasis(xAxis, yAxis, zAxis) {
						xAxis.setFromMatrix3Column(this, 0);
						yAxis.setFromMatrix3Column(this, 1);
						zAxis.setFromMatrix3Column(this, 2);

						return this;
					}

					setFromMatrix4(m) {
						const me = m.elements;

						this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);

						return this;
					}

					multiply(m) {
						return this.multiplyMatrices(this, m);
					}

					premultiply(m) {
						return this.multiplyMatrices(m, this);
					}

					multiplyMatrices(a, b) {
						const ae = a.elements;
						const be = b.elements;
						const te = this.elements;

						const a11 = ae[0],
							a12 = ae[3],
							a13 = ae[6];
						const a21 = ae[1],
							a22 = ae[4],
							a23 = ae[7];
						const a31 = ae[2],
							a32 = ae[5],
							a33 = ae[8];

						const b11 = be[0],
							b12 = be[3],
							b13 = be[6];
						const b21 = be[1],
							b22 = be[4],
							b23 = be[7];
						const b31 = be[2],
							b32 = be[5],
							b33 = be[8];

						te[0] = a11 * b11 + a12 * b21 + a13 * b31;
						te[3] = a11 * b12 + a12 * b22 + a13 * b32;
						te[6] = a11 * b13 + a12 * b23 + a13 * b33;

						te[1] = a21 * b11 + a22 * b21 + a23 * b31;
						te[4] = a21 * b12 + a22 * b22 + a23 * b32;
						te[7] = a21 * b13 + a22 * b23 + a23 * b33;

						te[2] = a31 * b11 + a32 * b21 + a33 * b31;
						te[5] = a31 * b12 + a32 * b22 + a33 * b32;
						te[8] = a31 * b13 + a32 * b23 + a33 * b33;

						return this;
					}

					multiplyScalar(s) {
						const te = this.elements;

						te[0] *= s;
						te[3] *= s;
						te[6] *= s;
						te[1] *= s;
						te[4] *= s;
						te[7] *= s;
						te[2] *= s;
						te[5] *= s;
						te[8] *= s;

						return this;
					}

					determinant() {
						const te = this.elements;

						const a = te[0],
							b = te[1],
							c = te[2],
							d = te[3],
							e = te[4],
							f = te[5],
							g = te[6],
							h = te[7],
							i = te[8];

						return (
							a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
						);
					}

					invert() {
						const te = this.elements,
							n11 = te[0],
							n21 = te[1],
							n31 = te[2],
							n12 = te[3],
							n22 = te[4],
							n32 = te[5],
							n13 = te[6],
							n23 = te[7],
							n33 = te[8],
							t11 = n33 * n22 - n32 * n23,
							t12 = n32 * n13 - n33 * n12,
							t13 = n23 * n12 - n22 * n13,
							det = n11 * t11 + n21 * t12 + n31 * t13;

						if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);

						const detInv = 1 / det;

						te[0] = t11 * detInv;
						te[1] = (n31 * n23 - n33 * n21) * detInv;
						te[2] = (n32 * n21 - n31 * n22) * detInv;

						te[3] = t12 * detInv;
						te[4] = (n33 * n11 - n31 * n13) * detInv;
						te[5] = (n31 * n12 - n32 * n11) * detInv;

						te[6] = t13 * detInv;
						te[7] = (n21 * n13 - n23 * n11) * detInv;
						te[8] = (n22 * n11 - n21 * n12) * detInv;

						return this;
					}

					transpose() {
						let tmp;
						const m = this.elements;

						tmp = m[1];
						m[1] = m[3];
						m[3] = tmp;
						tmp = m[2];
						m[2] = m[6];
						m[6] = tmp;
						tmp = m[5];
						m[5] = m[7];
						m[7] = tmp;

						return this;
					}

					getNormalMatrix(matrix4) {
						return this.setFromMatrix4(matrix4)
							.invert()
							.transpose();
					}

					transposeIntoArray(r) {
						const m = this.elements;

						r[0] = m[0];
						r[1] = m[3];
						r[2] = m[6];
						r[3] = m[1];
						r[4] = m[4];
						r[5] = m[7];
						r[6] = m[2];
						r[7] = m[5];
						r[8] = m[8];

						return this;
					}

					setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
						const c = Math.cos(rotation);
						const s = Math.sin(rotation);

						this.set(
							sx * c,
							sx * s,
							-sx * (c * cx + s * cy) + cx + tx,
							-sy * s,
							sy * c,
							-sy * (-s * cx + c * cy) + cy + ty,
							0,
							0,
							1
						);

						return this;
					}

					scale(sx, sy) {
						const te = this.elements;

						te[0] *= sx;
						te[3] *= sx;
						te[6] *= sx;
						te[1] *= sy;
						te[4] *= sy;
						te[7] *= sy;

						return this;
					}

					rotate(theta) {
						const c = Math.cos(theta);
						const s = Math.sin(theta);

						const te = this.elements;

						const a11 = te[0],
							a12 = te[3],
							a13 = te[6];
						const a21 = te[1],
							a22 = te[4],
							a23 = te[7];

						te[0] = c * a11 + s * a21;
						te[3] = c * a12 + s * a22;
						te[6] = c * a13 + s * a23;

						te[1] = -s * a11 + c * a21;
						te[4] = -s * a12 + c * a22;
						te[7] = -s * a13 + c * a23;

						return this;
					}

					translate(tx, ty) {
						const te = this.elements;

						te[0] += tx * te[2];
						te[3] += tx * te[5];
						te[6] += tx * te[8];
						te[1] += ty * te[2];
						te[4] += ty * te[5];
						te[7] += ty * te[8];

						return this;
					}

					equals(matrix) {
						const te = this.elements;
						const me = matrix.elements;

						for (let i = 0; i < 9; i++) {
							if (te[i] !== me[i]) return false;
						}

						return true;
					}

					fromArray(array, offset = 0) {
						for (let i = 0; i < 9; i++) {
							this.elements[i] = array[i + offset];
						}

						return this;
					}

					toArray(array = [], offset = 0) {
						const te = this.elements;

						array[offset] = te[0];
						array[offset + 1] = te[1];
						array[offset + 2] = te[2];

						array[offset + 3] = te[3];
						array[offset + 4] = te[4];
						array[offset + 5] = te[5];

						array[offset + 6] = te[6];
						array[offset + 7] = te[7];
						array[offset + 8] = te[8];

						return array;
					}

					clone() {
						return new this.constructor().fromArray(this.elements);
					}
				}

				Matrix3.prototype.isMatrix3 = true;




				/***/
}),

/***/ "./libs/three/math/Matrix4.js":
/*!************************************!*\
  !*** ./libs/three/math/Matrix4.js ***!
  \************************************/
/*! exports provided: Matrix4 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function () { return Matrix4; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./libs/three/math/Vector3.js");


				class Matrix4 {
					constructor() {
						this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

						if (arguments.length > 0) {
							console.error(
								'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.'
							);
						}
					}

					set(
						n11,
						n12,
						n13,
						n14,
						n21,
						n22,
						n23,
						n24,
						n31,
						n32,
						n33,
						n34,
						n41,
						n42,
						n43,
						n44
					) {
						const te = this.elements;

						te[0] = n11;
						te[4] = n12;
						te[8] = n13;
						te[12] = n14;
						te[1] = n21;
						te[5] = n22;
						te[9] = n23;
						te[13] = n24;
						te[2] = n31;
						te[6] = n32;
						te[10] = n33;
						te[14] = n34;
						te[3] = n41;
						te[7] = n42;
						te[11] = n43;
						te[15] = n44;

						return this;
					}

					identity() {
						this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

						return this;
					}

					clone() {
						return new Matrix4().fromArray(this.elements);
					}

					copy(m) {
						const te = this.elements;
						const me = m.elements;

						te[0] = me[0];
						te[1] = me[1];
						te[2] = me[2];
						te[3] = me[3];
						te[4] = me[4];
						te[5] = me[5];
						te[6] = me[6];
						te[7] = me[7];
						te[8] = me[8];
						te[9] = me[9];
						te[10] = me[10];
						te[11] = me[11];
						te[12] = me[12];
						te[13] = me[13];
						te[14] = me[14];
						te[15] = me[15];

						return this;
					}

					copyPosition(m) {
						const te = this.elements,
							me = m.elements;

						te[12] = me[12];
						te[13] = me[13];
						te[14] = me[14];

						return this;
					}

					setFromMatrix3(m) {
						const me = m.elements;

						this.set(
							me[0],
							me[3],
							me[6],
							0,
							me[1],
							me[4],
							me[7],
							0,
							me[2],
							me[5],
							me[8],
							0,
							0,
							0,
							0,
							1
						);

						return this;
					}

					extractBasis(xAxis, yAxis, zAxis) {
						xAxis.setFromMatrixColumn(this, 0);
						yAxis.setFromMatrixColumn(this, 1);
						zAxis.setFromMatrixColumn(this, 2);

						return this;
					}

					makeBasis(xAxis, yAxis, zAxis) {
						this.set(
							xAxis.x,
							yAxis.x,
							zAxis.x,
							0,
							xAxis.y,
							yAxis.y,
							zAxis.y,
							0,
							xAxis.z,
							yAxis.z,
							zAxis.z,
							0,
							0,
							0,
							0,
							1
						);

						return this;
					}

					extractRotation(m) {
						// this method does not support reflection matrices

						const te = this.elements;
						const me = m.elements;

						const scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
						const scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
						const scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();

						te[0] = me[0] * scaleX;
						te[1] = me[1] * scaleX;
						te[2] = me[2] * scaleX;
						te[3] = 0;

						te[4] = me[4] * scaleY;
						te[5] = me[5] * scaleY;
						te[6] = me[6] * scaleY;
						te[7] = 0;

						te[8] = me[8] * scaleZ;
						te[9] = me[9] * scaleZ;
						te[10] = me[10] * scaleZ;
						te[11] = 0;

						te[12] = 0;
						te[13] = 0;
						te[14] = 0;
						te[15] = 1;

						return this;
					}

					makeRotationFromEuler(euler) {
						if (!(euler && euler.isEuler)) {
							console.error(
								'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.'
							);
						}

						const te = this.elements;

						const x = euler.x,
							y = euler.y,
							z = euler.z;
						const a = Math.cos(x),
							b = Math.sin(x);
						const c = Math.cos(y),
							d = Math.sin(y);
						const e = Math.cos(z),
							f = Math.sin(z);

						if (euler.order === 'XYZ') {
							const ae = a * e,
								af = a * f,
								be = b * e,
								bf = b * f;

							te[0] = c * e;
							te[4] = -c * f;
							te[8] = d;

							te[1] = af + be * d;
							te[5] = ae - bf * d;
							te[9] = -b * c;

							te[2] = bf - ae * d;
							te[6] = be + af * d;
							te[10] = a * c;
						} else if (euler.order === 'YXZ') {
							const ce = c * e,
								cf = c * f,
								de = d * e,
								df = d * f;

							te[0] = ce + df * b;
							te[4] = de * b - cf;
							te[8] = a * d;

							te[1] = a * f;
							te[5] = a * e;
							te[9] = -b;

							te[2] = cf * b - de;
							te[6] = df + ce * b;
							te[10] = a * c;
						} else if (euler.order === 'ZXY') {
							const ce = c * e,
								cf = c * f,
								de = d * e,
								df = d * f;

							te[0] = ce - df * b;
							te[4] = -a * f;
							te[8] = de + cf * b;

							te[1] = cf + de * b;
							te[5] = a * e;
							te[9] = df - ce * b;

							te[2] = -a * d;
							te[6] = b;
							te[10] = a * c;
						} else if (euler.order === 'ZYX') {
							const ae = a * e,
								af = a * f,
								be = b * e,
								bf = b * f;

							te[0] = c * e;
							te[4] = be * d - af;
							te[8] = ae * d + bf;

							te[1] = c * f;
							te[5] = bf * d + ae;
							te[9] = af * d - be;

							te[2] = -d;
							te[6] = b * c;
							te[10] = a * c;
						} else if (euler.order === 'YZX') {
							const ac = a * c,
								ad = a * d,
								bc = b * c,
								bd = b * d;

							te[0] = c * e;
							te[4] = bd - ac * f;
							te[8] = bc * f + ad;

							te[1] = f;
							te[5] = a * e;
							te[9] = -b * e;

							te[2] = -d * e;
							te[6] = ad * f + bc;
							te[10] = ac - bd * f;
						} else if (euler.order === 'XZY') {
							const ac = a * c,
								ad = a * d,
								bc = b * c,
								bd = b * d;

							te[0] = c * e;
							te[4] = -f;
							te[8] = d * e;

							te[1] = ac * f + bd;
							te[5] = a * e;
							te[9] = ad * f - bc;

							te[2] = bc * f - ad;
							te[6] = b * e;
							te[10] = bd * f + ac;
						}

						// bottom row
						te[3] = 0;
						te[7] = 0;
						te[11] = 0;

						// last column
						te[12] = 0;
						te[13] = 0;
						te[14] = 0;
						te[15] = 1;

						return this;
					}

					makeRotationFromQuaternion(q) {
						return this.compose(
							_zero,
							q,
							_one
						);
					}

					lookAt(eye, target, up) {
						const te = this.elements;

						_z.subVectors(eye, target);

						if (_z.lengthSq() === 0) {
							// eye and target are in the same position

							_z.z = 1;
						}

						_z.normalize();
						_x.crossVectors(up, _z);

						if (_x.lengthSq() === 0) {
							// up and z are parallel

							if (Math.abs(up.z) === 1) {
								_z.x += 0.0001;
							} else {
								_z.z += 0.0001;
							}

							_z.normalize();
							_x.crossVectors(up, _z);
						}

						_x.normalize();
						_y.crossVectors(_z, _x);

						te[0] = _x.x;
						te[4] = _y.x;
						te[8] = _z.x;
						te[1] = _x.y;
						te[5] = _y.y;
						te[9] = _z.y;
						te[2] = _x.z;
						te[6] = _y.z;
						te[10] = _z.z;

						return this;
					}

					multiply(m, n) {
						if (n !== undefined) {
							console.warn(
								'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'
							);
							return this.multiplyMatrices(m, n);
						}

						return this.multiplyMatrices(this, m);
					}

					premultiply(m) {
						return this.multiplyMatrices(m, this);
					}

					multiplyMatrices(a, b) {
						const ae = a.elements;
						const be = b.elements;
						const te = this.elements;

						const a11 = ae[0],
							a12 = ae[4],
							a13 = ae[8],
							a14 = ae[12];
						const a21 = ae[1],
							a22 = ae[5],
							a23 = ae[9],
							a24 = ae[13];
						const a31 = ae[2],
							a32 = ae[6],
							a33 = ae[10],
							a34 = ae[14];
						const a41 = ae[3],
							a42 = ae[7],
							a43 = ae[11],
							a44 = ae[15];

						const b11 = be[0],
							b12 = be[4],
							b13 = be[8],
							b14 = be[12];
						const b21 = be[1],
							b22 = be[5],
							b23 = be[9],
							b24 = be[13];
						const b31 = be[2],
							b32 = be[6],
							b33 = be[10],
							b34 = be[14];
						const b41 = be[3],
							b42 = be[7],
							b43 = be[11],
							b44 = be[15];

						te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
						te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
						te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
						te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

						te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
						te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
						te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
						te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

						te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
						te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
						te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
						te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

						te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
						te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
						te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
						te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

						return this;
					}

					multiplyScalar(s) {
						const te = this.elements;

						te[0] *= s;
						te[4] *= s;
						te[8] *= s;
						te[12] *= s;
						te[1] *= s;
						te[5] *= s;
						te[9] *= s;
						te[13] *= s;
						te[2] *= s;
						te[6] *= s;
						te[10] *= s;
						te[14] *= s;
						te[3] *= s;
						te[7] *= s;
						te[11] *= s;
						te[15] *= s;

						return this;
					}

					determinant() {
						const te = this.elements;

						const n11 = te[0],
							n12 = te[4],
							n13 = te[8],
							n14 = te[12];
						const n21 = te[1],
							n22 = te[5],
							n23 = te[9],
							n24 = te[13];
						const n31 = te[2],
							n32 = te[6],
							n33 = te[10],
							n34 = te[14];
						const n41 = te[3],
							n42 = te[7],
							n43 = te[11],
							n44 = te[15];

						//TODO: make this more efficient
						//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

						return (
							n41 *
							(+n14 * n23 * n32 -
								n13 * n24 * n32 -
								n14 * n22 * n33 +
								n12 * n24 * n33 +
								n13 * n22 * n34 -
								n12 * n23 * n34) +
							n42 *
							(+n11 * n23 * n34 -
								n11 * n24 * n33 +
								n14 * n21 * n33 -
								n13 * n21 * n34 +
								n13 * n24 * n31 -
								n14 * n23 * n31) +
							n43 *
							(+n11 * n24 * n32 -
								n11 * n22 * n34 -
								n14 * n21 * n32 +
								n12 * n21 * n34 +
								n14 * n22 * n31 -
								n12 * n24 * n31) +
							n44 *
							(-n13 * n22 * n31 -
								n11 * n23 * n32 +
								n11 * n22 * n33 +
								n13 * n21 * n32 -
								n12 * n21 * n33 +
								n12 * n23 * n31)
						);
					}

					transpose() {
						const te = this.elements;
						let tmp;

						tmp = te[1];
						te[1] = te[4];
						te[4] = tmp;
						tmp = te[2];
						te[2] = te[8];
						te[8] = tmp;
						tmp = te[6];
						te[6] = te[9];
						te[9] = tmp;

						tmp = te[3];
						te[3] = te[12];
						te[12] = tmp;
						tmp = te[7];
						te[7] = te[13];
						te[13] = tmp;
						tmp = te[11];
						te[11] = te[14];
						te[14] = tmp;

						return this;
					}

					setPosition(x, y, z) {
						const te = this.elements;

						if (x.isVector3) {
							te[12] = x.x;
							te[13] = x.y;
							te[14] = x.z;
						} else {
							te[12] = x;
							te[13] = y;
							te[14] = z;
						}

						return this;
					}

					invert() {
						// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
						const te = this.elements,
							n11 = te[0],
							n21 = te[1],
							n31 = te[2],
							n41 = te[3],
							n12 = te[4],
							n22 = te[5],
							n32 = te[6],
							n42 = te[7],
							n13 = te[8],
							n23 = te[9],
							n33 = te[10],
							n43 = te[11],
							n14 = te[12],
							n24 = te[13],
							n34 = te[14],
							n44 = te[15],
							t11 =
								n23 * n34 * n42 -
								n24 * n33 * n42 +
								n24 * n32 * n43 -
								n22 * n34 * n43 -
								n23 * n32 * n44 +
								n22 * n33 * n44,
							t12 =
								n14 * n33 * n42 -
								n13 * n34 * n42 -
								n14 * n32 * n43 +
								n12 * n34 * n43 +
								n13 * n32 * n44 -
								n12 * n33 * n44,
							t13 =
								n13 * n24 * n42 -
								n14 * n23 * n42 +
								n14 * n22 * n43 -
								n12 * n24 * n43 -
								n13 * n22 * n44 +
								n12 * n23 * n44,
							t14 =
								n14 * n23 * n32 -
								n13 * n24 * n32 -
								n14 * n22 * n33 +
								n12 * n24 * n33 +
								n13 * n22 * n34 -
								n12 * n23 * n34;

						const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

						if (det === 0)
							return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

						const detInv = 1 / det;

						te[0] = t11 * detInv;
						te[1] =
							(n24 * n33 * n41 -
								n23 * n34 * n41 -
								n24 * n31 * n43 +
								n21 * n34 * n43 +
								n23 * n31 * n44 -
								n21 * n33 * n44) *
							detInv;
						te[2] =
							(n22 * n34 * n41 -
								n24 * n32 * n41 +
								n24 * n31 * n42 -
								n21 * n34 * n42 -
								n22 * n31 * n44 +
								n21 * n32 * n44) *
							detInv;
						te[3] =
							(n23 * n32 * n41 -
								n22 * n33 * n41 -
								n23 * n31 * n42 +
								n21 * n33 * n42 +
								n22 * n31 * n43 -
								n21 * n32 * n43) *
							detInv;

						te[4] = t12 * detInv;
						te[5] =
							(n13 * n34 * n41 -
								n14 * n33 * n41 +
								n14 * n31 * n43 -
								n11 * n34 * n43 -
								n13 * n31 * n44 +
								n11 * n33 * n44) *
							detInv;
						te[6] =
							(n14 * n32 * n41 -
								n12 * n34 * n41 -
								n14 * n31 * n42 +
								n11 * n34 * n42 +
								n12 * n31 * n44 -
								n11 * n32 * n44) *
							detInv;
						te[7] =
							(n12 * n33 * n41 -
								n13 * n32 * n41 +
								n13 * n31 * n42 -
								n11 * n33 * n42 -
								n12 * n31 * n43 +
								n11 * n32 * n43) *
							detInv;

						te[8] = t13 * detInv;
						te[9] =
							(n14 * n23 * n41 -
								n13 * n24 * n41 -
								n14 * n21 * n43 +
								n11 * n24 * n43 +
								n13 * n21 * n44 -
								n11 * n23 * n44) *
							detInv;
						te[10] =
							(n12 * n24 * n41 -
								n14 * n22 * n41 +
								n14 * n21 * n42 -
								n11 * n24 * n42 -
								n12 * n21 * n44 +
								n11 * n22 * n44) *
							detInv;
						te[11] =
							(n13 * n22 * n41 -
								n12 * n23 * n41 -
								n13 * n21 * n42 +
								n11 * n23 * n42 +
								n12 * n21 * n43 -
								n11 * n22 * n43) *
							detInv;

						te[12] = t14 * detInv;
						te[13] =
							(n13 * n24 * n31 -
								n14 * n23 * n31 +
								n14 * n21 * n33 -
								n11 * n24 * n33 -
								n13 * n21 * n34 +
								n11 * n23 * n34) *
							detInv;
						te[14] =
							(n14 * n22 * n31 -
								n12 * n24 * n31 -
								n14 * n21 * n32 +
								n11 * n24 * n32 +
								n12 * n21 * n34 -
								n11 * n22 * n34) *
							detInv;
						te[15] =
							(n12 * n23 * n31 -
								n13 * n22 * n31 +
								n13 * n21 * n32 -
								n11 * n23 * n32 -
								n12 * n21 * n33 +
								n11 * n22 * n33) *
							detInv;

						return this;
					}

					scale(v) {
						const te = this.elements;
						const x = v.x,
							y = v.y,
							z = v.z;

						te[0] *= x;
						te[4] *= y;
						te[8] *= z;
						te[1] *= x;
						te[5] *= y;
						te[9] *= z;
						te[2] *= x;
						te[6] *= y;
						te[10] *= z;
						te[3] *= x;
						te[7] *= y;
						te[11] *= z;

						return this;
					}

					getMaxScaleOnAxis() {
						const te = this.elements;

						const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
						const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
						const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

						return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
					}

					makeTranslation(x, y, z) {
						this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);

						return this;
					}

					makeRotationX(theta) {
						const c = Math.cos(theta),
							s = Math.sin(theta);

						this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);

						return this;
					}

					makeRotationY(theta) {
						const c = Math.cos(theta),
							s = Math.sin(theta);

						this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);

						return this;
					}

					makeRotationZ(theta) {
						const c = Math.cos(theta),
							s = Math.sin(theta);

						this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);

						return this;
					}

					makeRotationAxis(axis, angle) {
						// Based on http://www.gamedev.net/reference/articles/article1199.asp

						const c = Math.cos(angle);
						const s = Math.sin(angle);
						const t = 1 - c;
						const x = axis.x,
							y = axis.y,
							z = axis.z;
						const tx = t * x,
							ty = t * y;

						this.set(
							tx * x + c,
							tx * y - s * z,
							tx * z + s * y,
							0,
							tx * y + s * z,
							ty * y + c,
							ty * z - s * x,
							0,
							tx * z - s * y,
							ty * z + s * x,
							t * z * z + c,
							0,
							0,
							0,
							0,
							1
						);

						return this;
					}

					makeScale(x, y, z) {
						this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);

						return this;
					}

					makeShear(xy, xz, yx, yz, zx, zy) {
						this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);

						return this;
					}

					compose(position, quaternion, scale) {
						const te = this.elements;

						const x = quaternion._x,
							y = quaternion._y,
							z = quaternion._z,
							w = quaternion._w;
						const x2 = x + x,
							y2 = y + y,
							z2 = z + z;
						const xx = x * x2,
							xy = x * y2,
							xz = x * z2;
						const yy = y * y2,
							yz = y * z2,
							zz = z * z2;
						const wx = w * x2,
							wy = w * y2,
							wz = w * z2;

						const sx = scale.x,
							sy = scale.y,
							sz = scale.z;

						te[0] = (1 - (yy + zz)) * sx;
						te[1] = (xy + wz) * sx;
						te[2] = (xz - wy) * sx;
						te[3] = 0;

						te[4] = (xy - wz) * sy;
						te[5] = (1 - (xx + zz)) * sy;
						te[6] = (yz + wx) * sy;
						te[7] = 0;

						te[8] = (xz + wy) * sz;
						te[9] = (yz - wx) * sz;
						te[10] = (1 - (xx + yy)) * sz;
						te[11] = 0;

						te[12] = position.x;
						te[13] = position.y;
						te[14] = position.z;
						te[15] = 1;

						return this;
					}

					decompose(position, quaternion, scale) {
						const te = this.elements;

						let sx = _v1.set(te[0], te[1], te[2]).length();
						const sy = _v1.set(te[4], te[5], te[6]).length();
						const sz = _v1.set(te[8], te[9], te[10]).length();

						// if determine is negative, we need to invert one scale
						const det = this.determinant();
						if (det < 0) sx = -sx;

						position.x = te[12];
						position.y = te[13];
						position.z = te[14];

						// scale the rotation part
						_m1.copy(this);

						const invSX = 1 / sx;
						const invSY = 1 / sy;
						const invSZ = 1 / sz;

						_m1.elements[0] *= invSX;
						_m1.elements[1] *= invSX;
						_m1.elements[2] *= invSX;

						_m1.elements[4] *= invSY;
						_m1.elements[5] *= invSY;
						_m1.elements[6] *= invSY;

						_m1.elements[8] *= invSZ;
						_m1.elements[9] *= invSZ;
						_m1.elements[10] *= invSZ;

						quaternion.setFromRotationMatrix(_m1);

						scale.x = sx;
						scale.y = sy;
						scale.z = sz;

						return this;
					}

					makePerspective(left, right, top, bottom, near, far) {
						if (far === undefined) {
							console.warn(
								'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.'
							);
						}

						const te = this.elements;
						const x = (2 * near) / (right - left);
						const y = (2 * near) / (top - bottom);

						const a = (right + left) / (right - left);
						const b = (top + bottom) / (top - bottom);
						const c = -(far + near) / (far - near);
						const d = (-2 * far * near) / (far - near);

						te[0] = x;
						te[4] = 0;
						te[8] = a;
						te[12] = 0;
						te[1] = 0;
						te[5] = y;
						te[9] = b;
						te[13] = 0;
						te[2] = 0;
						te[6] = 0;
						te[10] = c;
						te[14] = d;
						te[3] = 0;
						te[7] = 0;
						te[11] = -1;
						te[15] = 0;

						return this;
					}

					makeOrthographic(left, right, top, bottom, near, far) {
						const te = this.elements;
						const w = 1.0 / (right - left);
						const h = 1.0 / (top - bottom);
						const p = 1.0 / (far - near);

						const x = (right + left) * w;
						const y = (top + bottom) * h;
						const z = (far + near) * p;

						te[0] = 2 * w;
						te[4] = 0;
						te[8] = 0;
						te[12] = -x;
						te[1] = 0;
						te[5] = 2 * h;
						te[9] = 0;
						te[13] = -y;
						te[2] = 0;
						te[6] = 0;
						te[10] = -2 * p;
						te[14] = -z;
						te[3] = 0;
						te[7] = 0;
						te[11] = 0;
						te[15] = 1;

						return this;
					}

					equals(matrix) {
						const te = this.elements;
						const me = matrix.elements;

						for (let i = 0; i < 16; i++) {
							if (te[i] !== me[i]) return false;
						}

						return true;
					}

					fromArray(array, offset = 0) {
						for (let i = 0; i < 16; i++) {
							this.elements[i] = array[i + offset];
						}

						return this;
					}

					toArray(array = [], offset = 0) {
						const te = this.elements;

						array[offset] = te[0];
						array[offset + 1] = te[1];
						array[offset + 2] = te[2];
						array[offset + 3] = te[3];

						array[offset + 4] = te[4];
						array[offset + 5] = te[5];
						array[offset + 6] = te[6];
						array[offset + 7] = te[7];

						array[offset + 8] = te[8];
						array[offset + 9] = te[9];
						array[offset + 10] = te[10];
						array[offset + 11] = te[11];

						array[offset + 12] = te[12];
						array[offset + 13] = te[13];
						array[offset + 14] = te[14];
						array[offset + 15] = te[15];

						return array;
					}
				}

				Matrix4.prototype.isMatrix4 = true;

				const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _m1 = /*@__PURE__*/ new Matrix4();
				const _zero = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, 0);
				const _one = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 1, 1);
				const _x = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _y = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _z = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();




				/***/
}),

/***/ "./libs/three/math/Plane.js":
/*!**********************************!*\
  !*** ./libs/three/math/Plane.js ***!
  \**********************************/
/*! exports provided: Plane */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function () { return Plane; });
/* harmony import */ var _Matrix3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix3.js */ "./libs/three/math/Matrix3.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3.js */ "./libs/three/math/Vector3.js");



				const _vector1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _vector2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _normalMatrix = /*@__PURE__*/ new _Matrix3_js__WEBPACK_IMPORTED_MODULE_0__["Matrix3"]();

				class Plane {
					constructor(normal = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](1, 0, 0), constant = 0) {
						// normal is assumed to be normalized

						this.normal = normal;
						this.constant = constant;
					}

					set(normal, constant) {
						this.normal.copy(normal);
						this.constant = constant;

						return this;
					}

					setComponents(x, y, z, w) {
						this.normal.set(x, y, z);
						this.constant = w;

						return this;
					}

					setFromNormalAndCoplanarPoint(normal, point) {
						this.normal.copy(normal);
						this.constant = -point.dot(this.normal);

						return this;
					}

					setFromCoplanarPoints(a, b, c) {
						const normal = _vector1
							.subVectors(c, b)
							.cross(_vector2.subVectors(a, b))
							.normalize();

						// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

						this.setFromNormalAndCoplanarPoint(normal, a);

						return this;
					}

					copy(plane) {
						this.normal.copy(plane.normal);
						this.constant = plane.constant;

						return this;
					}

					normalize() {
						// Note: will lead to a divide by zero if the plane is invalid.

						const inverseNormalLength = 1.0 / this.normal.length();
						this.normal.multiplyScalar(inverseNormalLength);
						this.constant *= inverseNormalLength;

						return this;
					}

					negate() {
						this.constant *= -1;
						this.normal.negate();

						return this;
					}

					distanceToPoint(point) {
						return this.normal.dot(point) + this.constant;
					}

					distanceToSphere(sphere) {
						return this.distanceToPoint(sphere.center) - sphere.radius;
					}

					projectPoint(point, target) {
						return target
							.copy(this.normal)
							.multiplyScalar(-this.distanceToPoint(point))
							.add(point);
					}

					intersectLine(line, target) {
						const direction = line.delta(_vector1);

						const denominator = this.normal.dot(direction);

						if (denominator === 0) {
							// line is coplanar, return origin
							if (this.distanceToPoint(line.start) === 0) {
								return target.copy(line.start);
							}

							// Unsure if this is the correct method to handle this case.
							return null;
						}

						const t = -(line.start.dot(this.normal) + this.constant) / denominator;

						if (t < 0 || t > 1) {
							return null;
						}

						return target
							.copy(direction)
							.multiplyScalar(t)
							.add(line.start);
					}

					intersectsLine(line) {
						// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

						const startSign = this.distanceToPoint(line.start);
						const endSign = this.distanceToPoint(line.end);

						return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0);
					}

					intersectsBox(box) {
						return box.intersectsPlane(this);
					}

					intersectsSphere(sphere) {
						return sphere.intersectsPlane(this);
					}

					coplanarPoint(target) {
						return target.copy(this.normal).multiplyScalar(-this.constant);
					}

					applyMatrix4(matrix, optionalNormalMatrix) {
						const normalMatrix =
							optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);

						const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);

						const normal = this.normal.applyMatrix3(normalMatrix).normalize();

						this.constant = -referencePoint.dot(normal);

						return this;
					}

					translate(offset) {
						this.constant -= offset.dot(this.normal);

						return this;
					}

					equals(plane) {
						return plane.normal.equals(this.normal) && plane.constant === this.constant;
					}

					clone() {
						return new this.constructor().copy(this);
					}
				}

				Plane.prototype.isPlane = true;




				/***/
}),

/***/ "./libs/three/math/Quaternion.js":
/*!***************************************!*\
  !*** ./libs/three/math/Quaternion.js ***!
  \***************************************/
/*! exports provided: Quaternion */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function () { return Quaternion; });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./libs/three/math/MathUtils.js");


				class Quaternion {
					constructor(x = 0, y = 0, z = 0, w = 1) {
						this._x = x;
						this._y = y;
						this._z = z;
						this._w = w;
					}

					static slerp(qa, qb, qm, t) {
						console.warn(
							'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.'
						);
						return qm.slerpQuaternions(qa, qb, t);
					}

					static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
						// fuzz-free, array-based Quaternion SLERP operation

						let x0 = src0[srcOffset0 + 0],
							y0 = src0[srcOffset0 + 1],
							z0 = src0[srcOffset0 + 2],
							w0 = src0[srcOffset0 + 3];

						const x1 = src1[srcOffset1 + 0],
							y1 = src1[srcOffset1 + 1],
							z1 = src1[srcOffset1 + 2],
							w1 = src1[srcOffset1 + 3];

						if (t === 0) {
							dst[dstOffset + 0] = x0;
							dst[dstOffset + 1] = y0;
							dst[dstOffset + 2] = z0;
							dst[dstOffset + 3] = w0;
							return;
						}

						if (t === 1) {
							dst[dstOffset + 0] = x1;
							dst[dstOffset + 1] = y1;
							dst[dstOffset + 2] = z1;
							dst[dstOffset + 3] = w1;
							return;
						}

						if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
							let s = 1 - t;
							const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
								dir = cos >= 0 ? 1 : -1,
								sqrSin = 1 - cos * cos;

							// Skip the Slerp for tiny steps to avoid numeric problems:
							if (sqrSin > Number.EPSILON) {
								const sin = Math.sqrt(sqrSin),
									len = Math.atan2(sin, cos * dir);

								s = Math.sin(s * len) / sin;
								t = Math.sin(t * len) / sin;
							}

							const tDir = t * dir;

							x0 = x0 * s + x1 * tDir;
							y0 = y0 * s + y1 * tDir;
							z0 = z0 * s + z1 * tDir;
							w0 = w0 * s + w1 * tDir;

							// Normalize in case we just did a lerp:
							if (s === 1 - t) {
								const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);

								x0 *= f;
								y0 *= f;
								z0 *= f;
								w0 *= f;
							}
						}

						dst[dstOffset] = x0;
						dst[dstOffset + 1] = y0;
						dst[dstOffset + 2] = z0;
						dst[dstOffset + 3] = w0;
					}

					static multiplyQuaternionsFlat(
						dst,
						dstOffset,
						src0,
						srcOffset0,
						src1,
						srcOffset1
					) {
						const x0 = src0[srcOffset0];
						const y0 = src0[srcOffset0 + 1];
						const z0 = src0[srcOffset0 + 2];
						const w0 = src0[srcOffset0 + 3];

						const x1 = src1[srcOffset1];
						const y1 = src1[srcOffset1 + 1];
						const z1 = src1[srcOffset1 + 2];
						const w1 = src1[srcOffset1 + 3];

						dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
						dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
						dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
						dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

						return dst;
					}

					get x() {
						return this._x;
					}

					set x(value) {
						this._x = value;
						this._onChangeCallback();
					}

					get y() {
						return this._y;
					}

					set y(value) {
						this._y = value;
						this._onChangeCallback();
					}

					get z() {
						return this._z;
					}

					set z(value) {
						this._z = value;
						this._onChangeCallback();
					}

					get w() {
						return this._w;
					}

					set w(value) {
						this._w = value;
						this._onChangeCallback();
					}

					set(x, y, z, w) {
						this._x = x;
						this._y = y;
						this._z = z;
						this._w = w;

						this._onChangeCallback();

						return this;
					}

					clone() {
						return new this.constructor(this._x, this._y, this._z, this._w);
					}

					copy(quaternion) {
						this._x = quaternion.x;
						this._y = quaternion.y;
						this._z = quaternion.z;
						this._w = quaternion.w;

						this._onChangeCallback();

						return this;
					}

					setFromEuler(euler, update) {
						if (!(euler && euler.isEuler)) {
							throw new Error(
								'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'
							);
						}

						const x = euler._x,
							y = euler._y,
							z = euler._z,
							order = euler._order;

						// http://www.mathworks.com/matlabcentral/fileexchange/
						// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
						//	content/SpinCalc.m

						const cos = Math.cos;
						const sin = Math.sin;

						const c1 = cos(x / 2);
						const c2 = cos(y / 2);
						const c3 = cos(z / 2);

						const s1 = sin(x / 2);
						const s2 = sin(y / 2);
						const s3 = sin(z / 2);

						switch (order) {
							case 'XYZ':
								this._x = s1 * c2 * c3 + c1 * s2 * s3;
								this._y = c1 * s2 * c3 - s1 * c2 * s3;
								this._z = c1 * c2 * s3 + s1 * s2 * c3;
								this._w = c1 * c2 * c3 - s1 * s2 * s3;
								break;

							case 'YXZ':
								this._x = s1 * c2 * c3 + c1 * s2 * s3;
								this._y = c1 * s2 * c3 - s1 * c2 * s3;
								this._z = c1 * c2 * s3 - s1 * s2 * c3;
								this._w = c1 * c2 * c3 + s1 * s2 * s3;
								break;

							case 'ZXY':
								this._x = s1 * c2 * c3 - c1 * s2 * s3;
								this._y = c1 * s2 * c3 + s1 * c2 * s3;
								this._z = c1 * c2 * s3 + s1 * s2 * c3;
								this._w = c1 * c2 * c3 - s1 * s2 * s3;
								break;

							case 'ZYX':
								this._x = s1 * c2 * c3 - c1 * s2 * s3;
								this._y = c1 * s2 * c3 + s1 * c2 * s3;
								this._z = c1 * c2 * s3 - s1 * s2 * c3;
								this._w = c1 * c2 * c3 + s1 * s2 * s3;
								break;

							case 'YZX':
								this._x = s1 * c2 * c3 + c1 * s2 * s3;
								this._y = c1 * s2 * c3 + s1 * c2 * s3;
								this._z = c1 * c2 * s3 - s1 * s2 * c3;
								this._w = c1 * c2 * c3 - s1 * s2 * s3;
								break;

							case 'XZY':
								this._x = s1 * c2 * c3 - c1 * s2 * s3;
								this._y = c1 * s2 * c3 - s1 * c2 * s3;
								this._z = c1 * c2 * s3 + s1 * s2 * c3;
								this._w = c1 * c2 * c3 + s1 * s2 * s3;
								break;

							default:
								console.warn(
									'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
									order
								);
						}

						if (update !== false) this._onChangeCallback();

						return this;
					}

					setFromAxisAngle(axis, angle) {
						// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

						// assumes axis is normalized

						const halfAngle = angle / 2,
							s = Math.sin(halfAngle);

						this._x = axis.x * s;
						this._y = axis.y * s;
						this._z = axis.z * s;
						this._w = Math.cos(halfAngle);

						this._onChangeCallback();

						return this;
					}

					setFromRotationMatrix(m) {
						// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

						// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

						const te = m.elements,
							m11 = te[0],
							m12 = te[4],
							m13 = te[8],
							m21 = te[1],
							m22 = te[5],
							m23 = te[9],
							m31 = te[2],
							m32 = te[6],
							m33 = te[10],
							trace = m11 + m22 + m33;

						if (trace > 0) {
							const s = 0.5 / Math.sqrt(trace + 1.0);

							this._w = 0.25 / s;
							this._x = (m32 - m23) * s;
							this._y = (m13 - m31) * s;
							this._z = (m21 - m12) * s;
						} else if (m11 > m22 && m11 > m33) {
							const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);

							this._w = (m32 - m23) / s;
							this._x = 0.25 * s;
							this._y = (m12 + m21) / s;
							this._z = (m13 + m31) / s;
						} else if (m22 > m33) {
							const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);

							this._w = (m13 - m31) / s;
							this._x = (m12 + m21) / s;
							this._y = 0.25 * s;
							this._z = (m23 + m32) / s;
						} else {
							const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);

							this._w = (m21 - m12) / s;
							this._x = (m13 + m31) / s;
							this._y = (m23 + m32) / s;
							this._z = 0.25 * s;
						}

						this._onChangeCallback();

						return this;
					}

					setFromUnitVectors(vFrom, vTo) {
						// assumes direction vectors vFrom and vTo are normalized

						let r = vFrom.dot(vTo) + 1;

						if (r < Number.EPSILON) {
							// vFrom and vTo point in opposite directions

							r = 0;

							if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
								this._x = -vFrom.y;
								this._y = vFrom.x;
								this._z = 0;
								this._w = r;
							} else {
								this._x = 0;
								this._y = -vFrom.z;
								this._z = vFrom.y;
								this._w = r;
							}
						} else {
							// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

							this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
							this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
							this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
							this._w = r;
						}

						return this.normalize();
					}

					angleTo(q) {
						return 2 * Math.acos(Math.abs(_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["clamp"](this.dot(q), -1, 1)));
					}

					rotateTowards(q, step) {
						const angle = this.angleTo(q);

						if (angle === 0) return this;

						const t = Math.min(1, step / angle);

						this.slerp(q, t);

						return this;
					}

					identity() {
						return this.set(0, 0, 0, 1);
					}

					invert() {
						// quaternion is assumed to have unit length

						return this.conjugate();
					}

					conjugate() {
						this._x *= -1;
						this._y *= -1;
						this._z *= -1;

						this._onChangeCallback();

						return this;
					}

					dot(v) {
						return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
					}

					lengthSq() {
						return (
							this._x * this._x +
							this._y * this._y +
							this._z * this._z +
							this._w * this._w
						);
					}

					length() {
						return Math.sqrt(
							this._x * this._x +
							this._y * this._y +
							this._z * this._z +
							this._w * this._w
						);
					}

					normalize() {
						let l = this.length();

						if (l === 0) {
							this._x = 0;
							this._y = 0;
							this._z = 0;
							this._w = 1;
						} else {
							l = 1 / l;

							this._x = this._x * l;
							this._y = this._y * l;
							this._z = this._z * l;
							this._w = this._w * l;
						}

						this._onChangeCallback();

						return this;
					}

					multiply(q, p) {
						if (p !== undefined) {
							console.warn(
								'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'
							);
							return this.multiplyQuaternions(q, p);
						}

						return this.multiplyQuaternions(this, q);
					}

					premultiply(q) {
						return this.multiplyQuaternions(q, this);
					}

					multiplyQuaternions(a, b) {
						// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

						const qax = a._x,
							qay = a._y,
							qaz = a._z,
							qaw = a._w;
						const qbx = b._x,
							qby = b._y,
							qbz = b._z,
							qbw = b._w;

						this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
						this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
						this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
						this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

						this._onChangeCallback();

						return this;
					}

					slerp(qb, t) {
						if (t === 0) return this;
						if (t === 1) return this.copy(qb);

						const x = this._x,
							y = this._y,
							z = this._z,
							w = this._w;

						// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

						let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

						if (cosHalfTheta < 0) {
							this._w = -qb._w;
							this._x = -qb._x;
							this._y = -qb._y;
							this._z = -qb._z;

							cosHalfTheta = -cosHalfTheta;
						} else {
							this.copy(qb);
						}

						if (cosHalfTheta >= 1.0) {
							this._w = w;
							this._x = x;
							this._y = y;
							this._z = z;

							return this;
						}

						const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

						if (sqrSinHalfTheta <= Number.EPSILON) {
							const s = 1 - t;
							this._w = s * w + t * this._w;
							this._x = s * x + t * this._x;
							this._y = s * y + t * this._y;
							this._z = s * z + t * this._z;

							this.normalize();
							this._onChangeCallback();

							return this;
						}

						const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
						const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
						const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
							ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

						this._w = w * ratioA + this._w * ratioB;
						this._x = x * ratioA + this._x * ratioB;
						this._y = y * ratioA + this._y * ratioB;
						this._z = z * ratioA + this._z * ratioB;

						this._onChangeCallback();

						return this;
					}

					slerpQuaternions(qa, qb, t) {
						this.copy(qa).slerp(qb, t);
					}

					random() {
						// Derived from http://planning.cs.uiuc.edu/node198.html
						// Note, this source uses w, x, y, z ordering,
						// so we swap the order below.

						const u1 = Math.random();
						const sqrt1u1 = Math.sqrt(1 - u1);
						const sqrtu1 = Math.sqrt(u1);

						const u2 = 2 * Math.PI * Math.random();

						const u3 = 2 * Math.PI * Math.random();

						return this.set(
							sqrt1u1 * Math.cos(u2),
							sqrtu1 * Math.sin(u3),
							sqrtu1 * Math.cos(u3),
							sqrt1u1 * Math.sin(u2)
						);
					}

					equals(quaternion) {
						return (
							quaternion._x === this._x &&
							quaternion._y === this._y &&
							quaternion._z === this._z &&
							quaternion._w === this._w
						);
					}

					fromArray(array, offset = 0) {
						this._x = array[offset];
						this._y = array[offset + 1];
						this._z = array[offset + 2];
						this._w = array[offset + 3];

						this._onChangeCallback();

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this._x;
						array[offset + 1] = this._y;
						array[offset + 2] = this._z;
						array[offset + 3] = this._w;

						return array;
					}

					fromBufferAttribute(attribute, index) {
						this._x = attribute.getX(index);
						this._y = attribute.getY(index);
						this._z = attribute.getZ(index);
						this._w = attribute.getW(index);

						return this;
					}

					_onChange(callback) {
						this._onChangeCallback = callback;

						return this;
					}

					_onChangeCallback() { }
				}

				Quaternion.prototype.isQuaternion = true;




				/***/
}),

/***/ "./libs/three/math/Ray.js":
/*!********************************!*\
  !*** ./libs/three/math/Ray.js ***!
  \********************************/
/*! exports provided: Ray */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function () { return Ray; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./libs/three/math/Vector3.js");


				const _vector = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _segCenter = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _segDir = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _diff = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				const _edge1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _edge2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _normal = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				class Ray {
					constructor(origin = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), direction = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](0, 0, -1)) {
						this.origin = origin;
						this.direction = direction;
					}

					set(origin, direction) {
						this.origin.copy(origin);
						this.direction.copy(direction);

						return this;
					}

					copy(ray) {
						this.origin.copy(ray.origin);
						this.direction.copy(ray.direction);

						return this;
					}

					at(t, target) {
						return target
							.copy(this.direction)
							.multiplyScalar(t)
							.add(this.origin);
					}

					lookAt(v) {
						this.direction
							.copy(v)
							.sub(this.origin)
							.normalize();

						return this;
					}

					recast(t) {
						this.origin.copy(this.at(t, _vector));

						return this;
					}

					closestPointToPoint(point, target) {
						target.subVectors(point, this.origin);

						const directionDistance = target.dot(this.direction);

						if (directionDistance < 0) {
							return target.copy(this.origin);
						}

						return target
							.copy(this.direction)
							.multiplyScalar(directionDistance)
							.add(this.origin);
					}

					distanceToPoint(point) {
						return Math.sqrt(this.distanceSqToPoint(point));
					}

					distanceSqToPoint(point) {
						const directionDistance = _vector
							.subVectors(point, this.origin)
							.dot(this.direction);

						// point behind the ray

						if (directionDistance < 0) {
							return this.origin.distanceToSquared(point);
						}

						_vector
							.copy(this.direction)
							.multiplyScalar(directionDistance)
							.add(this.origin);

						return _vector.distanceToSquared(point);
					}

					distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
						// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
						// It returns the min distance between the ray and the segment
						// defined by v0 and v1
						// It can also set two optional targets :
						// - The closest point on the ray
						// - The closest point on the segment

						_segCenter
							.copy(v0)
							.add(v1)
							.multiplyScalar(0.5);
						_segDir
							.copy(v1)
							.sub(v0)
							.normalize();
						_diff.copy(this.origin).sub(_segCenter);

						const segExtent = v0.distanceTo(v1) * 0.5;
						const a01 = -this.direction.dot(_segDir);
						const b0 = _diff.dot(this.direction);
						const b1 = -_diff.dot(_segDir);
						const c = _diff.lengthSq();
						const det = Math.abs(1 - a01 * a01);
						let s0, s1, sqrDist, extDet;

						if (det > 0) {
							// The ray and segment are not parallel.

							s0 = a01 * b1 - b0;
							s1 = a01 * b0 - b1;
							extDet = segExtent * det;

							if (s0 >= 0) {
								if (s1 >= -extDet) {
									if (s1 <= extDet) {
										// region 0
										// Minimum at interior points of ray and segment.

										const invDet = 1 / det;
										s0 *= invDet;
										s1 *= invDet;
										sqrDist =
											s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
									} else {
										// region 1

										s1 = segExtent;
										s0 = Math.max(0, -(a01 * s1 + b0));
										sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
									}
								} else {
									// region 5

									s1 = -segExtent;
									s0 = Math.max(0, -(a01 * s1 + b0));
									sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
								}
							} else {
								if (s1 <= -extDet) {
									// region 4

									s0 = Math.max(0, -(-a01 * segExtent + b0));
									s1 =
										s0 > 0
											? -segExtent
											: Math.min(Math.max(-segExtent, -b1), segExtent);
									sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
								} else if (s1 <= extDet) {
									// region 3

									s0 = 0;
									s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
									sqrDist = s1 * (s1 + 2 * b1) + c;
								} else {
									// region 2

									s0 = Math.max(0, -(a01 * segExtent + b0));
									s1 =
										s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
									sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
								}
							}
						} else {
							// Ray and segment are parallel.

							s1 = a01 > 0 ? -segExtent : segExtent;
							s0 = Math.max(0, -(a01 * s1 + b0));
							sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
						}

						if (optionalPointOnRay) {
							optionalPointOnRay
								.copy(this.direction)
								.multiplyScalar(s0)
								.add(this.origin);
						}

						if (optionalPointOnSegment) {
							optionalPointOnSegment
								.copy(_segDir)
								.multiplyScalar(s1)
								.add(_segCenter);
						}

						return sqrDist;
					}

					intersectSphere(sphere, target) {
						_vector.subVectors(sphere.center, this.origin);
						const tca = _vector.dot(this.direction);
						const d2 = _vector.dot(_vector) - tca * tca;
						const radius2 = sphere.radius * sphere.radius;

						if (d2 > radius2) return null;

						const thc = Math.sqrt(radius2 - d2);

						// t0 = first intersect point - entrance on front of sphere
						const t0 = tca - thc;

						// t1 = second intersect point - exit point on back of sphere
						const t1 = tca + thc;

						// test to see if both t0 and t1 are behind the ray - if so, return null
						if (t0 < 0 && t1 < 0) return null;

						// test to see if t0 is behind the ray:
						// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
						// in order to always return an intersect point that is in front of the ray.
						if (t0 < 0) return this.at(t1, target);

						// else t0 is in front of the ray, so return the first collision point scaled by t0
						return this.at(t0, target);
					}

					intersectsSphere(sphere) {
						return (
							this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius
						);
					}

					distanceToPlane(plane) {
						const denominator = plane.normal.dot(this.direction);

						if (denominator === 0) {
							// line is coplanar, return origin
							if (plane.distanceToPoint(this.origin) === 0) {
								return 0;
							}

							// Null is preferable to undefined since undefined means.... it is undefined

							return null;
						}

						const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

						// Return if the ray never intersects the plane

						return t >= 0 ? t : null;
					}

					intersectPlane(plane, target) {
						const t = this.distanceToPlane(plane);

						if (t === null) {
							return null;
						}

						return this.at(t, target);
					}

					intersectsPlane(plane) {
						// check if the ray lies on the plane first

						const distToPoint = plane.distanceToPoint(this.origin);

						if (distToPoint === 0) {
							return true;
						}

						const denominator = plane.normal.dot(this.direction);

						if (denominator * distToPoint < 0) {
							return true;
						}

						// ray origin is behind the plane (and is pointing behind it)

						return false;
					}

					intersectBox(box, target) {
						let tmin, tmax, tymin, tymax, tzmin, tzmax;

						const invdirx = 1 / this.direction.x,
							invdiry = 1 / this.direction.y,
							invdirz = 1 / this.direction.z;

						const origin = this.origin;

						if (invdirx >= 0) {
							tmin = (box.min.x - origin.x) * invdirx;
							tmax = (box.max.x - origin.x) * invdirx;
						} else {
							tmin = (box.max.x - origin.x) * invdirx;
							tmax = (box.min.x - origin.x) * invdirx;
						}

						if (invdiry >= 0) {
							tymin = (box.min.y - origin.y) * invdiry;
							tymax = (box.max.y - origin.y) * invdiry;
						} else {
							tymin = (box.max.y - origin.y) * invdiry;
							tymax = (box.min.y - origin.y) * invdiry;
						}

						if (tmin > tymax || tymin > tmax) return null;

						// These lines also handle the case where tmin or tmax is NaN
						// (result of 0 * Infinity). x !== x returns true if x is NaN

						if (tymin > tmin || tmin !== tmin) tmin = tymin;

						if (tymax < tmax || tmax !== tmax) tmax = tymax;

						if (invdirz >= 0) {
							tzmin = (box.min.z - origin.z) * invdirz;
							tzmax = (box.max.z - origin.z) * invdirz;
						} else {
							tzmin = (box.max.z - origin.z) * invdirz;
							tzmax = (box.min.z - origin.z) * invdirz;
						}

						if (tmin > tzmax || tzmin > tmax) return null;

						if (tzmin > tmin || tmin !== tmin) tmin = tzmin;

						if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

						//return point closest to the ray (positive side)

						if (tmax < 0) return null;

						return this.at(tmin >= 0 ? tmin : tmax, target);
					}

					intersectsBox(box) {
						return this.intersectBox(box, _vector) !== null;
					}

					intersectTriangle(a, b, c, backfaceCulling, target) {
						// Compute the offset origin, edges, and normal.

						// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

						_edge1.subVectors(b, a);
						_edge2.subVectors(c, a);
						_normal.crossVectors(_edge1, _edge2);

						// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
						// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
						//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
						//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
						//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
						let DdN = this.direction.dot(_normal);
						let sign;

						if (DdN > 0) {
							if (backfaceCulling) return null;
							sign = 1;
						} else if (DdN < 0) {
							sign = -1;
							DdN = -DdN;
						} else {
							return null;
						}

						_diff.subVectors(this.origin, a);
						const DdQxE2 =
							sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

						// b1 < 0, no intersection
						if (DdQxE2 < 0) {
							return null;
						}

						const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

						// b2 < 0, no intersection
						if (DdE1xQ < 0) {
							return null;
						}

						// b1+b2 > 1, no intersection
						if (DdQxE2 + DdE1xQ > DdN) {
							return null;
						}

						// Line intersects triangle, check if ray does.
						const QdN = -sign * _diff.dot(_normal);

						// t < 0, no intersection
						if (QdN < 0) {
							return null;
						}

						// Ray intersects triangle.
						return this.at(QdN / DdN, target);
					}

					applyMatrix4(matrix4) {
						this.origin.applyMatrix4(matrix4);
						this.direction.transformDirection(matrix4);

						return this;
					}

					equals(ray) {
						return (
							ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
						);
					}

					clone() {
						return new this.constructor().copy(this);
					}
				}




				/***/
}),

/***/ "./libs/three/math/Sphere.js":
/*!***********************************!*\
  !*** ./libs/three/math/Sphere.js ***!
  \***********************************/
/*! exports provided: Sphere */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function () { return Sphere; });
/* harmony import */ var _Box3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Box3.js */ "./libs/three/math/Box3.js");
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Vector3.js */ "./libs/three/math/Vector3.js");



				const _box = /*@__PURE__*/ new _Box3_js__WEBPACK_IMPORTED_MODULE_0__["Box3"]();
				const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _toFarthestPoint = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _toPoint = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

				class Sphere {
					constructor(center = new _Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"](), radius = -1) {
						this.center = center;
						this.radius = radius;
					}

					set(center, radius) {
						this.center.copy(center);
						this.radius = radius;

						return this;
					}

					setFromPoints(points, optionalCenter) {
						const center = this.center;

						if (optionalCenter !== undefined) {
							center.copy(optionalCenter);
						} else {
							_box.setFromPoints(points).getCenter(center);
						}

						let maxRadiusSq = 0;

						for (let i = 0, il = points.length; i < il; i++) {
							maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
						}

						this.radius = Math.sqrt(maxRadiusSq);

						return this;
					}

					copy(sphere) {
						this.center.copy(sphere.center);
						this.radius = sphere.radius;

						return this;
					}

					isEmpty() {
						return this.radius < 0;
					}

					makeEmpty() {
						this.center.set(0, 0, 0);
						this.radius = -1;

						return this;
					}

					containsPoint(point) {
						return point.distanceToSquared(this.center) <= this.radius * this.radius;
					}

					distanceToPoint(point) {
						return point.distanceTo(this.center) - this.radius;
					}

					intersectsSphere(sphere) {
						const radiusSum = this.radius + sphere.radius;

						return (
							sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
						);
					}

					intersectsBox(box) {
						return box.intersectsSphere(this);
					}

					intersectsPlane(plane) {
						return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
					}

					clampPoint(point, target) {
						const deltaLengthSq = this.center.distanceToSquared(point);

						target.copy(point);

						if (deltaLengthSq > this.radius * this.radius) {
							target.sub(this.center).normalize();
							target.multiplyScalar(this.radius).add(this.center);
						}

						return target;
					}

					getBoundingBox(target) {
						if (this.isEmpty()) {
							// Empty sphere produces empty bounding box
							target.makeEmpty();
							return target;
						}

						target.set(this.center, this.center);
						target.expandByScalar(this.radius);

						return target;
					}

					applyMatrix4(matrix) {
						this.center.applyMatrix4(matrix);
						this.radius = this.radius * matrix.getMaxScaleOnAxis();

						return this;
					}

					translate(offset) {
						this.center.add(offset);

						return this;
					}

					expandByPoint(point) {
						// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

						_toPoint.subVectors(point, this.center);

						const lengthSq = _toPoint.lengthSq();

						if (lengthSq > this.radius * this.radius) {
							const length = Math.sqrt(lengthSq);
							const missingRadiusHalf = (length - this.radius) * 0.5;

							// Nudge this sphere towards the target point. Add half the missing distance to radius,
							// and the other half to position. This gives a tighter enclosure, instead of if
							// the whole missing distance were just added to radius.

							this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));
							this.radius += missingRadiusHalf;
						}

						return this;
					}

					union(sphere) {
						// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

						// To enclose another sphere into this sphere, we only need to enclose two points:
						// 1) Enclose the farthest point on the other sphere into this sphere.
						// 2) Enclose the opposite point of the farthest point into this sphere.

						_toFarthestPoint
							.subVectors(sphere.center, this.center)
							.normalize()
							.multiplyScalar(sphere.radius);

						this.expandByPoint(_v1.copy(sphere.center).add(_toFarthestPoint));
						this.expandByPoint(_v1.copy(sphere.center).sub(_toFarthestPoint));

						return this;
					}

					equals(sphere) {
						return sphere.center.equals(this.center) && sphere.radius === this.radius;
					}

					clone() {
						return new this.constructor().copy(this);
					}
				}




				/***/
}),

/***/ "./libs/three/math/Spherical.js":
/*!**************************************!*\
  !*** ./libs/three/math/Spherical.js ***!
  \**************************************/
/*! exports provided: Spherical */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function () { return Spherical; });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./libs/three/math/MathUtils.js");
				/**
				 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
				 *
				 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
				 * The azimuthal angle (theta) is measured from the positive z-axis.
				 */



				class Spherical {
					constructor(radius = 1, phi = 0, theta = 0) {
						this.radius = radius;
						this.phi = phi; // polar angle
						this.theta = theta; // azimuthal angle

						return this;
					}

					set(radius, phi, theta) {
						this.radius = radius;
						this.phi = phi;
						this.theta = theta;

						return this;
					}

					copy(other) {
						this.radius = other.radius;
						this.phi = other.phi;
						this.theta = other.theta;

						return this;
					}

					// restrict phi to be betwee EPS and PI-EPS
					makeSafe() {
						const EPS = 0.000001;
						this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));

						return this;
					}

					setFromVector3(v) {
						return this.setFromCartesianCoords(v.x, v.y, v.z);
					}

					setFromCartesianCoords(x, y, z) {
						this.radius = Math.sqrt(x * x + y * y + z * z);

						if (this.radius === 0) {
							this.theta = 0;
							this.phi = 0;
						} else {
							this.theta = Math.atan2(x, z);
							this.phi = Math.acos(_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["clamp"](y / this.radius, -1, 1));
						}

						return this;
					}

					clone() {
						return new this.constructor().copy(this);
					}
				}




				/***/
}),

/***/ "./libs/three/math/Triangle.js":
/*!*************************************!*\
  !*** ./libs/three/math/Triangle.js ***!
  \*************************************/
/*! exports provided: Triangle */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function () { return Triangle; });
/* harmony import */ var _Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Vector3.js */ "./libs/three/math/Vector3.js");


				const _v0 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _v1 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _v2 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _v3 = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				const _vab = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _vac = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _vbc = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _vap = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _vbp = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _vcp = /*@__PURE__*/ new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				class Triangle {
					constructor(a = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), b = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](), c = new _Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]()) {
						this.a = a;
						this.b = b;
						this.c = c;
					}

					static getNormal(a, b, c, target) {
						target.subVectors(c, b);
						_v0.subVectors(a, b);
						target.cross(_v0);

						const targetLengthSq = target.lengthSq();
						if (targetLengthSq > 0) {
							return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
						}

						return target.set(0, 0, 0);
					}

					// static/instance method to calculate barycentric coordinates
					// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
					static getBarycoord(point, a, b, c, target) {
						_v0.subVectors(c, a);
						_v1.subVectors(b, a);
						_v2.subVectors(point, a);

						const dot00 = _v0.dot(_v0);
						const dot01 = _v0.dot(_v1);
						const dot02 = _v0.dot(_v2);
						const dot11 = _v1.dot(_v1);
						const dot12 = _v1.dot(_v2);

						const denom = dot00 * dot11 - dot01 * dot01;

						// collinear or singular triangle
						if (denom === 0) {
							// arbitrary location outside of triangle?
							// not sure if this is the best idea, maybe should be returning undefined
							return target.set(-2, -1, -1);
						}

						const invDenom = 1 / denom;
						const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
						const v = (dot00 * dot12 - dot01 * dot02) * invDenom;

						// barycentric coordinates must always sum to 1
						return target.set(1 - u - v, v, u);
					}

					static containsPoint(point, a, b, c) {
						this.getBarycoord(point, a, b, c, _v3);

						return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
					}

					static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
						this.getBarycoord(point, p1, p2, p3, _v3);

						target.set(0, 0);
						target.addScaledVector(uv1, _v3.x);
						target.addScaledVector(uv2, _v3.y);
						target.addScaledVector(uv3, _v3.z);

						return target;
					}

					static isFrontFacing(a, b, c, direction) {
						_v0.subVectors(c, b);
						_v1.subVectors(a, b);

						// strictly front facing
						return _v0.cross(_v1).dot(direction) < 0 ? true : false;
					}

					set(a, b, c) {
						this.a.copy(a);
						this.b.copy(b);
						this.c.copy(c);

						return this;
					}

					setFromPointsAndIndices(points, i0, i1, i2) {
						this.a.copy(points[i0]);
						this.b.copy(points[i1]);
						this.c.copy(points[i2]);

						return this;
					}

					setFromAttributeAndIndices(attribute, i0, i1, i2) {
						this.a.fromBufferAttribute(attribute, i0);
						this.b.fromBufferAttribute(attribute, i1);
						this.c.fromBufferAttribute(attribute, i2);

						return this;
					}

					clone() {
						return new this.constructor().copy(this);
					}

					copy(triangle) {
						this.a.copy(triangle.a);
						this.b.copy(triangle.b);
						this.c.copy(triangle.c);

						return this;
					}

					getArea() {
						_v0.subVectors(this.c, this.b);
						_v1.subVectors(this.a, this.b);

						return _v0.cross(_v1).length() * 0.5;
					}

					getMidpoint(target) {
						return target
							.addVectors(this.a, this.b)
							.add(this.c)
							.multiplyScalar(1 / 3);
					}

					getNormal(target) {
						return Triangle.getNormal(this.a, this.b, this.c, target);
					}

					getPlane(target) {
						return target.setFromCoplanarPoints(this.a, this.b, this.c);
					}

					getBarycoord(point, target) {
						return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
					}

					getUV(point, uv1, uv2, uv3, target) {
						return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
					}

					containsPoint(point) {
						return Triangle.containsPoint(point, this.a, this.b, this.c);
					}

					isFrontFacing(direction) {
						return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
					}

					intersectsBox(box) {
						return box.intersectsTriangle(this);
					}

					closestPointToPoint(p, target) {
						const a = this.a,
							b = this.b,
							c = this.c;
						let v, w;

						// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
						// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
						// under the accompanying license; see chapter 5.1.5 for detailed explanation.
						// basically, we're distinguishing which of the voronoi regions of the triangle
						// the point lies in with the minimum amount of redundant computation.

						_vab.subVectors(b, a);
						_vac.subVectors(c, a);
						_vap.subVectors(p, a);
						const d1 = _vab.dot(_vap);
						const d2 = _vac.dot(_vap);
						if (d1 <= 0 && d2 <= 0) {
							// vertex region of A; barycentric coords (1, 0, 0)
							return target.copy(a);
						}

						_vbp.subVectors(p, b);
						const d3 = _vab.dot(_vbp);
						const d4 = _vac.dot(_vbp);
						if (d3 >= 0 && d4 <= d3) {
							// vertex region of B; barycentric coords (0, 1, 0)
							return target.copy(b);
						}

						const vc = d1 * d4 - d3 * d2;
						if (vc <= 0 && d1 >= 0 && d3 <= 0) {
							v = d1 / (d1 - d3);
							// edge region of AB; barycentric coords (1-v, v, 0)
							return target.copy(a).addScaledVector(_vab, v);
						}

						_vcp.subVectors(p, c);
						const d5 = _vab.dot(_vcp);
						const d6 = _vac.dot(_vcp);
						if (d6 >= 0 && d5 <= d6) {
							// vertex region of C; barycentric coords (0, 0, 1)
							return target.copy(c);
						}

						const vb = d5 * d2 - d1 * d6;
						if (vb <= 0 && d2 >= 0 && d6 <= 0) {
							w = d2 / (d2 - d6);
							// edge region of AC; barycentric coords (1-w, 0, w)
							return target.copy(a).addScaledVector(_vac, w);
						}

						const va = d3 * d6 - d5 * d4;
						if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
							_vbc.subVectors(c, b);
							w = (d4 - d3) / (d4 - d3 + (d5 - d6));
							// edge region of BC; barycentric coords (0, 1-w, w)
							return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
						}

						// face region
						const denom = 1 / (va + vb + vc);
						// u = va * denom
						v = vb * denom;
						w = vc * denom;

						return target
							.copy(a)
							.addScaledVector(_vab, v)
							.addScaledVector(_vac, w);
					}

					equals(triangle) {
						return (
							triangle.a.equals(this.a) &&
							triangle.b.equals(this.b) &&
							triangle.c.equals(this.c)
						);
					}
				}




				/***/
}),

/***/ "./libs/three/math/Vector2.js":
/*!************************************!*\
  !*** ./libs/three/math/Vector2.js ***!
  \************************************/
/*! exports provided: Vector2 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function () { return Vector2; });
				class Vector2 {
					constructor(x = 0, y = 0) {
						this.x = x;
						this.y = y;
					}

					get width() {
						return this.x;
					}

					set width(value) {
						this.x = value;
					}

					get height() {
						return this.y;
					}

					set height(value) {
						this.y = value;
					}

					set(x, y) {
						this.x = x;
						this.y = y;

						return this;
					}

					setScalar(scalar) {
						this.x = scalar;
						this.y = scalar;

						return this;
					}

					setX(x) {
						this.x = x;

						return this;
					}

					setY(y) {
						this.y = y;

						return this;
					}

					setComponent(index, value) {
						switch (index) {
							case 0:
								this.x = value;
								break;
							case 1:
								this.y = value;
								break;
							default:
								throw new Error('index is out of range: ' + index);
						}

						return this;
					}

					getComponent(index) {
						switch (index) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							default:
								throw new Error('index is out of range: ' + index);
						}
					}

					clone() {
						return new this.constructor(this.x, this.y);
					}

					copy(v) {
						this.x = v.x;
						this.y = v.y;

						return this;
					}

					add(v, w) {
						if (w !== undefined) {
							console.warn(
								'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
							);
							return this.addVectors(v, w);
						}

						this.x += v.x;
						this.y += v.y;

						return this;
					}

					addScalar(s) {
						this.x += s;
						this.y += s;

						return this;
					}

					addVectors(a, b) {
						this.x = a.x + b.x;
						this.y = a.y + b.y;

						return this;
					}

					addScaledVector(v, s) {
						this.x += v.x * s;
						this.y += v.y * s;

						return this;
					}

					sub(v, w) {
						if (w !== undefined) {
							console.warn(
								'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
							);
							return this.subVectors(v, w);
						}

						this.x -= v.x;
						this.y -= v.y;

						return this;
					}

					subScalar(s) {
						this.x -= s;
						this.y -= s;

						return this;
					}

					subVectors(a, b) {
						this.x = a.x - b.x;
						this.y = a.y - b.y;

						return this;
					}

					multiply(v) {
						this.x *= v.x;
						this.y *= v.y;

						return this;
					}

					multiplyScalar(scalar) {
						this.x *= scalar;
						this.y *= scalar;

						return this;
					}

					divide(v) {
						this.x /= v.x;
						this.y /= v.y;

						return this;
					}

					divideScalar(scalar) {
						return this.multiplyScalar(1 / scalar);
					}

					applyMatrix3(m) {
						const x = this.x,
							y = this.y;
						const e = m.elements;

						this.x = e[0] * x + e[3] * y + e[6];
						this.y = e[1] * x + e[4] * y + e[7];

						return this;
					}

					min(v) {
						this.x = Math.min(this.x, v.x);
						this.y = Math.min(this.y, v.y);

						return this;
					}

					max(v) {
						this.x = Math.max(this.x, v.x);
						this.y = Math.max(this.y, v.y);

						return this;
					}

					clamp(min, max) {
						// assumes min < max, componentwise

						this.x = Math.max(min.x, Math.min(max.x, this.x));
						this.y = Math.max(min.y, Math.min(max.y, this.y));

						return this;
					}

					clampScalar(minVal, maxVal) {
						this.x = Math.max(minVal, Math.min(maxVal, this.x));
						this.y = Math.max(minVal, Math.min(maxVal, this.y));

						return this;
					}

					clampLength(min, max) {
						const length = this.length();

						return this.divideScalar(length || 1).multiplyScalar(
							Math.max(min, Math.min(max, length))
						);
					}

					floor() {
						this.x = Math.floor(this.x);
						this.y = Math.floor(this.y);

						return this;
					}

					ceil() {
						this.x = Math.ceil(this.x);
						this.y = Math.ceil(this.y);

						return this;
					}

					round() {
						this.x = Math.round(this.x);
						this.y = Math.round(this.y);

						return this;
					}

					roundToZero() {
						this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
						this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);

						return this;
					}

					negate() {
						this.x = -this.x;
						this.y = -this.y;

						return this;
					}

					dot(v) {
						return this.x * v.x + this.y * v.y;
					}

					cross(v) {
						return this.x * v.y - this.y * v.x;
					}

					lengthSq() {
						return this.x * this.x + this.y * this.y;
					}

					length() {
						return Math.sqrt(this.x * this.x + this.y * this.y);
					}

					manhattanLength() {
						return Math.abs(this.x) + Math.abs(this.y);
					}

					normalize() {
						return this.divideScalar(this.length() || 1);
					}

					angle() {
						// computes the angle in radians with respect to the positive x-axis

						const angle = Math.atan2(-this.y, -this.x) + Math.PI;

						return angle;
					}

					distanceTo(v) {
						return Math.sqrt(this.distanceToSquared(v));
					}

					distanceToSquared(v) {
						const dx = this.x - v.x,
							dy = this.y - v.y;
						return dx * dx + dy * dy;
					}

					manhattanDistanceTo(v) {
						return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
					}

					setLength(length) {
						return this.normalize().multiplyScalar(length);
					}

					lerp(v, alpha) {
						this.x += (v.x - this.x) * alpha;
						this.y += (v.y - this.y) * alpha;

						return this;
					}

					lerpVectors(v1, v2, alpha) {
						this.x = v1.x + (v2.x - v1.x) * alpha;
						this.y = v1.y + (v2.y - v1.y) * alpha;

						return this;
					}

					equals(v) {
						return v.x === this.x && v.y === this.y;
					}

					fromArray(array, offset = 0) {
						this.x = array[offset];
						this.y = array[offset + 1];

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this.x;
						array[offset + 1] = this.y;

						return array;
					}

					fromBufferAttribute(attribute, index, offset) {
						if (offset !== undefined) {
							console.warn(
								'THREE.Vector2: offset has been removed from .fromBufferAttribute().'
							);
						}

						this.x = attribute.getX(index);
						this.y = attribute.getY(index);

						return this;
					}

					rotateAround(center, angle) {
						const c = Math.cos(angle),
							s = Math.sin(angle);

						const x = this.x - center.x;
						const y = this.y - center.y;

						this.x = x * c - y * s + center.x;
						this.y = x * s + y * c + center.y;

						return this;
					}

					random() {
						this.x = Math.random();
						this.y = Math.random();

						return this;
					}

					*[Symbol.iterator]() {
						yield this.x;
						yield this.y;
					}
				}

				Vector2.prototype.isVector2 = true;




				/***/
}),

/***/ "./libs/three/math/Vector3.js":
/*!************************************!*\
  !*** ./libs/three/math/Vector3.js ***!
  \************************************/
/*! exports provided: Vector3 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function () { return Vector3; });
/* harmony import */ var _MathUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MathUtils.js */ "./libs/three/math/MathUtils.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Quaternion.js */ "./libs/three/math/Quaternion.js");



				class Vector3 {
					constructor(x = 0, y = 0, z = 0) {
						this.x = x;
						this.y = y;
						this.z = z;
					}

					set(x, y, z) {
						if (z === undefined) z = this.z; // sprite.scale.set(x,y)

						this.x = x;
						this.y = y;
						this.z = z;

						return this;
					}

					setScalar(scalar) {
						this.x = scalar;
						this.y = scalar;
						this.z = scalar;

						return this;
					}

					setX(x) {
						this.x = x;

						return this;
					}

					setY(y) {
						this.y = y;

						return this;
					}

					setZ(z) {
						this.z = z;

						return this;
					}

					setComponent(index, value) {
						switch (index) {
							case 0:
								this.x = value;
								break;
							case 1:
								this.y = value;
								break;
							case 2:
								this.z = value;
								break;
							default:
								throw new Error('index is out of range: ' + index);
						}

						return this;
					}

					getComponent(index) {
						switch (index) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw new Error('index is out of range: ' + index);
						}
					}

					clone() {
						return new this.constructor(this.x, this.y, this.z);
					}

					copy(v) {
						this.x = v.x;
						this.y = v.y;
						this.z = v.z;

						return this;
					}

					add(v, w) {
						if (w !== undefined) {
							console.warn(
								'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
							);
							return this.addVectors(v, w);
						}

						this.x += v.x;
						this.y += v.y;
						this.z += v.z;

						return this;
					}

					addScalar(s) {
						this.x += s;
						this.y += s;
						this.z += s;

						return this;
					}

					addVectors(a, b) {
						this.x = a.x + b.x;
						this.y = a.y + b.y;
						this.z = a.z + b.z;

						return this;
					}

					addScaledVector(v, s) {
						this.x += v.x * s;
						this.y += v.y * s;
						this.z += v.z * s;

						return this;
					}

					sub(v, w) {
						if (w !== undefined) {
							console.warn(
								'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
							);
							return this.subVectors(v, w);
						}

						this.x -= v.x;
						this.y -= v.y;
						this.z -= v.z;

						return this;
					}

					subScalar(s) {
						this.x -= s;
						this.y -= s;
						this.z -= s;

						return this;
					}

					subVectors(a, b) {
						this.x = a.x - b.x;
						this.y = a.y - b.y;
						this.z = a.z - b.z;

						return this;
					}

					multiply(v, w) {
						if (w !== undefined) {
							console.warn(
								'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'
							);
							return this.multiplyVectors(v, w);
						}

						this.x *= v.x;
						this.y *= v.y;
						this.z *= v.z;

						return this;
					}

					multiplyScalar(scalar) {
						this.x *= scalar;
						this.y *= scalar;
						this.z *= scalar;

						return this;
					}

					multiplyVectors(a, b) {
						this.x = a.x * b.x;
						this.y = a.y * b.y;
						this.z = a.z * b.z;

						return this;
					}

					applyEuler(euler) {
						if (!(euler && euler.isEuler)) {
							console.error(
								'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.'
							);
						}

						return this.applyQuaternion(_quaternion.setFromEuler(euler));
					}

					applyAxisAngle(axis, angle) {
						return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
					}

					applyMatrix3(m) {
						const x = this.x,
							y = this.y,
							z = this.z;
						const e = m.elements;

						this.x = e[0] * x + e[3] * y + e[6] * z;
						this.y = e[1] * x + e[4] * y + e[7] * z;
						this.z = e[2] * x + e[5] * y + e[8] * z;

						return this;
					}

					applyNormalMatrix(m) {
						return this.applyMatrix3(m).normalize();
					}

					applyMatrix4(m) {
						const x = this.x,
							y = this.y,
							z = this.z;
						const e = m.elements;

						const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);

						this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
						this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
						this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;

						return this;
					}

					applyQuaternion(q) {
						const x = this.x,
							y = this.y,
							z = this.z;
						const qx = q.x,
							qy = q.y,
							qz = q.z,
							qw = q.w;

						// calculate quat * vector

						const ix = qw * x + qy * z - qz * y;
						const iy = qw * y + qz * x - qx * z;
						const iz = qw * z + qx * y - qy * x;
						const iw = -qx * x - qy * y - qz * z;

						// calculate result * inverse quat

						this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
						this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
						this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

						return this;
					}

					project(camera) {
						return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(
							camera.projectionMatrix
						);
					}

					unproject(camera) {
						return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(
							camera.matrixWorld
						);
					}

					transformDirection(m) {
						// input: THREE.Matrix4 affine matrix
						// vector interpreted as a direction

						const x = this.x,
							y = this.y,
							z = this.z;
						const e = m.elements;

						this.x = e[0] * x + e[4] * y + e[8] * z;
						this.y = e[1] * x + e[5] * y + e[9] * z;
						this.z = e[2] * x + e[6] * y + e[10] * z;

						return this.normalize();
					}

					divide(v) {
						this.x /= v.x;
						this.y /= v.y;
						this.z /= v.z;

						return this;
					}

					divideScalar(scalar) {
						return this.multiplyScalar(1 / scalar);
					}

					min(v) {
						this.x = Math.min(this.x, v.x);
						this.y = Math.min(this.y, v.y);
						this.z = Math.min(this.z, v.z);

						return this;
					}

					max(v) {
						this.x = Math.max(this.x, v.x);
						this.y = Math.max(this.y, v.y);
						this.z = Math.max(this.z, v.z);

						return this;
					}

					clamp(min, max) {
						// assumes min < max, componentwise

						this.x = Math.max(min.x, Math.min(max.x, this.x));
						this.y = Math.max(min.y, Math.min(max.y, this.y));
						this.z = Math.max(min.z, Math.min(max.z, this.z));

						return this;
					}

					clampScalar(minVal, maxVal) {
						this.x = Math.max(minVal, Math.min(maxVal, this.x));
						this.y = Math.max(minVal, Math.min(maxVal, this.y));
						this.z = Math.max(minVal, Math.min(maxVal, this.z));

						return this;
					}

					clampLength(min, max) {
						const length = this.length();

						return this.divideScalar(length || 1).multiplyScalar(
							Math.max(min, Math.min(max, length))
						);
					}

					floor() {
						this.x = Math.floor(this.x);
						this.y = Math.floor(this.y);
						this.z = Math.floor(this.z);

						return this;
					}

					ceil() {
						this.x = Math.ceil(this.x);
						this.y = Math.ceil(this.y);
						this.z = Math.ceil(this.z);

						return this;
					}

					round() {
						this.x = Math.round(this.x);
						this.y = Math.round(this.y);
						this.z = Math.round(this.z);

						return this;
					}

					roundToZero() {
						this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
						this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
						this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);

						return this;
					}

					negate() {
						this.x = -this.x;
						this.y = -this.y;
						this.z = -this.z;

						return this;
					}

					dot(v) {
						return this.x * v.x + this.y * v.y + this.z * v.z;
					}

					// TODO lengthSquared?

					lengthSq() {
						return this.x * this.x + this.y * this.y + this.z * this.z;
					}

					length() {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
					}

					manhattanLength() {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
					}

					normalize() {
						return this.divideScalar(this.length() || 1);
					}

					setLength(length) {
						return this.normalize().multiplyScalar(length);
					}

					lerp(v, alpha) {
						this.x += (v.x - this.x) * alpha;
						this.y += (v.y - this.y) * alpha;
						this.z += (v.z - this.z) * alpha;

						return this;
					}

					lerpVectors(v1, v2, alpha) {
						this.x = v1.x + (v2.x - v1.x) * alpha;
						this.y = v1.y + (v2.y - v1.y) * alpha;
						this.z = v1.z + (v2.z - v1.z) * alpha;

						return this;
					}

					cross(v, w) {
						if (w !== undefined) {
							console.warn(
								'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'
							);
							return this.crossVectors(v, w);
						}

						return this.crossVectors(this, v);
					}

					crossVectors(a, b) {
						const ax = a.x,
							ay = a.y,
							az = a.z;
						const bx = b.x,
							by = b.y,
							bz = b.z;

						this.x = ay * bz - az * by;
						this.y = az * bx - ax * bz;
						this.z = ax * by - ay * bx;

						return this;
					}

					projectOnVector(v) {
						const denominator = v.lengthSq();

						if (denominator === 0) return this.set(0, 0, 0);

						const scalar = v.dot(this) / denominator;

						return this.copy(v).multiplyScalar(scalar);
					}

					projectOnPlane(planeNormal) {
						_vector.copy(this).projectOnVector(planeNormal);

						return this.sub(_vector);
					}

					reflect(normal) {
						// reflect incident vector off plane orthogonal to normal
						// normal is assumed to have unit length

						return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
					}

					angleTo(v) {
						const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());

						if (denominator === 0) return Math.PI / 2;

						const theta = this.dot(v) / denominator;

						// clamp, to handle numerical problems

						return Math.acos(_MathUtils_js__WEBPACK_IMPORTED_MODULE_0__["clamp"](theta, -1, 1));
					}

					distanceTo(v) {
						return Math.sqrt(this.distanceToSquared(v));
					}

					distanceToSquared(v) {
						const dx = this.x - v.x,
							dy = this.y - v.y,
							dz = this.z - v.z;

						return dx * dx + dy * dy + dz * dz;
					}

					manhattanDistanceTo(v) {
						return (
							Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
						);
					}

					setFromSpherical(s) {
						return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
					}

					setFromSphericalCoords(radius, phi, theta) {
						const sinPhiRadius = Math.sin(phi) * radius;

						this.x = sinPhiRadius * Math.sin(theta);
						this.y = Math.cos(phi) * radius;
						this.z = sinPhiRadius * Math.cos(theta);

						return this;
					}

					setFromCylindrical(c) {
						return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
					}

					setFromCylindricalCoords(radius, theta, y) {
						this.x = radius * Math.sin(theta);
						this.y = y;
						this.z = radius * Math.cos(theta);

						return this;
					}

					setFromMatrixPosition(m) {
						const e = m.elements;

						this.x = e[12];
						this.y = e[13];
						this.z = e[14];

						return this;
					}

					setFromMatrixScale(m) {
						const sx = this.setFromMatrixColumn(m, 0).length();
						const sy = this.setFromMatrixColumn(m, 1).length();
						const sz = this.setFromMatrixColumn(m, 2).length();

						this.x = sx;
						this.y = sy;
						this.z = sz;

						return this;
					}

					setFromMatrixColumn(m, index) {
						return this.fromArray(m.elements, index * 4);
					}

					setFromMatrix3Column(m, index) {
						return this.fromArray(m.elements, index * 3);
					}

					equals(v) {
						return v.x === this.x && v.y === this.y && v.z === this.z;
					}

					fromArray(array, offset = 0) {
						this.x = array[offset];
						this.y = array[offset + 1];
						this.z = array[offset + 2];

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this.x;
						array[offset + 1] = this.y;
						array[offset + 2] = this.z;

						return array;
					}

					fromBufferAttribute(attribute, index, offset) {
						if (offset !== undefined) {
							console.warn(
								'THREE.Vector3: offset has been removed from .fromBufferAttribute().'
							);
						}

						this.x = attribute.getX(index);
						this.y = attribute.getY(index);
						this.z = attribute.getZ(index);

						return this;
					}

					random() {
						this.x = Math.random();
						this.y = Math.random();
						this.z = Math.random();

						return this;
					}

					randomDirection() {
						// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

						const u = (Math.random() - 0.5) * 2;
						const t = Math.random() * Math.PI * 2;
						const f = Math.sqrt(1 - u ** 2);

						this.x = f * Math.cos(t);
						this.y = f * Math.sin(t);
						this.z = u;

						return this;
					}

					*[Symbol.iterator]() {
						yield this.x;
						yield this.y;
						yield this.z;
					}
				}

				Vector3.prototype.isVector3 = true;

				const _vector = /*@__PURE__*/ new Vector3();
				const _quaternion = /*@__PURE__*/ new _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"]();




				/***/
}),

/***/ "./libs/three/math/Vector4.js":
/*!************************************!*\
  !*** ./libs/three/math/Vector4.js ***!
  \************************************/
/*! exports provided: Vector4 */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function () { return Vector4; });
				class Vector4 {
					constructor(x = 0, y = 0, z = 0, w = 1) {
						this.x = x;
						this.y = y;
						this.z = z;
						this.w = w;
					}

					get width() {
						return this.z;
					}

					set width(value) {
						this.z = value;
					}

					get height() {
						return this.w;
					}

					set height(value) {
						this.w = value;
					}

					set(x, y, z, w) {
						this.x = x;
						this.y = y;
						this.z = z;
						this.w = w;

						return this;
					}

					setScalar(scalar) {
						this.x = scalar;
						this.y = scalar;
						this.z = scalar;
						this.w = scalar;

						return this;
					}

					setX(x) {
						this.x = x;

						return this;
					}

					setY(y) {
						this.y = y;

						return this;
					}

					setZ(z) {
						this.z = z;

						return this;
					}

					setW(w) {
						this.w = w;

						return this;
					}

					setComponent(index, value) {
						switch (index) {
							case 0:
								this.x = value;
								break;
							case 1:
								this.y = value;
								break;
							case 2:
								this.z = value;
								break;
							case 3:
								this.w = value;
								break;
							default:
								throw new Error('index is out of range: ' + index);
						}

						return this;
					}

					getComponent(index) {
						switch (index) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							case 3:
								return this.w;
							default:
								throw new Error('index is out of range: ' + index);
						}
					}

					clone() {
						return new this.constructor(this.x, this.y, this.z, this.w);
					}

					copy(v) {
						this.x = v.x;
						this.y = v.y;
						this.z = v.z;
						this.w = v.w !== undefined ? v.w : 1;

						return this;
					}

					add(v, w) {
						if (w !== undefined) {
							console.warn(
								'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
							);
							return this.addVectors(v, w);
						}

						this.x += v.x;
						this.y += v.y;
						this.z += v.z;
						this.w += v.w;

						return this;
					}

					addScalar(s) {
						this.x += s;
						this.y += s;
						this.z += s;
						this.w += s;

						return this;
					}

					addVectors(a, b) {
						this.x = a.x + b.x;
						this.y = a.y + b.y;
						this.z = a.z + b.z;
						this.w = a.w + b.w;

						return this;
					}

					addScaledVector(v, s) {
						this.x += v.x * s;
						this.y += v.y * s;
						this.z += v.z * s;
						this.w += v.w * s;

						return this;
					}

					sub(v, w) {
						if (w !== undefined) {
							console.warn(
								'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
							);
							return this.subVectors(v, w);
						}

						this.x -= v.x;
						this.y -= v.y;
						this.z -= v.z;
						this.w -= v.w;

						return this;
					}

					subScalar(s) {
						this.x -= s;
						this.y -= s;
						this.z -= s;
						this.w -= s;

						return this;
					}

					subVectors(a, b) {
						this.x = a.x - b.x;
						this.y = a.y - b.y;
						this.z = a.z - b.z;
						this.w = a.w - b.w;

						return this;
					}

					multiply(v) {
						this.x *= v.x;
						this.y *= v.y;
						this.z *= v.z;
						this.w *= v.w;

						return this;
					}

					multiplyScalar(scalar) {
						this.x *= scalar;
						this.y *= scalar;
						this.z *= scalar;
						this.w *= scalar;

						return this;
					}

					applyMatrix4(m) {
						const x = this.x,
							y = this.y,
							z = this.z,
							w = this.w;
						const e = m.elements;

						this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
						this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
						this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
						this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

						return this;
					}

					divideScalar(scalar) {
						return this.multiplyScalar(1 / scalar);
					}

					setAxisAngleFromQuaternion(q) {
						// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

						// q is assumed to be normalized

						this.w = 2 * Math.acos(q.w);

						const s = Math.sqrt(1 - q.w * q.w);

						if (s < 0.0001) {
							this.x = 1;
							this.y = 0;
							this.z = 0;
						} else {
							this.x = q.x / s;
							this.y = q.y / s;
							this.z = q.z / s;
						}

						return this;
					}

					setAxisAngleFromRotationMatrix(m) {
						// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

						// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

						let angle, x, y, z; // variables for result
						const epsilon = 0.01, // margin to allow for rounding errors
							epsilon2 = 0.1, // margin to distinguish between 0 and 180 degrees
							te = m.elements,
							m11 = te[0],
							m12 = te[4],
							m13 = te[8],
							m21 = te[1],
							m22 = te[5],
							m23 = te[9],
							m31 = te[2],
							m32 = te[6],
							m33 = te[10];

						if (
							Math.abs(m12 - m21) < epsilon &&
							Math.abs(m13 - m31) < epsilon &&
							Math.abs(m23 - m32) < epsilon
						) {
							// singularity found
							// first check for identity matrix which must have +1 for all terms
							// in leading diagonal and zero in other terms

							if (
								Math.abs(m12 + m21) < epsilon2 &&
								Math.abs(m13 + m31) < epsilon2 &&
								Math.abs(m23 + m32) < epsilon2 &&
								Math.abs(m11 + m22 + m33 - 3) < epsilon2
							) {
								// this singularity is identity matrix so angle = 0

								this.set(1, 0, 0, 0);

								return this; // zero angle, arbitrary axis
							}

							// otherwise this singularity is angle = 180

							angle = Math.PI;

							const xx = (m11 + 1) / 2;
							const yy = (m22 + 1) / 2;
							const zz = (m33 + 1) / 2;
							const xy = (m12 + m21) / 4;
							const xz = (m13 + m31) / 4;
							const yz = (m23 + m32) / 4;

							if (xx > yy && xx > zz) {
								// m11 is the largest diagonal term

								if (xx < epsilon) {
									x = 0;
									y = 0.707106781;
									z = 0.707106781;
								} else {
									x = Math.sqrt(xx);
									y = xy / x;
									z = xz / x;
								}
							} else if (yy > zz) {
								// m22 is the largest diagonal term

								if (yy < epsilon) {
									x = 0.707106781;
									y = 0;
									z = 0.707106781;
								} else {
									y = Math.sqrt(yy);
									x = xy / y;
									z = yz / y;
								}
							} else {
								// m33 is the largest diagonal term so base result on this

								if (zz < epsilon) {
									x = 0.707106781;
									y = 0.707106781;
									z = 0;
								} else {
									z = Math.sqrt(zz);
									x = xz / z;
									y = yz / z;
								}
							}

							this.set(x, y, z, angle);

							return this; // return 180 deg rotation
						}

						// as we have reached here there are no singularities so we can handle normally

						let s = Math.sqrt(
							(m32 - m23) * (m32 - m23) +
							(m13 - m31) * (m13 - m31) +
							(m21 - m12) * (m21 - m12)
						); // used to normalize

						if (Math.abs(s) < 0.001) s = 1;

						// prevent divide by zero, should not happen if matrix is orthogonal and should be
						// caught by singularity test above, but I've left it in just in case

						this.x = (m32 - m23) / s;
						this.y = (m13 - m31) / s;
						this.z = (m21 - m12) / s;
						this.w = Math.acos((m11 + m22 + m33 - 1) / 2);

						return this;
					}

					min(v) {
						this.x = Math.min(this.x, v.x);
						this.y = Math.min(this.y, v.y);
						this.z = Math.min(this.z, v.z);
						this.w = Math.min(this.w, v.w);

						return this;
					}

					max(v) {
						this.x = Math.max(this.x, v.x);
						this.y = Math.max(this.y, v.y);
						this.z = Math.max(this.z, v.z);
						this.w = Math.max(this.w, v.w);

						return this;
					}

					clamp(min, max) {
						// assumes min < max, componentwise

						this.x = Math.max(min.x, Math.min(max.x, this.x));
						this.y = Math.max(min.y, Math.min(max.y, this.y));
						this.z = Math.max(min.z, Math.min(max.z, this.z));
						this.w = Math.max(min.w, Math.min(max.w, this.w));

						return this;
					}

					clampScalar(minVal, maxVal) {
						this.x = Math.max(minVal, Math.min(maxVal, this.x));
						this.y = Math.max(minVal, Math.min(maxVal, this.y));
						this.z = Math.max(minVal, Math.min(maxVal, this.z));
						this.w = Math.max(minVal, Math.min(maxVal, this.w));

						return this;
					}

					clampLength(min, max) {
						const length = this.length();

						return this.divideScalar(length || 1).multiplyScalar(
							Math.max(min, Math.min(max, length))
						);
					}

					floor() {
						this.x = Math.floor(this.x);
						this.y = Math.floor(this.y);
						this.z = Math.floor(this.z);
						this.w = Math.floor(this.w);

						return this;
					}

					ceil() {
						this.x = Math.ceil(this.x);
						this.y = Math.ceil(this.y);
						this.z = Math.ceil(this.z);
						this.w = Math.ceil(this.w);

						return this;
					}

					round() {
						this.x = Math.round(this.x);
						this.y = Math.round(this.y);
						this.z = Math.round(this.z);
						this.w = Math.round(this.w);

						return this;
					}

					roundToZero() {
						this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
						this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
						this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
						this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);

						return this;
					}

					negate() {
						this.x = -this.x;
						this.y = -this.y;
						this.z = -this.z;
						this.w = -this.w;

						return this;
					}

					dot(v) {
						return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
					}

					lengthSq() {
						return (
							this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
						);
					}

					length() {
						return Math.sqrt(
							this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
						);
					}

					manhattanLength() {
						return (
							Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
						);
					}

					normalize() {
						return this.divideScalar(this.length() || 1);
					}

					setLength(length) {
						return this.normalize().multiplyScalar(length);
					}

					lerp(v, alpha) {
						this.x += (v.x - this.x) * alpha;
						this.y += (v.y - this.y) * alpha;
						this.z += (v.z - this.z) * alpha;
						this.w += (v.w - this.w) * alpha;

						return this;
					}

					lerpVectors(v1, v2, alpha) {
						this.x = v1.x + (v2.x - v1.x) * alpha;
						this.y = v1.y + (v2.y - v1.y) * alpha;
						this.z = v1.z + (v2.z - v1.z) * alpha;
						this.w = v1.w + (v2.w - v1.w) * alpha;

						return this;
					}

					equals(v) {
						return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
					}

					fromArray(array, offset = 0) {
						this.x = array[offset];
						this.y = array[offset + 1];
						this.z = array[offset + 2];
						this.w = array[offset + 3];

						return this;
					}

					toArray(array = [], offset = 0) {
						array[offset] = this.x;
						array[offset + 1] = this.y;
						array[offset + 2] = this.z;
						array[offset + 3] = this.w;

						return array;
					}

					fromBufferAttribute(attribute, index, offset) {
						if (offset !== undefined) {
							console.warn(
								'THREE.Vector4: offset has been removed from .fromBufferAttribute().'
							);
						}

						this.x = attribute.getX(index);
						this.y = attribute.getY(index);
						this.z = attribute.getZ(index);
						this.w = attribute.getW(index);

						return this;
					}

					random() {
						this.x = Math.random();
						this.y = Math.random();
						this.z = Math.random();
						this.w = Math.random();

						return this;
					}

					*[Symbol.iterator]() {
						yield this.x;
						yield this.y;
						yield this.z;
						yield this.w;
					}
				}

				Vector4.prototype.isVector4 = true;




				/***/
}),

/***/ "./libs/three/math/interpolants/CubicInterpolant.js":
/*!**********************************************************!*\
  !*** ./libs/three/math/interpolants/CubicInterpolant.js ***!
  \**********************************************************/
/*! exports provided: CubicInterpolant */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function () { return CubicInterpolant; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Interpolant.js */ "./libs/three/math/Interpolant.js");




				/**
				 * Fast and simple cubic spline interpolant.
				 *
				 * It was derived from a Hermitian construction setting the first derivative
				 * at each sample position to the linear slope between neighboring positions
				 * over their parameter interval.
				 */

				class CubicInterpolant extends _Interpolant_js__WEBPACK_IMPORTED_MODULE_1__["Interpolant"] {
					constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
						super(parameterPositions, sampleValues, sampleSize, resultBuffer);

						this._weightPrev = -0;
						this._offsetPrev = -0;
						this._weightNext = -0;
						this._offsetNext = -0;

						this.DefaultSettings_ = {
							endingStart: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"],
							endingEnd: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroCurvatureEnding"]
						};
					}

					intervalChanged_(i1, t0, t1) {
						const pp = this.parameterPositions;
						let iPrev = i1 - 2,
							iNext = i1 + 1,
							tPrev = pp[iPrev],
							tNext = pp[iNext];

						if (tPrev === undefined) {
							switch (this.getSettings_().endingStart) {
								case _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"]:
									// f'(t0) = 0
									iPrev = i1;
									tPrev = 2 * t0 - t1;

									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"]:
									// use the other end of the curve
									iPrev = pp.length - 2;
									tPrev = t0 + pp[iPrev] - pp[iPrev + 1];

									break;

								default:
									// ZeroCurvatureEnding

									// f''(t0) = 0 a.k.a. Natural Spline
									iPrev = i1;
									tPrev = t1;
							}
						}

						if (tNext === undefined) {
							switch (this.getSettings_().endingEnd) {
								case _constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroSlopeEnding"]:
									// f'(tN) = 0
									iNext = i1;
									tNext = 2 * t1 - t0;

									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_0__["WrapAroundEnding"]:
									// use the other end of the curve
									iNext = 1;
									tNext = t1 + pp[1] - pp[0];

									break;

								default:
									// ZeroCurvatureEnding

									// f''(tN) = 0, a.k.a. Natural Spline
									iNext = i1 - 1;
									tNext = t0;
							}
						}

						const halfDt = (t1 - t0) * 0.5,
							stride = this.valueSize;

						this._weightPrev = halfDt / (t0 - tPrev);
						this._weightNext = halfDt / (tNext - t1);
						this._offsetPrev = iPrev * stride;
						this._offsetNext = iNext * stride;
					}

					interpolate_(i1, t0, t, t1) {
						const result = this.resultBuffer,
							values = this.sampleValues,
							stride = this.valueSize,
							o1 = i1 * stride,
							o0 = o1 - stride,
							oP = this._offsetPrev,
							oN = this._offsetNext,
							wP = this._weightPrev,
							wN = this._weightNext,
							p = (t - t0) / (t1 - t0),
							pp = p * p,
							ppp = pp * p;

						// evaluate polynomials

						const sP = -wP * ppp + 2 * wP * pp - wP * p;
						const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
						const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
						const sN = wN * ppp - wN * pp;

						// combine data linearly

						for (let i = 0; i !== stride; ++i) {
							result[i] =
								sP * values[oP + i] +
								s0 * values[o0 + i] +
								s1 * values[o1 + i] +
								sN * values[oN + i];
						}

						return result;
					}
				}




				/***/
}),

/***/ "./libs/three/math/interpolants/DiscreteInterpolant.js":
/*!*************************************************************!*\
  !*** ./libs/three/math/interpolants/DiscreteInterpolant.js ***!
  \*************************************************************/
/*! exports provided: DiscreteInterpolant */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function () { return DiscreteInterpolant; });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "./libs/three/math/Interpolant.js");


				/**
				 *
				 * Interpolant that evaluates to the sample value at the position preceeding
				 * the parameter.
				 */

				class DiscreteInterpolant extends _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"] {
					constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
						super(parameterPositions, sampleValues, sampleSize, resultBuffer);
					}

					interpolate_(i1 /*, t0, t, t1 */) {
						return this.copySampleValue_(i1 - 1);
					}
				}




				/***/
}),

/***/ "./libs/three/math/interpolants/LinearInterpolant.js":
/*!***********************************************************!*\
  !*** ./libs/three/math/interpolants/LinearInterpolant.js ***!
  \***********************************************************/
/*! exports provided: LinearInterpolant */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function () { return LinearInterpolant; });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "./libs/three/math/Interpolant.js");


				class LinearInterpolant extends _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"] {
					constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
						super(parameterPositions, sampleValues, sampleSize, resultBuffer);
					}

					interpolate_(i1, t0, t, t1) {
						const result = this.resultBuffer,
							values = this.sampleValues,
							stride = this.valueSize,
							offset1 = i1 * stride,
							offset0 = offset1 - stride,
							weight1 = (t - t0) / (t1 - t0),
							weight0 = 1 - weight1;

						for (let i = 0; i !== stride; ++i) {
							result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
						}

						return result;
					}
				}




				/***/
}),

/***/ "./libs/three/math/interpolants/QuaternionLinearInterpolant.js":
/*!*********************************************************************!*\
  !*** ./libs/three/math/interpolants/QuaternionLinearInterpolant.js ***!
  \*********************************************************************/
/*! exports provided: QuaternionLinearInterpolant */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function () { return QuaternionLinearInterpolant; });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "./libs/three/math/Interpolant.js");
/* harmony import */ var _Quaternion_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Quaternion.js */ "./libs/three/math/Quaternion.js");



				/**
				 * Spherical linear unit quaternion interpolant.
				 */

				class QuaternionLinearInterpolant extends _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__["Interpolant"] {
					constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
						super(parameterPositions, sampleValues, sampleSize, resultBuffer);
					}

					interpolate_(i1, t0, t, t1) {
						const result = this.resultBuffer,
							values = this.sampleValues,
							stride = this.valueSize,
							alpha = (t - t0) / (t1 - t0);

						let offset = i1 * stride;

						for (let end = offset + stride; offset !== end; offset += 4) {
							_Quaternion_js__WEBPACK_IMPORTED_MODULE_1__["Quaternion"].slerpFlat(
								result,
								0,
								values,
								offset - stride,
								values,
								offset,
								alpha
							);
						}

						return result;
					}
				}




				/***/
}),

/***/ "./libs/three/objects/Bone.js":
/*!************************************!*\
  !*** ./libs/three/objects/Bone.js ***!
  \************************************/
/*! exports provided: Bone */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function () { return Bone; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");


				class Bone extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {
					constructor() {
						super();

						this.type = 'Bone';
					}
				}

				Bone.prototype.isBone = true;




				/***/
}),

/***/ "./libs/three/objects/Group.js":
/*!*************************************!*\
  !*** ./libs/three/objects/Group.js ***!
  \*************************************/
/*! exports provided: Group */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function () { return Group; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");


				class Group extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {
					constructor() {
						super();

						this.type = 'Group';
					}
				}

				Group.prototype.isGroup = true;




				/***/
}),

/***/ "./libs/three/objects/Line.js":
/*!************************************!*\
  !*** ./libs/three/objects/Line.js ***!
  \************************************/
/*! exports provided: Line */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function () { return Line; });
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Sphere.js */ "./libs/three/math/Sphere.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Ray.js */ "./libs/three/math/Ray.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../materials/LineBasicMaterial.js */ "./libs/three/materials/LineBasicMaterial.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "./libs/three/core/BufferGeometry.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");









				const _start = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
				const _end = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
				const _inverseMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
				const _ray = /*@__PURE__*/ new _math_Ray_js__WEBPACK_IMPORTED_MODULE_1__["Ray"]();
				const _sphere = /*@__PURE__*/ new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__["Sphere"]();

				class Line extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"] {
					constructor(
						geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__["BufferGeometry"](),
						material = new _materials_LineBasicMaterial_js__WEBPACK_IMPORTED_MODULE_5__["LineBasicMaterial"]()
					) {
						super();

						this.type = 'Line';

						this.geometry = geometry;
						this.material = material;

						this.updateMorphTargets();
					}

					copy(source) {
						super.copy(source);

						this.material = source.material;
						this.geometry = source.geometry;

						return this;
					}

					computeLineDistances() {
						const geometry = this.geometry;

						if (geometry.isBufferGeometry) {
							// we assume non-indexed geometry

							if (geometry.index === null) {
								const positionAttribute = geometry.attributes.position;
								const lineDistances = [0];

								for (let i = 1, l = positionAttribute.count; i < l; i++) {
									_start.fromBufferAttribute(positionAttribute, i - 1);
									_end.fromBufferAttribute(positionAttribute, i);

									lineDistances[i] = lineDistances[i - 1];
									lineDistances[i] += _start.distanceTo(_end);
								}

								geometry.setAttribute(
									'lineDistance',
									new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_7__["Float32BufferAttribute"](lineDistances, 1)
								);
							} else {
								console.warn(
									'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
								);
							}
						} else if (geometry.isGeometry) {
							console.error(
								'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
							);
						}

						return this;
					}

					raycast(raycaster, intersects) {
						const geometry = this.geometry;
						const matrixWorld = this.matrixWorld;
						const threshold = raycaster.params.Line.threshold;
						const drawRange = geometry.drawRange;

						// Checking boundingSphere distance to ray

						if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

						_sphere.copy(geometry.boundingSphere);
						_sphere.applyMatrix4(matrixWorld);
						_sphere.radius += threshold;

						if (raycaster.ray.intersectsSphere(_sphere) === false) return;

						//

						_inverseMatrix.copy(matrixWorld).invert();
						_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

						const localThreshold =
							threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
						const localThresholdSq = localThreshold * localThreshold;

						const vStart = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						const vEnd = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						const interSegment = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						const interRay = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();
						const step = this.isLineSegments ? 2 : 1;

						if (geometry.isBufferGeometry) {
							const index = geometry.index;
							const attributes = geometry.attributes;
							const positionAttribute = attributes.position;

							if (index !== null) {
								const start = Math.max(0, drawRange.start);
								const end = Math.min(index.count, drawRange.start + drawRange.count);

								for (let i = start, l = end - 1; i < l; i += step) {
									const a = index.getX(i);
									const b = index.getX(i + 1);

									vStart.fromBufferAttribute(positionAttribute, a);
									vEnd.fromBufferAttribute(positionAttribute, b);

									const distSq = _ray.distanceSqToSegment(
										vStart,
										vEnd,
										interRay,
										interSegment
									);

									if (distSq > localThresholdSq) continue;

									interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

									const distance = raycaster.ray.origin.distanceTo(interRay);

									if (distance < raycaster.near || distance > raycaster.far) continue;

									intersects.push({
										distance: distance,
										// What do we want? intersection point on the ray or on the segment??
										// point: raycaster.ray.at( distance ),
										point: interSegment.clone().applyMatrix4(this.matrixWorld),
										index: i,
										face: null,
										faceIndex: null,
										object: this
									});
								}
							} else {
								const start = Math.max(0, drawRange.start);
								const end = Math.min(
									positionAttribute.count,
									drawRange.start + drawRange.count
								);

								for (let i = start, l = end - 1; i < l; i += step) {
									vStart.fromBufferAttribute(positionAttribute, i);
									vEnd.fromBufferAttribute(positionAttribute, i + 1);

									const distSq = _ray.distanceSqToSegment(
										vStart,
										vEnd,
										interRay,
										interSegment
									);

									if (distSq > localThresholdSq) continue;

									interRay.applyMatrix4(this.matrixWorld); //Move back to world space for distance calculation

									const distance = raycaster.ray.origin.distanceTo(interRay);

									if (distance < raycaster.near || distance > raycaster.far) continue;

									intersects.push({
										distance: distance,
										// What do we want? intersection point on the ray or on the segment??
										// point: raycaster.ray.at( distance ),
										point: interSegment.clone().applyMatrix4(this.matrixWorld),
										index: i,
										face: null,
										faceIndex: null,
										object: this
									});
								}
							}
						} else if (geometry.isGeometry) {
							console.error(
								'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
							);
						}
					}

					updateMorphTargets() {
						const geometry = this.geometry;

						if (geometry.isBufferGeometry) {
							const morphAttributes = geometry.morphAttributes;
							const keys = Object.keys(morphAttributes);

							if (keys.length > 0) {
								const morphAttribute = morphAttributes[keys[0]];

								if (morphAttribute !== undefined) {
									this.morphTargetInfluences = [];
									this.morphTargetDictionary = {};

									for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
										const name = morphAttribute[m].name || String(m);

										this.morphTargetInfluences.push(0);
										this.morphTargetDictionary[name] = m;
									}
								}
							}
						} else {
							const morphTargets = geometry.morphTargets;

							if (morphTargets !== undefined && morphTargets.length > 0) {
								console.error(
									'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
								);
							}
						}
					}
				}

				Line.prototype.isLine = true;




				/***/
}),

/***/ "./libs/three/objects/LineLoop.js":
/*!****************************************!*\
  !*** ./libs/three/objects/LineLoop.js ***!
  \****************************************/
/*! exports provided: LineLoop */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function () { return LineLoop; });
/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line.js */ "./libs/three/objects/Line.js");


				class LineLoop extends _Line_js__WEBPACK_IMPORTED_MODULE_0__["Line"] {
					constructor(geometry, material) {
						super(geometry, material);

						this.type = 'LineLoop';
					}
				}

				LineLoop.prototype.isLineLoop = true;




				/***/
}),

/***/ "./libs/three/objects/LineSegments.js":
/*!********************************************!*\
  !*** ./libs/three/objects/LineSegments.js ***!
  \********************************************/
/*! exports provided: LineSegments */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function () { return LineSegments; });
/* harmony import */ var _Line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Line.js */ "./libs/three/objects/Line.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");




				const _start = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();
				const _end = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_1__["Vector3"]();

				class LineSegments extends _Line_js__WEBPACK_IMPORTED_MODULE_0__["Line"] {
					constructor(geometry, material) {
						super(geometry, material);

						this.type = 'LineSegments';
					}

					computeLineDistances() {
						const geometry = this.geometry;

						if (geometry.isBufferGeometry) {
							// we assume non-indexed geometry

							if (geometry.index === null) {
								const positionAttribute = geometry.attributes.position;
								const lineDistances = [];

								for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
									_start.fromBufferAttribute(positionAttribute, i);
									_end.fromBufferAttribute(positionAttribute, i + 1);

									lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
									lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
								}

								geometry.setAttribute(
									'lineDistance',
									new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_2__["Float32BufferAttribute"](lineDistances, 1)
								);
							} else {
								console.warn(
									'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
								);
							}
						} else if (geometry.isGeometry) {
							console.error(
								'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
							);
						}

						return this;
					}
				}

				LineSegments.prototype.isLineSegments = true;




				/***/
}),

/***/ "./libs/three/objects/Mesh.js":
/*!************************************!*\
  !*** ./libs/three/objects/Mesh.js ***!
  \************************************/
/*! exports provided: Mesh */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function () { return Mesh; });
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Sphere.js */ "./libs/three/math/Sphere.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Ray.js */ "./libs/three/math/Ray.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");
/* harmony import */ var _math_Triangle_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../math/Triangle.js */ "./libs/three/math/Triangle.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../materials/MeshBasicMaterial.js */ "./libs/three/materials/MeshBasicMaterial.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "./libs/three/core/BufferGeometry.js");











				const _inverseMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_4__["Matrix4"]();
				const _ray = /*@__PURE__*/ new _math_Ray_js__WEBPACK_IMPORTED_MODULE_3__["Ray"]();
				const _sphere = /*@__PURE__*/ new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_2__["Sphere"]();

				const _vA = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _vB = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _vC = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				const _tempA = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _tempB = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _tempC = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				const _morphA = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _morphB = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _morphC = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				const _uvA = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();
				const _uvB = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();
				const _uvC = /*@__PURE__*/ new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]();

				const _intersectionPoint = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
				const _intersectionPointWorld = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();

				class Mesh extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_5__["Object3D"] {
					constructor(
						geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_9__["BufferGeometry"](),
						material // = new MeshBasicMaterial()
					) {
						super();

						this.type = 'Mesh';

						this.geometry = geometry;
						this.material = material || new _materials_MeshBasicMaterial_js__WEBPACK_IMPORTED_MODULE_8__["MeshBasicMaterial"]();

						this.updateMorphTargets();
					}

					copy(source) {
						super.copy(source);

						if (source.morphTargetInfluences !== undefined) {
							this.morphTargetInfluences = source.morphTargetInfluences.slice();
						}

						if (source.morphTargetDictionary !== undefined) {
							this.morphTargetDictionary = Object.assign(
								{},
								source.morphTargetDictionary
							);
						}

						this.material = source.material;
						this.geometry = source.geometry;

						return this;
					}

					updateMorphTargets() {
						const geometry = this.geometry;

						if (geometry.isBufferGeometry) {
							const morphAttributes = geometry.morphAttributes;
							const keys = Object.keys(morphAttributes);

							if (keys.length > 0) {
								const morphAttribute = morphAttributes[keys[0]];

								if (morphAttribute !== undefined) {
									this.morphTargetInfluences = [];
									this.morphTargetDictionary = {};

									for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
										const name = morphAttribute[m].name || String(m);

										this.morphTargetInfluences.push(0);
										this.morphTargetDictionary[name] = m;
									}
								}
							}
						} else {
							const morphTargets = geometry.morphTargets;

							if (morphTargets !== undefined && morphTargets.length > 0) {
								console.error(
									'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
								);
							}
						}
					}

					raycast(raycaster, intersects) {
						const geometry = this.geometry;
						const material = this.material;
						const matrixWorld = this.matrixWorld;

						if (material === undefined) return;

						// Checking boundingSphere distance to ray

						if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

						_sphere.copy(geometry.boundingSphere);
						_sphere.applyMatrix4(matrixWorld);

						if (raycaster.ray.intersectsSphere(_sphere) === false) return;

						//

						_inverseMatrix.copy(matrixWorld).invert();
						_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

						// Check boundingBox before continuing

						if (geometry.boundingBox !== null) {
							if (_ray.intersectsBox(geometry.boundingBox) === false) return;
						}

						let intersection;

						if (geometry.isBufferGeometry) {
							const index = geometry.index;
							const position = geometry.attributes.position;
							const morphPosition = geometry.morphAttributes.position;
							const morphTargetsRelative = geometry.morphTargetsRelative;
							const uv = geometry.attributes.uv;
							const uv2 = geometry.attributes.uv2;
							const groups = geometry.groups;
							const drawRange = geometry.drawRange;

							if (index !== null) {
								// indexed buffer geometry

								if (Array.isArray(material)) {
									for (let i = 0, il = groups.length; i < il; i++) {
										const group = groups[i];
										const groupMaterial = material[group.materialIndex];

										const start = Math.max(group.start, drawRange.start);
										const end = Math.min(
											index.count,
											Math.min(
												group.start + group.count,
												drawRange.start + drawRange.count
											)
										);

										for (let j = start, jl = end; j < jl; j += 3) {
											const a = index.getX(j);
											const b = index.getX(j + 1);
											const c = index.getX(j + 2);

											intersection = checkBufferGeometryIntersection(
												this,
												groupMaterial,
												raycaster,
												_ray,
												position,
												morphPosition,
												morphTargetsRelative,
												uv,
												uv2,
												a,
												b,
												c
											);

											if (intersection) {
												intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
												intersection.face.materialIndex = group.materialIndex;
												intersects.push(intersection);
											}
										}
									}
								} else {
									const start = Math.max(0, drawRange.start);
									const end = Math.min(index.count, drawRange.start + drawRange.count);

									for (let i = start, il = end; i < il; i += 3) {
										const a = index.getX(i);
										const b = index.getX(i + 1);
										const c = index.getX(i + 2);

										intersection = checkBufferGeometryIntersection(
											this,
											material,
											raycaster,
											_ray,
											position,
											morphPosition,
											morphTargetsRelative,
											uv,
											uv2,
											a,
											b,
											c
										);

										if (intersection) {
											intersection.faceIndex = Math.floor(i / 3); // triangle number in indexed buffer semantics
											intersects.push(intersection);
										}
									}
								}
							} else if (position !== undefined) {
								// non-indexed buffer geometry

								if (Array.isArray(material)) {
									for (let i = 0, il = groups.length; i < il; i++) {
										const group = groups[i];
										const groupMaterial = material[group.materialIndex];

										const start = Math.max(group.start, drawRange.start);
										const end = Math.min(
											position.count,
											Math.min(
												group.start + group.count,
												drawRange.start + drawRange.count
											)
										);

										for (let j = start, jl = end; j < jl; j += 3) {
											const a = j;
											const b = j + 1;
											const c = j + 2;

											intersection = checkBufferGeometryIntersection(
												this,
												groupMaterial,
												raycaster,
												_ray,
												position,
												morphPosition,
												morphTargetsRelative,
												uv,
												uv2,
												a,
												b,
												c
											);

											if (intersection) {
												intersection.faceIndex = Math.floor(j / 3); // triangle number in non-indexed buffer semantics
												intersection.face.materialIndex = group.materialIndex;
												intersects.push(intersection);
											}
										}
									}
								} else {
									const start = Math.max(0, drawRange.start);
									const end = Math.min(
										position.count,
										drawRange.start + drawRange.count
									);

									for (let i = start, il = end; i < il; i += 3) {
										const a = i;
										const b = i + 1;
										const c = i + 2;

										intersection = checkBufferGeometryIntersection(
											this,
											material,
											raycaster,
											_ray,
											position,
											morphPosition,
											morphTargetsRelative,
											uv,
											uv2,
											a,
											b,
											c
										);

										if (intersection) {
											intersection.faceIndex = Math.floor(i / 3); // triangle number in non-indexed buffer semantics
											intersects.push(intersection);
										}
									}
								}
							}
						} else if (geometry.isGeometry) {
							console.error(
								'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
							);
						}
					}
				}

				Mesh.prototype.isMesh = true;

				function checkIntersection(
					object,
					material,
					raycaster,
					ray,
					pA,
					pB,
					pC,
					point
				) {
					let intersect;

					if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_7__["BackSide"]) {
						intersect = ray.intersectTriangle(pC, pB, pA, true, point);
					} else {
						intersect = ray.intersectTriangle(
							pA,
							pB,
							pC,
							material.side !== _constants_js__WEBPACK_IMPORTED_MODULE_7__["DoubleSide"],
							point
						);
					}

					if (intersect === null) return null;

					_intersectionPointWorld.copy(point);
					_intersectionPointWorld.applyMatrix4(object.matrixWorld);

					const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);

					if (distance < raycaster.near || distance > raycaster.far) return null;

					return {
						distance: distance,
						point: _intersectionPointWorld.clone(),
						object: object
					};
				}

				function checkBufferGeometryIntersection(
					object,
					material,
					raycaster,
					ray,
					position,
					morphPosition,
					morphTargetsRelative,
					uv,
					uv2,
					a,
					b,
					c
				) {
					_vA.fromBufferAttribute(position, a);
					_vB.fromBufferAttribute(position, b);
					_vC.fromBufferAttribute(position, c);

					const morphInfluences = object.morphTargetInfluences;

					if (morphPosition && morphInfluences) {
						_morphA.set(0, 0, 0);
						_morphB.set(0, 0, 0);
						_morphC.set(0, 0, 0);

						for (let i = 0, il = morphPosition.length; i < il; i++) {
							const influence = morphInfluences[i];
							const morphAttribute = morphPosition[i];

							if (influence === 0) continue;

							_tempA.fromBufferAttribute(morphAttribute, a);
							_tempB.fromBufferAttribute(morphAttribute, b);
							_tempC.fromBufferAttribute(morphAttribute, c);

							if (morphTargetsRelative) {
								_morphA.addScaledVector(_tempA, influence);
								_morphB.addScaledVector(_tempB, influence);
								_morphC.addScaledVector(_tempC, influence);
							} else {
								_morphA.addScaledVector(_tempA.sub(_vA), influence);
								_morphB.addScaledVector(_tempB.sub(_vB), influence);
								_morphC.addScaledVector(_tempC.sub(_vC), influence);
							}
						}

						_vA.add(_morphA);
						_vB.add(_morphB);
						_vC.add(_morphC);
					}

					if (object.isSkinnedMesh) {
						object.boneTransform(a, _vA);
						object.boneTransform(b, _vB);
						object.boneTransform(c, _vC);
					}

					const intersection = checkIntersection(
						object,
						material,
						raycaster,
						ray,
						_vA,
						_vB,
						_vC,
						_intersectionPoint
					);

					if (intersection) {
						if (uv) {
							_uvA.fromBufferAttribute(uv, a);
							_uvB.fromBufferAttribute(uv, b);
							_uvC.fromBufferAttribute(uv, c);

							intersection.uv = _math_Triangle_js__WEBPACK_IMPORTED_MODULE_6__["Triangle"].getUV(
								_intersectionPoint,
								_vA,
								_vB,
								_vC,
								_uvA,
								_uvB,
								_uvC,
								new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]()
							);
						}

						if (uv2) {
							_uvA.fromBufferAttribute(uv2, a);
							_uvB.fromBufferAttribute(uv2, b);
							_uvC.fromBufferAttribute(uv2, c);

							intersection.uv2 = _math_Triangle_js__WEBPACK_IMPORTED_MODULE_6__["Triangle"].getUV(
								_intersectionPoint,
								_vA,
								_vB,
								_vC,
								_uvA,
								_uvB,
								_uvC,
								new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"]()
							);
						}

						const face = {
							a: a,
							b: b,
							c: c,
							normal: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_0__["Vector3"](),
							materialIndex: 0
						};

						_math_Triangle_js__WEBPACK_IMPORTED_MODULE_6__["Triangle"].getNormal(_vA, _vB, _vC, face.normal);

						intersection.face = face;
					}

					return intersection;
				}




				/***/
}),

/***/ "./libs/three/objects/Points.js":
/*!**************************************!*\
  !*** ./libs/three/objects/Points.js ***!
  \**************************************/
/*! exports provided: Points */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function () { return Points; });
/* harmony import */ var _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Sphere.js */ "./libs/three/math/Sphere.js");
/* harmony import */ var _math_Ray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Ray.js */ "./libs/three/math/Ray.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _materials_PointsMaterial_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../materials/PointsMaterial.js */ "./libs/three/materials/PointsMaterial.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../core/BufferGeometry.js */ "./libs/three/core/BufferGeometry.js");








				const _inverseMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
				const _ray = /*@__PURE__*/ new _math_Ray_js__WEBPACK_IMPORTED_MODULE_1__["Ray"]();
				const _sphere = /*@__PURE__*/ new _math_Sphere_js__WEBPACK_IMPORTED_MODULE_0__["Sphere"]();
				const _position = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();

				class Points extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_3__["Object3D"] {
					constructor(
						geometry = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__["BufferGeometry"](),
						material = new _materials_PointsMaterial_js__WEBPACK_IMPORTED_MODULE_5__["PointsMaterial"]()
					) {
						super();

						this.type = 'Points';

						this.geometry = geometry;
						this.material = material;

						this.updateMorphTargets();
					}

					copy(source) {
						super.copy(source);

						this.material = source.material;
						this.geometry = source.geometry;

						return this;
					}

					raycast(raycaster, intersects) {
						const geometry = this.geometry;
						const matrixWorld = this.matrixWorld;
						const threshold = raycaster.params.Points.threshold;
						const drawRange = geometry.drawRange;

						// Checking boundingSphere distance to ray

						if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

						_sphere.copy(geometry.boundingSphere);
						_sphere.applyMatrix4(matrixWorld);
						_sphere.radius += threshold;

						if (raycaster.ray.intersectsSphere(_sphere) === false) return;

						//

						_inverseMatrix.copy(matrixWorld).invert();
						_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);

						const localThreshold =
							threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
						const localThresholdSq = localThreshold * localThreshold;

						if (geometry.isBufferGeometry) {
							const index = geometry.index;
							const attributes = geometry.attributes;
							const positionAttribute = attributes.position;

							if (index !== null) {
								const start = Math.max(0, drawRange.start);
								const end = Math.min(index.count, drawRange.start + drawRange.count);

								for (let i = start, il = end; i < il; i++) {
									const a = index.getX(i);

									_position.fromBufferAttribute(positionAttribute, a);

									testPoint(
										_position,
										a,
										localThresholdSq,
										matrixWorld,
										raycaster,
										intersects,
										this
									);
								}
							} else {
								const start = Math.max(0, drawRange.start);
								const end = Math.min(
									positionAttribute.count,
									drawRange.start + drawRange.count
								);

								for (let i = start, l = end; i < l; i++) {
									_position.fromBufferAttribute(positionAttribute, i);

									testPoint(
										_position,
										i,
										localThresholdSq,
										matrixWorld,
										raycaster,
										intersects,
										this
									);
								}
							}
						} else {
							console.error(
								'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.'
							);
						}
					}

					updateMorphTargets() {
						const geometry = this.geometry;

						if (geometry.isBufferGeometry) {
							const morphAttributes = geometry.morphAttributes;
							const keys = Object.keys(morphAttributes);

							if (keys.length > 0) {
								const morphAttribute = morphAttributes[keys[0]];

								if (morphAttribute !== undefined) {
									this.morphTargetInfluences = [];
									this.morphTargetDictionary = {};

									for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
										const name = morphAttribute[m].name || String(m);

										this.morphTargetInfluences.push(0);
										this.morphTargetDictionary[name] = m;
									}
								}
							}
						} else {
							const morphTargets = geometry.morphTargets;

							if (morphTargets !== undefined && morphTargets.length > 0) {
								console.error(
									'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.'
								);
							}
						}
					}
				}

				Points.prototype.isPoints = true;

				function testPoint(
					point,
					index,
					localThresholdSq,
					matrixWorld,
					raycaster,
					intersects,
					object
				) {
					const rayPointDistanceSq = _ray.distanceSqToPoint(point);

					if (rayPointDistanceSq < localThresholdSq) {
						const intersectPoint = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_4__["Vector3"]();

						_ray.closestPointToPoint(point, intersectPoint);
						intersectPoint.applyMatrix4(matrixWorld);

						const distance = raycaster.ray.origin.distanceTo(intersectPoint);

						if (distance < raycaster.near || distance > raycaster.far) return;

						intersects.push({
							distance: distance,
							distanceToRay: Math.sqrt(rayPointDistanceSq),
							point: intersectPoint,
							index: index,
							face: null,
							object: object
						});
					}
				}




				/***/
}),

/***/ "./libs/three/objects/Skeleton.js":
/*!****************************************!*\
  !*** ./libs/three/objects/Skeleton.js ***!
  \****************************************/
/*! exports provided: Skeleton */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function () { return Skeleton; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _Bone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bone.js */ "./libs/three/objects/Bone.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../textures/DataTexture.js */ "./libs/three/textures/DataTexture.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");






				const _offsetMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();
				const _identityMatrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

				class Skeleton {
					constructor(bones = [], boneInverses = []) {
						this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_4__["generateUUID"]();

						this.bones = bones.slice(0);
						this.boneInverses = boneInverses;
						this.boneMatrices = null;

						this.boneTexture = null;
						this.boneTextureSize = 0;

						this.frame = -1;

						this.init();
					}

					init() {
						const bones = this.bones;
						const boneInverses = this.boneInverses;

						this.boneMatrices = new Float32Array(bones.length * 16);

						// calculate inverse bone matrices if necessary

						if (boneInverses.length === 0) {
							this.calculateInverses();
						} else {
							// handle special case

							if (bones.length !== boneInverses.length) {
								console.warn(
									'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.'
								);

								this.boneInverses = [];

								for (let i = 0, il = this.bones.length; i < il; i++) {
									this.boneInverses.push(new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]());
								}
							}
						}
					}

					calculateInverses() {
						this.boneInverses.length = 0;

						for (let i = 0, il = this.bones.length; i < il; i++) {
							const inverse = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

							if (this.bones[i]) {
								inverse.copy(this.bones[i].matrixWorld).invert();
							}

							this.boneInverses.push(inverse);
						}
					}

					pose() {
						// recover the bind-time world matrices

						for (let i = 0, il = this.bones.length; i < il; i++) {
							const bone = this.bones[i];

							if (bone) {
								bone.matrixWorld.copy(this.boneInverses[i]).invert();
							}
						}

						// compute the local matrices, positions, rotations and scales

						for (let i = 0, il = this.bones.length; i < il; i++) {
							const bone = this.bones[i];

							if (bone) {
								if (bone.parent && bone.parent.isBone) {
									bone.matrix.copy(bone.parent.matrixWorld).invert();
									bone.matrix.multiply(bone.matrixWorld);
								} else {
									bone.matrix.copy(bone.matrixWorld);
								}

								bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
							}
						}
					}

					update() {
						const bones = this.bones;
						const boneInverses = this.boneInverses;
						const boneMatrices = this.boneMatrices;
						const boneTexture = this.boneTexture;

						// flatten bone matrices to array

						for (let i = 0, il = bones.length; i < il; i++) {
							// compute the offset between the current and the original transform

							const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;

							_offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
							_offsetMatrix.toArray(boneMatrices, i * 16);
						}

						if (boneTexture !== null) {
							boneTexture.needsUpdate = true;
						}
					}

					clone() {
						return new Skeleton(this.bones, this.boneInverses);
					}

					computeBoneTexture() {
						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

						let size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
						size = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_4__["ceilPowerOfTwo"](size);
						size = Math.max(size, 4);

						const boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
						boneMatrices.set(this.boneMatrices); // copy current values

						const boneTexture = new _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_3__["DataTexture"](
							boneMatrices,
							size,
							size,
							_constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"],
							_constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"]
						);

						this.boneMatrices = boneMatrices;
						this.boneTexture = boneTexture;
						this.boneTextureSize = size;

						return this;
					}

					getBoneByName(name) {
						for (let i = 0, il = this.bones.length; i < il; i++) {
							const bone = this.bones[i];

							if (bone.name === name) {
								return bone;
							}
						}

						return undefined;
					}

					dispose() {
						if (this.boneTexture !== null) {
							this.boneTexture.dispose();

							this.boneTexture = null;
						}
					}

					fromJSON(json, bones) {
						this.uuid = json.uuid;

						for (let i = 0, l = json.bones.length; i < l; i++) {
							const uuid = json.bones[i];
							let bone = bones[uuid];

							if (bone === undefined) {
								console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
								bone = new _Bone_js__WEBPACK_IMPORTED_MODULE_1__["Bone"]();
							}

							this.bones.push(bone);
							this.boneInverses.push(new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]().fromArray(json.boneInverses[i]));
						}

						this.init();

						return this;
					}

					toJSON() {
						const data = {
							metadata: {
								version: 4.5,
								type: 'Skeleton',
								generator: 'Skeleton.toJSON'
							},
							bones: [],
							boneInverses: []
						};

						data.uuid = this.uuid;

						const bones = this.bones;
						const boneInverses = this.boneInverses;

						for (let i = 0, l = bones.length; i < l; i++) {
							const bone = bones[i];
							data.bones.push(bone.uuid);

							const boneInverse = boneInverses[i];
							data.boneInverses.push(boneInverse.toArray());
						}

						return data;
					}
				}




				/***/
}),

/***/ "./libs/three/objects/SkinnedMesh.js":
/*!*******************************************!*\
  !*** ./libs/three/objects/SkinnedMesh.js ***!
  \*******************************************/
/*! exports provided: SkinnedMesh */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function () { return SkinnedMesh; });
/* harmony import */ var _Mesh_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mesh.js */ "./libs/three/objects/Mesh.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector4.js */ "./libs/three/math/Vector4.js");





				const _basePosition = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

				const _skinIndex = /*@__PURE__*/ new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();
				const _skinWeight = /*@__PURE__*/ new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();

				const _vector = /*@__PURE__*/ new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();
				const _matrix = /*@__PURE__*/ new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();

				class SkinnedMesh extends _Mesh_js__WEBPACK_IMPORTED_MODULE_0__["Mesh"] {
					constructor(geometry, material) {
						super(geometry, material);

						this.type = 'SkinnedMesh';

						this.bindMode = 'attached';
						this.bindMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
						this.bindMatrixInverse = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
					}

					copy(source) {
						super.copy(source);

						this.bindMode = source.bindMode;
						this.bindMatrix.copy(source.bindMatrix);
						this.bindMatrixInverse.copy(source.bindMatrixInverse);

						this.skeleton = source.skeleton;

						return this;
					}

					bind(skeleton, bindMatrix) {
						this.skeleton = skeleton;

						if (bindMatrix === undefined) {
							this.updateMatrixWorld(true);

							this.skeleton.calculateInverses();

							bindMatrix = this.matrixWorld;
						}

						this.bindMatrix.copy(bindMatrix);
						this.bindMatrixInverse.copy(bindMatrix).invert();
					}

					pose() {
						this.skeleton.pose();
					}

					normalizeSkinWeights() {
						const vector = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"]();

						const skinWeight = this.geometry.attributes.skinWeight;

						for (let i = 0, l = skinWeight.count; i < l; i++) {
							vector.x = skinWeight.getX(i);
							vector.y = skinWeight.getY(i);
							vector.z = skinWeight.getZ(i);
							vector.w = skinWeight.getW(i);

							const scale = 1.0 / vector.manhattanLength();

							if (scale !== Infinity) {
								vector.multiplyScalar(scale);
							} else {
								vector.set(1, 0, 0, 0); // do something reasonable
							}

							skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
						}
					}

					updateMatrixWorld(force) {
						super.updateMatrixWorld(force);

						if (this.bindMode === 'attached') {
							this.bindMatrixInverse.copy(this.matrixWorld).invert();
						} else if (this.bindMode === 'detached') {
							this.bindMatrixInverse.copy(this.bindMatrix).invert();
						} else {
							console.warn(
								'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode
							);
						}
					}

					boneTransform(index, target) {
						const skeleton = this.skeleton;
						const geometry = this.geometry;

						_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
						_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);

						_basePosition.copy(target).applyMatrix4(this.bindMatrix);

						target.set(0, 0, 0);

						for (let i = 0; i < 4; i++) {
							const weight = _skinWeight.getComponent(i);

							if (weight !== 0) {
								const boneIndex = _skinIndex.getComponent(i);

								_matrix.multiplyMatrices(
									skeleton.bones[boneIndex].matrixWorld,
									skeleton.boneInverses[boneIndex]
								);

								target.addScaledVector(
									_vector.copy(_basePosition).applyMatrix4(_matrix),
									weight
								);
							}
						}

						return target.applyMatrix4(this.bindMatrixInverse);
					}
				}

				SkinnedMesh.prototype.isSkinnedMesh = true;




				/***/
}),

/***/ "./libs/three/postprocessing/EffectComposer.js":
/*!*****************************************************!*\
  !*** ./libs/three/postprocessing/EffectComposer.js ***!
  \*****************************************************/
/*! exports provided: EffectComposer, Pass, FullScreenQuad */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EffectComposer", function () { return EffectComposer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pass", function () { return Pass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FullScreenQuad", function () { return FullScreenQuad; });
/* harmony import */ var _cameras_OrthographicCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cameras/OrthographicCamera */ "./libs/three/cameras/OrthographicCamera.js");
/* harmony import */ var _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute */ "./libs/three/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferGeometry */ "./libs/three/core/BufferGeometry.js");
/* harmony import */ var _core_Clock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/Clock */ "./libs/three/core/Clock.js");
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector2 */ "./libs/three/math/Vector2.js");
/* harmony import */ var _objects_Mesh__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../objects/Mesh */ "./libs/three/objects/Mesh.js");
/* harmony import */ var _renderers_WebGLRenderTarget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../renderers/WebGLRenderTarget */ "./libs/three/renderers/WebGLRenderTarget.js");
/* harmony import */ var _shaders_CopyShader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shaders/CopyShader */ "./libs/three/shaders/CopyShader.js");
/* harmony import */ var _MaskPass__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MaskPass */ "./libs/three/postprocessing/MaskPass.js");
/* harmony import */ var _ShaderPass__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ShaderPass */ "./libs/three/postprocessing/ShaderPass.js");












				class EffectComposer {

					constructor(renderer, renderTarget) {

						this.renderer = renderer;

						if (renderTarget === undefined) {

							const size = renderer.getSize(new _math_Vector2__WEBPACK_IMPORTED_MODULE_4__["Vector2"]());
							this._pixelRatio = renderer.getPixelRatio();
							this._width = size.width;
							this._height = size.height;

							renderTarget = new _renderers_WebGLRenderTarget__WEBPACK_IMPORTED_MODULE_6__["WebGLRenderTarget"](this._width * this._pixelRatio, this._height * this._pixelRatio);
							renderTarget.texture.name = 'EffectComposer.rt1';

						} else {

							this._pixelRatio = 1;
							this._width = renderTarget.width;
							this._height = renderTarget.height;

						}

						this.renderTarget1 = renderTarget;
						this.renderTarget2 = renderTarget.clone();
						this.renderTarget2.texture.name = 'EffectComposer.rt2';

						this.writeBuffer = this.renderTarget1;
						this.readBuffer = this.renderTarget2;

						this.renderToScreen = true;

						this.passes = [];

						// dependencies

						if (_shaders_CopyShader__WEBPACK_IMPORTED_MODULE_7__["CopyShader"] === undefined) {

							console.error('THREE.EffectComposer relies on CopyShader');

						}

						if (_ShaderPass__WEBPACK_IMPORTED_MODULE_9__["ShaderPass"] === undefined) {

							console.error('THREE.EffectComposer relies on ShaderPass');

						}

						this.copyPass = new _ShaderPass__WEBPACK_IMPORTED_MODULE_9__["ShaderPass"](_shaders_CopyShader__WEBPACK_IMPORTED_MODULE_7__["CopyShader"]);

						this.clock = new _core_Clock__WEBPACK_IMPORTED_MODULE_3__["Clock"]();

					}

					swapBuffers() {

						const tmp = this.readBuffer;
						this.readBuffer = this.writeBuffer;
						this.writeBuffer = tmp;

					}

					addPass(pass) {

						this.passes.push(pass);
						pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);

					}

					insertPass(pass, index) {

						this.passes.splice(index, 0, pass);
						pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);

					}

					removePass(pass) {

						const index = this.passes.indexOf(pass);

						if (index !== - 1) {

							this.passes.splice(index, 1);

						}

					}

					isLastEnabledPass(passIndex) {

						for (let i = passIndex + 1; i < this.passes.length; i++) {

							if (this.passes[i].enabled) {

								return false;

							}

						}

						return true;

					}

					render(deltaTime) {

						// deltaTime value is in seconds

						if (deltaTime === undefined) {

							deltaTime = this.clock.getDelta();

						}

						const currentRenderTarget = this.renderer.getRenderTarget();

						let maskActive = false;

						for (let i = 0, il = this.passes.length; i < il; i++) {

							const pass = this.passes[i];

							if (pass.enabled === false) continue;

							pass.renderToScreen = (this.renderToScreen && this.isLastEnabledPass(i));
							pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);

							if (pass.needsSwap) {

								if (maskActive) {

									const context = this.renderer.getContext();
									const stencil = this.renderer.state.buffers.stencil;

									//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );
									stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);

									this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);

									//context.stencilFunc( context.EQUAL, 1, 0xffffffff );
									stencil.setFunc(context.EQUAL, 1, 0xffffffff);

								}

								this.swapBuffers();

							}

							if (_MaskPass__WEBPACK_IMPORTED_MODULE_8__["MaskPass"] !== undefined) {

								if (pass instanceof _MaskPass__WEBPACK_IMPORTED_MODULE_8__["MaskPass"]) {

									maskActive = true;

								} else if (pass instanceof _MaskPass__WEBPACK_IMPORTED_MODULE_8__["ClearMaskPass"]) {

									maskActive = false;

								}

							}

						}

						this.renderer.setRenderTarget(currentRenderTarget);

					}

					reset(renderTarget) {

						if (renderTarget === undefined) {

							const size = this.renderer.getSize(new _math_Vector2__WEBPACK_IMPORTED_MODULE_4__["Vector2"]());
							this._pixelRatio = this.renderer.getPixelRatio();
							this._width = size.width;
							this._height = size.height;

							renderTarget = this.renderTarget1.clone();
							renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);

						}

						this.renderTarget1.dispose();
						this.renderTarget2.dispose();
						this.renderTarget1 = renderTarget;
						this.renderTarget2 = renderTarget.clone();

						this.writeBuffer = this.renderTarget1;
						this.readBuffer = this.renderTarget2;

					}

					setSize(width, height) {

						this._width = width;
						this._height = height;

						const effectiveWidth = this._width * this._pixelRatio;
						const effectiveHeight = this._height * this._pixelRatio;

						this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
						this.renderTarget2.setSize(effectiveWidth, effectiveHeight);

						for (let i = 0; i < this.passes.length; i++) {

							this.passes[i].setSize(effectiveWidth, effectiveHeight);

						}

					}

					setPixelRatio(pixelRatio) {

						this._pixelRatio = pixelRatio;

						this.setSize(this._width, this._height);

					}

				}


				class Pass {

					constructor() {

						// if set to true, the pass is processed by the composer
						this.enabled = true;

						// if set to true, the pass indicates to swap read and write buffer after rendering
						this.needsSwap = true;

						// if set to true, the pass clears its buffer before rendering
						this.clear = false;

						// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
						this.renderToScreen = false;

					}

					setSize( /* width, height */) { }

					render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */) {

						console.error('THREE.Pass: .render() must be implemented in derived pass.');

					}

				}

				// Helper for passes that need to fill the viewport with a single quad.

				const _camera = new _cameras_OrthographicCamera__WEBPACK_IMPORTED_MODULE_0__["OrthographicCamera"](- 1, 1, 1, - 1, 0, 1);

				// https://github.com/mrdoob/three.js/pull/21358

				const _geometry = new _core_BufferGeometry__WEBPACK_IMPORTED_MODULE_2__["BufferGeometry"]();
				_geometry.setAttribute('position', new _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]([- 1, 3, 0, - 1, - 1, 0, 3, - 1, 0], 3));
				_geometry.setAttribute('uv', new _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]([0, 2, 0, 0, 2, 0], 2));

				class FullScreenQuad {

					constructor(material) {

						this._mesh = new _objects_Mesh__WEBPACK_IMPORTED_MODULE_5__["Mesh"](_geometry, material);

					}

					dispose() {

						this._mesh.geometry.dispose();

					}

					render(renderer) {

						renderer.render(this._mesh, _camera);

					}

					get material() {

						return this._mesh.material;

					}

					set material(value) {

						this._mesh.material = value;

					}

				}




				/***/
}),

/***/ "./libs/three/postprocessing/MaskPass.js":
/*!***********************************************!*\
  !*** ./libs/three/postprocessing/MaskPass.js ***!
  \***********************************************/
/*! exports provided: MaskPass, ClearMaskPass */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaskPass", function () { return MaskPass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClearMaskPass", function () { return ClearMaskPass; });
/* harmony import */ var _Pass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Pass.js */ "./libs/three/postprocessing/Pass.js");


				class MaskPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_0__["Pass"] {

					constructor(scene, camera) {

						super();

						this.scene = scene;
						this.camera = camera;

						this.clear = true;
						this.needsSwap = false;

						this.inverse = false;

					}

					render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {

						const context = renderer.getContext();
						const state = renderer.state;

						// don't update color or depth

						state.buffers.color.setMask(false);
						state.buffers.depth.setMask(false);

						// lock buffers

						state.buffers.color.setLocked(true);
						state.buffers.depth.setLocked(true);

						// set up stencil

						let writeValue, clearValue;

						if (this.inverse) {

							writeValue = 0;
							clearValue = 1;

						} else {

							writeValue = 1;
							clearValue = 0;

						}

						state.buffers.stencil.setTest(true);
						state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
						state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
						state.buffers.stencil.setClear(clearValue);
						state.buffers.stencil.setLocked(true);

						// draw into the stencil buffer

						renderer.setRenderTarget(readBuffer);
						if (this.clear) renderer.clear();
						renderer.render(this.scene, this.camera);

						renderer.setRenderTarget(writeBuffer);
						if (this.clear) renderer.clear();
						renderer.render(this.scene, this.camera);

						// unlock color and depth buffer for subsequent rendering

						state.buffers.color.setLocked(false);
						state.buffers.depth.setLocked(false);

						// only render where stencil is set to 1

						state.buffers.stencil.setLocked(false);
						state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1
						state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
						state.buffers.stencil.setLocked(true);

					}

				}

				class ClearMaskPass extends _Pass_js__WEBPACK_IMPORTED_MODULE_0__["Pass"] {

					constructor() {

						super();

						this.needsSwap = false;

					}

					render(renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */) {

						renderer.state.buffers.stencil.setLocked(false);
						renderer.state.buffers.stencil.setTest(false);

					}

				}




				/***/
}),

/***/ "./libs/three/postprocessing/Pass.js":
/*!*******************************************!*\
  !*** ./libs/three/postprocessing/Pass.js ***!
  \*******************************************/
/*! exports provided: Pass, FullScreenQuad */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pass", function () { return Pass; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FullScreenQuad", function () { return FullScreenQuad; });
/* harmony import */ var _cameras_OrthographicCamera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cameras/OrthographicCamera */ "./libs/three/cameras/OrthographicCamera.js");
/* harmony import */ var _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/BufferAttribute */ "./libs/three/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/BufferGeometry */ "./libs/three/core/BufferGeometry.js");
/* harmony import */ var _objects_Mesh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../objects/Mesh */ "./libs/three/objects/Mesh.js");





				class Pass {

					constructor() {

						// if set to true, the pass is processed by the composer
						this.enabled = true;

						// if set to true, the pass indicates to swap read and write buffer after rendering
						this.needsSwap = true;

						// if set to true, the pass clears its buffer before rendering
						this.clear = false;

						// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
						this.renderToScreen = false;

					}

					setSize( /* width, height */) { }

					render( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */) {

						console.error('THREE.Pass: .render() must be implemented in derived pass.');

					}

				}

				// Helper for passes that need to fill the viewport with a single quad.

				const _camera = new _cameras_OrthographicCamera__WEBPACK_IMPORTED_MODULE_0__["OrthographicCamera"](- 1, 1, 1, - 1, 0, 1);

				// https://github.com/mrdoob/three.js/pull/21358

				const _geometry = new _core_BufferGeometry__WEBPACK_IMPORTED_MODULE_2__["BufferGeometry"]();
				_geometry.setAttribute('position', new _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]([- 1, 3, 0, - 1, - 1, 0, 3, - 1, 0], 3));
				_geometry.setAttribute('uv', new _core_BufferAttribute__WEBPACK_IMPORTED_MODULE_1__["Float32BufferAttribute"]([0, 2, 0, 0, 2, 0], 2));

				class FullScreenQuad {

					constructor(material) {

						this._mesh = new _objects_Mesh__WEBPACK_IMPORTED_MODULE_3__["Mesh"](_geometry, material);

					}

					dispose() {

						this._mesh.geometry.dispose();

					}

					render(renderer) {

						renderer.render(this._mesh, _camera);

					}

					get material() {

						return this._mesh.material;

					}

					set material(value) {

						this._mesh.material = value;

					}

				}




				/***/
}),

/***/ "./libs/three/postprocessing/RenderPass.js":
/*!*************************************************!*\
  !*** ./libs/three/postprocessing/RenderPass.js ***!
  \*************************************************/
/*! exports provided: RenderPass */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RenderPass", function () { return RenderPass; });
/* harmony import */ var _math_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Color */ "./libs/three/math/Color.js");
/* harmony import */ var _Pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Pass */ "./libs/three/postprocessing/Pass.js");



				class RenderPass extends _Pass__WEBPACK_IMPORTED_MODULE_1__["Pass"] {

					constructor(scene, camera, overrideMaterial, clearColor, clearAlpha) {

						super();

						this.scene = scene;
						this.camera = camera;

						this.overrideMaterial = overrideMaterial;

						this.clearColor = clearColor;
						this.clearAlpha = (clearAlpha !== undefined) ? clearAlpha : 0;

						this.clear = true;
						this.clearDepth = false;
						this.needsSwap = false;
						this._oldClearColor = new _math_Color__WEBPACK_IMPORTED_MODULE_0__["Color"]();

					}

					render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {

						const oldAutoClear = renderer.autoClear;
						renderer.autoClear = false;

						let oldClearAlpha, oldOverrideMaterial;

						if (this.overrideMaterial !== undefined) {

							oldOverrideMaterial = this.scene.overrideMaterial;

							this.scene.overrideMaterial = this.overrideMaterial;

						}

						if (this.clearColor) {

							renderer.getClearColor(this._oldClearColor);
							oldClearAlpha = renderer.getClearAlpha();

							renderer.setClearColor(this.clearColor, this.clearAlpha);

						}

						if (this.clearDepth) {

							renderer.clearDepth();

						}

						renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);

						// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
						if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
						renderer.render(this.scene, this.camera);

						if (this.clearColor) {

							renderer.setClearColor(this._oldClearColor, oldClearAlpha);

						}

						if (this.overrideMaterial !== undefined) {

							this.scene.overrideMaterial = oldOverrideMaterial;

						}

						renderer.autoClear = oldAutoClear;

					}

				}




				/***/
}),

/***/ "./libs/three/postprocessing/ShaderPass.js":
/*!*************************************************!*\
  !*** ./libs/three/postprocessing/ShaderPass.js ***!
  \*************************************************/
/*! exports provided: ShaderPass */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderPass", function () { return ShaderPass; });
/* harmony import */ var _materials_ShaderMaterial__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials/ShaderMaterial */ "./libs/three/materials/ShaderMaterial.js");
/* harmony import */ var _renderers_shaders_UniformsUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderers/shaders/UniformsUtils */ "./libs/three/renderers/shaders/UniformsUtils.js");
/* harmony import */ var _Pass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Pass */ "./libs/three/postprocessing/Pass.js");





				class ShaderPass extends _Pass__WEBPACK_IMPORTED_MODULE_2__["Pass"] {

					constructor(shader, textureID) {

						super();

						this.textureID = (textureID !== undefined) ? textureID : 'tDiffuse';

						if (shader instanceof _materials_ShaderMaterial__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"]) {

							this.uniforms = shader.uniforms;

							this.material = shader;

						} else if (shader) {

							this.uniforms = _renderers_shaders_UniformsUtils__WEBPACK_IMPORTED_MODULE_1__["UniformsUtils"].clone(shader.uniforms);

							this.material = new _materials_ShaderMaterial__WEBPACK_IMPORTED_MODULE_0__["ShaderMaterial"]({

								defines: Object.assign({}, shader.defines),
								uniforms: this.uniforms,
								vertexShader: shader.vertexShader,
								fragmentShader: shader.fragmentShader

							});

						}

						this.fsQuad = new _Pass__WEBPACK_IMPORTED_MODULE_2__["FullScreenQuad"](this.material);

					}

					render(renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */) {

						if (this.uniforms[this.textureID]) {

							this.uniforms[this.textureID].value = readBuffer.texture;

						}

						this.fsQuad.material = this.material;

						if (this.renderToScreen) {

							renderer.setRenderTarget(null);
							this.fsQuad.render(renderer);

						} else {

							renderer.setRenderTarget(writeBuffer);
							// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
							if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
							this.fsQuad.render(renderer);

						}

					}

				}




				/***/
}),

/***/ "./libs/three/renderers/WebGL1Renderer.js":
/*!************************************************!*\
  !*** ./libs/three/renderers/WebGL1Renderer.js ***!
  \************************************************/
/*! exports provided: WebGL1Renderer */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGL1Renderer", function () { return WebGL1Renderer; });
/* harmony import */ var _WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRenderer.js */ "./libs/three/renderers/WebGLRenderer.js");


				class WebGL1Renderer extends _WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderer"] { }

				WebGL1Renderer.prototype.isWebGL1Renderer = true;




				/***/
}),

/***/ "./libs/three/renderers/WebGLCubeRenderTarget.js":
/*!*******************************************************!*\
  !*** ./libs/three/renderers/WebGLCubeRenderTarget.js ***!
  \*******************************************************/
/*! exports provided: WebGLCubeRenderTarget */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeRenderTarget", function () { return WebGLCubeRenderTarget; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../objects/Mesh.js */ "./libs/three/objects/Mesh.js");
/* harmony import */ var _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometries/BoxGeometry.js */ "./libs/three/geometries/BoxGeometry.js");
/* harmony import */ var _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../materials/ShaderMaterial.js */ "./libs/three/materials/ShaderMaterial.js");
/* harmony import */ var _shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/UniformsUtils.js */ "./libs/three/renderers/shaders/UniformsUtils.js");
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WebGLRenderTarget.js */ "./libs/three/renderers/WebGLRenderTarget.js");
/* harmony import */ var _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../cameras/CubeCamera.js */ "./libs/three/cameras/CubeCamera.js");
/* harmony import */ var _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../textures/CubeTexture.js */ "./libs/three/textures/CubeTexture.js");









				class WebGLCubeRenderTarget extends _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_5__["WebGLRenderTarget"] {
					constructor(size, options, dummy) {
						if (Number.isInteger(options)) {
							console.warn(
								'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )'
							);

							options = dummy;
						}

						super(size, size, options);

						options = options || {};

						// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
						// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
						// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

						// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
						// and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
						// as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

						this.texture = new _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_7__["CubeTexture"](
							undefined,
							options.mapping,
							options.wrapS,
							options.wrapT,
							options.magFilter,
							options.minFilter,
							options.format,
							options.type,
							options.anisotropy,
							options.encoding
						);
						this.texture.isRenderTargetTexture = true;

						this.texture.generateMipmaps =
							options.generateMipmaps !== undefined ? options.generateMipmaps : false;
						this.texture.minFilter =
							options.minFilter !== undefined ? options.minFilter : _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

						this.texture._needsFlipEnvMap = false;
					}

					fromEquirectangularTexture(renderer, texture) {
						this.texture.type = texture.type;
						this.texture.format = _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"]; // see #18859
						this.texture.encoding = texture.encoding;

						this.texture.generateMipmaps = texture.generateMipmaps;
						this.texture.minFilter = texture.minFilter;
						this.texture.magFilter = texture.magFilter;

						const shader = {
							uniforms: {
								tEquirect: { value: null }
							},

							vertexShader: /* glsl */ `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

							fragmentShader: /* glsl */ `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
						};

						const geometry = new _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_2__["BoxGeometry"](5, 5, 5);

						const material = new _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__["ShaderMaterial"]({
							name: 'CubemapFromEquirect',

							uniforms: Object(_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_4__["cloneUniforms"])(shader.uniforms),
							vertexShader: shader.vertexShader,
							fragmentShader: shader.fragmentShader,
							side: _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"],
							blending: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"]
						});

						material.uniforms.tEquirect.value = texture;

						const mesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_1__["Mesh"](geometry, material);

						const currentMinFilter = texture.minFilter;

						// Avoid blurred poles
						if (texture.minFilter === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"])
							texture.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"];

						const camera = new _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_6__["CubeCamera"](1, 10, this);
						camera.update(renderer, mesh);

						texture.minFilter = currentMinFilter;

						mesh.geometry.dispose();
						mesh.material.dispose();

						return this;
					}

					clear(renderer, color, depth, stencil) {
						const currentRenderTarget = renderer.getRenderTarget();

						for (let i = 0; i < 6; i++) {
							renderer.setRenderTarget(this, i);

							renderer.clear(color, depth, stencil);
						}

						renderer.setRenderTarget(currentRenderTarget);
					}
				}

				WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;




				/***/
}),

/***/ "./libs/three/renderers/WebGLMultisampleRenderTarget.js":
/*!**************************************************************!*\
  !*** ./libs/three/renderers/WebGLMultisampleRenderTarget.js ***!
  \**************************************************************/
/*! exports provided: WebGLMultisampleRenderTarget */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function () { return WebGLMultisampleRenderTarget; });
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRenderTarget.js */ "./libs/three/renderers/WebGLRenderTarget.js");


				class WebGLMultisampleRenderTarget extends _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderTarget"] {
					constructor(width, height, options) {
						super(width, height, options);

						this.samples = 4;
					}

					copy(source) {
						super.copy.call(this, source);

						this.samples = source.samples;

						return this;
					}
				}

				WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;




				/***/
}),

/***/ "./libs/three/renderers/WebGLRenderTarget.js":
/*!***************************************************!*\
  !*** ./libs/three/renderers/WebGLRenderTarget.js ***!
  \***************************************************/
/*! exports provided: WebGLRenderTarget */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function () { return WebGLRenderTarget; });
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher.js */ "./libs/three/core/EventDispatcher.js");
/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../textures/Texture.js */ "./libs/three/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector4.js */ "./libs/three/math/Vector4.js");





				/*
				 In options, we can specify:
				 * Texture parameters for an auto-generated target texture
				 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
				*/
				class WebGLRenderTarget extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"] {
					constructor(width, height, options = {}) {
						super();

						this.width = width;
						this.height = height;
						this.depth = 1;

						this.scissor = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"](0, 0, width, height);
						this.scissorTest = false;

						this.viewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_3__["Vector4"](0, 0, width, height);

						this.texture = new _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__["Texture"](
							undefined,
							options.mapping,
							options.wrapS,
							options.wrapT,
							options.magFilter,
							options.minFilter,
							options.format,
							options.type,
							options.anisotropy,
							options.encoding
						);
						this.texture.isRenderTargetTexture = true;

						this.texture.image = { width: width, height: height, depth: 1 };

						this.texture.generateMipmaps =
							options.generateMipmaps !== undefined ? options.generateMipmaps : false;
						this.texture.internalFormat =
							options.internalFormat !== undefined ? options.internalFormat : null;
						this.texture.minFilter =
							options.minFilter !== undefined ? options.minFilter : _constants_js__WEBPACK_IMPORTED_MODULE_2__["LinearFilter"];

						this.depthBuffer =
							options.depthBuffer !== undefined ? options.depthBuffer : true;
						this.stencilBuffer =
							options.stencilBuffer !== undefined ? options.stencilBuffer : false;
						this.depthTexture =
							options.depthTexture !== undefined ? options.depthTexture : null;
					}

					setTexture(texture) {
						texture.image = {
							width: this.width,
							height: this.height,
							depth: this.depth
						};

						this.texture = texture;
					}

					setSize(width, height, depth = 1) {
						if (
							this.width !== width ||
							this.height !== height ||
							this.depth !== depth
						) {
							this.width = width;
							this.height = height;
							this.depth = depth;

							this.texture.image.width = width;
							this.texture.image.height = height;
							this.texture.image.depth = depth;

							this.dispose();
						}

						this.viewport.set(0, 0, width, height);
						this.scissor.set(0, 0, width, height);
					}

					clone() {
						return new this.constructor().copy(this);
					}

					copy(source) {
						this.width = source.width;
						this.height = source.height;
						this.depth = source.depth;

						this.viewport.copy(source.viewport);

						this.texture = source.texture.clone();
						this.texture.image = { ...this.texture.image }; // See #20328.

						this.depthBuffer = source.depthBuffer;
						this.stencilBuffer = source.stencilBuffer;
						this.depthTexture = source.depthTexture;

						return this;
					}

					dispose() {
						this.dispatchEvent({ type: 'dispose' });
					}
				}

				WebGLRenderTarget.prototype.isWebGLRenderTarget = true;




				/***/
}),

/***/ "./libs/three/renderers/WebGLRenderer.js":
/*!***********************************************!*\
  !*** ./libs/three/renderers/WebGLRenderer.js ***!
  \***********************************************/
/*! exports provided: WebGLRenderer */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function () { return WebGLRenderer; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/Frustum.js */ "./libs/three/math/Frustum.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Vector4.js */ "./libs/three/math/Vector4.js");
/* harmony import */ var _webgl_WebGLAnimation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webgl/WebGLAnimation.js */ "./libs/three/renderers/webgl/WebGLAnimation.js");
/* harmony import */ var _webgl_WebGLAttributes_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./webgl/WebGLAttributes.js */ "./libs/three/renderers/webgl/WebGLAttributes.js");
/* harmony import */ var _webgl_WebGLBackground_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./webgl/WebGLBackground.js */ "./libs/three/renderers/webgl/WebGLBackground.js");
/* harmony import */ var _webgl_WebGLBindingStates_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./webgl/WebGLBindingStates.js */ "./libs/three/renderers/webgl/WebGLBindingStates.js");
/* harmony import */ var _webgl_WebGLBufferRenderer_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./webgl/WebGLBufferRenderer.js */ "./libs/three/renderers/webgl/WebGLBufferRenderer.js");
/* harmony import */ var _webgl_WebGLCapabilities_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./webgl/WebGLCapabilities.js */ "./libs/three/renderers/webgl/WebGLCapabilities.js");
/* harmony import */ var _webgl_WebGLClipping_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./webgl/WebGLClipping.js */ "./libs/three/renderers/webgl/WebGLClipping.js");
/* harmony import */ var _webgl_WebGLCubeMaps_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./webgl/WebGLCubeMaps.js */ "./libs/three/renderers/webgl/WebGLCubeMaps.js");
/* harmony import */ var _webgl_WebGLCubeUVMaps_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./webgl/WebGLCubeUVMaps.js */ "./libs/three/renderers/webgl/WebGLCubeUVMaps.js");
/* harmony import */ var _webgl_WebGLExtensions_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./webgl/WebGLExtensions.js */ "./libs/three/renderers/webgl/WebGLExtensions.js");
/* harmony import */ var _webgl_WebGLGeometries_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./webgl/WebGLGeometries.js */ "./libs/three/renderers/webgl/WebGLGeometries.js");
/* harmony import */ var _webgl_WebGLIndexedBufferRenderer_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./webgl/WebGLIndexedBufferRenderer.js */ "./libs/three/renderers/webgl/WebGLIndexedBufferRenderer.js");
/* harmony import */ var _webgl_WebGLInfo_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./webgl/WebGLInfo.js */ "./libs/three/renderers/webgl/WebGLInfo.js");
/* harmony import */ var _webgl_WebGLMorphtargets_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./webgl/WebGLMorphtargets.js */ "./libs/three/renderers/webgl/WebGLMorphtargets.js");
/* harmony import */ var _WebGLMultisampleRenderTarget_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./WebGLMultisampleRenderTarget.js */ "./libs/three/renderers/WebGLMultisampleRenderTarget.js");
/* harmony import */ var _webgl_WebGLObjects_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./webgl/WebGLObjects.js */ "./libs/three/renderers/webgl/WebGLObjects.js");
/* harmony import */ var _webgl_WebGLPrograms_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./webgl/WebGLPrograms.js */ "./libs/three/renderers/webgl/WebGLPrograms.js");
/* harmony import */ var _webgl_WebGLProperties_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./webgl/WebGLProperties.js */ "./libs/three/renderers/webgl/WebGLProperties.js");
/* harmony import */ var _webgl_WebGLRenderLists_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./webgl/WebGLRenderLists.js */ "./libs/three/renderers/webgl/WebGLRenderLists.js");
/* harmony import */ var _webgl_WebGLRenderStates_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./webgl/WebGLRenderStates.js */ "./libs/three/renderers/webgl/WebGLRenderStates.js");
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./WebGLRenderTarget.js */ "./libs/three/renderers/WebGLRenderTarget.js");
/* harmony import */ var _webgl_WebGLShadowMap_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./webgl/WebGLShadowMap.js */ "./libs/three/renderers/webgl/WebGLShadowMap.js");
/* harmony import */ var _webgl_WebGLState_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./webgl/WebGLState.js */ "./libs/three/renderers/webgl/WebGLState.js");
/* harmony import */ var _webgl_WebGLTextures_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./webgl/WebGLTextures.js */ "./libs/three/renderers/webgl/WebGLTextures.js");
/* harmony import */ var _webgl_WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./webgl/WebGLUniforms.js */ "./libs/three/renderers/webgl/WebGLUniforms.js");
/* harmony import */ var _webgl_WebGLUtils_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./webgl/WebGLUtils.js */ "./libs/three/renderers/webgl/WebGLUtils.js");
/* harmony import */ var _webgl_WebGLMaterials_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./webgl/WebGLMaterials.js */ "./libs/three/renderers/webgl/WebGLMaterials.js");

































				function WebGLRenderer(parameters = {}) {
					const _canvas = parameters.canvas,
						_context = parameters.context !== undefined ? parameters.context : null,
						_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
						_depth = parameters.depth !== undefined ? parameters.depth : true,
						_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
						_antialias =
							parameters.antialias !== undefined ? parameters.antialias : false,
						_premultipliedAlpha =
							parameters.premultipliedAlpha !== undefined
								? parameters.premultipliedAlpha
								: true,
						_preserveDrawingBuffer =
							parameters.preserveDrawingBuffer !== undefined
								? parameters.preserveDrawingBuffer
								: false,
						_powerPreference =
							parameters.powerPreference !== undefined
								? parameters.powerPreference
								: 'default',
						_failIfMajorPerformanceCaveat =
							parameters.failIfMajorPerformanceCaveat !== undefined
								? parameters.failIfMajorPerformanceCaveat
								: false;

					let currentRenderList = null;
					let currentRenderState = null;

					// render() can be called from within a callback triggered by another render.
					// We track this so that the nested render call gets its list and state isolated from the parent render call.

					const renderListStack = [];
					const renderStateStack = [];

					// public properties

					// Debug configuration container
					this.debug = {
						/**
						 * Enables error checking and reporting when shader programs are being compiled
						 * @type {boolean}
						 */
						checkShaderErrors: true
					};

					// clearing

					this.autoClear = true;
					this.autoClearColor = true;
					this.autoClearDepth = true;
					this.autoClearStencil = true;

					// scene graph

					this.sortObjects = true;

					// user-defined clipping

					this.clippingPlanes = [];
					this.localClippingEnabled = false;

					// physically based shading

					this.gammaFactor = 2.0; // for backwards compatibility
					this.outputEncoding = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"];

					// physical lights

					this.physicallyCorrectLights = false;

					// tone mapping

					this.toneMapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoToneMapping"];
					this.toneMappingExposure = 1.0;

					// internal properties

					const _this = this;

					let _isContextLost = false;

					// internal state cache

					let _currentActiveCubeFace = 0;
					let _currentActiveMipmapLevel = 0;
					let _currentRenderTarget = null;
					let _currentMaterialId = -1;

					let _currentCamera = null;

					const _currentViewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_4__["Vector4"]();
					const _currentScissor = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_4__["Vector4"]();
					let _currentScissorTest = null;

					//

					let _width = _canvas.width;
					let _height = _canvas.height;

					let _pixelRatio = 1;
					let _opaqueSort = null;
					let _transparentSort = null;

					const _viewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_4__["Vector4"](0, 0, _width, _height);
					const _scissor = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_4__["Vector4"](0, 0, _width, _height);
					let _scissorTest = false;

					//

					const _currentDrawBuffers = [];

					// frustum

					const _frustum = new _math_Frustum_js__WEBPACK_IMPORTED_MODULE_1__["Frustum"]();

					// clipping

					let _clippingEnabled = false;
					let _localClippingEnabled = false;

					// transmission

					let _transmissionRenderTarget = null;

					// camera matrices cache

					const _projScreenMatrix = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_2__["Matrix4"]();

					const _vector3 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();

					const _emptyScene = {
						background: null,
						fog: null,
						environment: null,
						overrideMaterial: null,
						isScene: true
					};

					function getTargetPixelRatio() {
						return _currentRenderTarget === null ? _pixelRatio : 1;
					}

					// initialize

					let _gl = _context;

					function getContext(contextNames, contextAttributes) {
						for (let i = 0; i < contextNames.length; i++) {
							const contextName = contextNames[i];
							const context = _canvas.getContext(contextName, contextAttributes);
							if (context !== null) return context;
						}

						return null;
					}

					try {
						const contextAttributes = {
							alpha: _alpha,
							depth: _depth,
							stencil: _stencil,
							antialias: _antialias,
							premultipliedAlpha: _premultipliedAlpha,
							preserveDrawingBuffer: _preserveDrawingBuffer,
							powerPreference: _powerPreference,
							failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
						};

						// event listeners must be registered before WebGL context is created, see #12753

						// _canvas.addEventListener('webglcontextlost', onContextLost, false);
						// _canvas.addEventListener('webglcontextrestored', onContextRestore, false);

						if (_gl === null) {
							const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];

							if (_this.isWebGL1Renderer === true) {
								contextNames.shift();
							}
							_gl = getContext(contextNames, contextAttributes);

							if (_gl === null) {
								if (getContext(contextNames)) {
									throw new Error(
										'Error creating WebGL context with your selected attributes.'
									);
								} else {
									throw new Error('Error creating WebGL context.');
								}
							}
						}

						// Some experimental-webgl implementations do not have getShaderPrecisionFormat

						if (_gl.getShaderPrecisionFormat === undefined) {
							_gl.getShaderPrecisionFormat = function () {
								return { rangeMin: 1, rangeMax: 1, precision: 1 };
							};
						}
					} catch (error) {
						console.error('THREE.WebGLRenderer: ' + error.message);
						throw error;
					}

					let extensions, capabilities, state, info;
					let properties,
						textures,
						cubemaps,
						cubeuvmaps,
						attributes,
						geometries,
						objects;
					let programCache, materials, renderLists, renderStates, clipping, shadowMap;

					let background, morphtargets, bufferRenderer, indexedBufferRenderer;

					let utils, bindingStates;

					function initGLContext() {
						extensions = new _webgl_WebGLExtensions_js__WEBPACK_IMPORTED_MODULE_14__["WebGLExtensions"](_gl);

						capabilities = new _webgl_WebGLCapabilities_js__WEBPACK_IMPORTED_MODULE_10__["WebGLCapabilities"](_gl, extensions, parameters);

						extensions.init(capabilities);

						utils = new _webgl_WebGLUtils_js__WEBPACK_IMPORTED_MODULE_30__["WebGLUtils"](_gl, extensions, capabilities);

						state = new _webgl_WebGLState_js__WEBPACK_IMPORTED_MODULE_27__["WebGLState"](_gl, extensions, capabilities);

						_currentDrawBuffers[0] = _gl.BACK;

						info = new _webgl_WebGLInfo_js__WEBPACK_IMPORTED_MODULE_17__["WebGLInfo"](_gl);
						properties = new _webgl_WebGLProperties_js__WEBPACK_IMPORTED_MODULE_22__["WebGLProperties"]();
						textures = new _webgl_WebGLTextures_js__WEBPACK_IMPORTED_MODULE_28__["WebGLTextures"](
							_gl,
							extensions,
							state,
							properties,
							capabilities,
							utils,
							info
						);
						cubemaps = new _webgl_WebGLCubeMaps_js__WEBPACK_IMPORTED_MODULE_12__["WebGLCubeMaps"](_this);
						cubeuvmaps = new _webgl_WebGLCubeUVMaps_js__WEBPACK_IMPORTED_MODULE_13__["WebGLCubeUVMaps"](_this);
						attributes = new _webgl_WebGLAttributes_js__WEBPACK_IMPORTED_MODULE_6__["WebGLAttributes"](_gl, capabilities);
						bindingStates = new _webgl_WebGLBindingStates_js__WEBPACK_IMPORTED_MODULE_8__["WebGLBindingStates"](
							_gl,
							extensions,
							attributes,
							capabilities
						);
						geometries = new _webgl_WebGLGeometries_js__WEBPACK_IMPORTED_MODULE_15__["WebGLGeometries"](_gl, attributes, info, bindingStates);
						objects = new _webgl_WebGLObjects_js__WEBPACK_IMPORTED_MODULE_20__["WebGLObjects"](_gl, geometries, attributes, info);
						morphtargets = new _webgl_WebGLMorphtargets_js__WEBPACK_IMPORTED_MODULE_18__["WebGLMorphtargets"](_gl, capabilities, textures);
						clipping = new _webgl_WebGLClipping_js__WEBPACK_IMPORTED_MODULE_11__["WebGLClipping"](properties);
						programCache = new _webgl_WebGLPrograms_js__WEBPACK_IMPORTED_MODULE_21__["WebGLPrograms"](
							_this,
							cubemaps,
							cubeuvmaps,
							extensions,
							capabilities,
							bindingStates,
							clipping
						);
						materials = new _webgl_WebGLMaterials_js__WEBPACK_IMPORTED_MODULE_31__["WebGLMaterials"](properties);
						renderLists = new _webgl_WebGLRenderLists_js__WEBPACK_IMPORTED_MODULE_23__["WebGLRenderLists"](properties);
						renderStates = new _webgl_WebGLRenderStates_js__WEBPACK_IMPORTED_MODULE_24__["WebGLRenderStates"](extensions, capabilities);
						background = new _webgl_WebGLBackground_js__WEBPACK_IMPORTED_MODULE_7__["WebGLBackground"](
							_this,
							cubemaps,
							state,
							objects,
							_premultipliedAlpha
						);
						shadowMap = new _webgl_WebGLShadowMap_js__WEBPACK_IMPORTED_MODULE_26__["WebGLShadowMap"](_this, objects, capabilities);

						bufferRenderer = new _webgl_WebGLBufferRenderer_js__WEBPACK_IMPORTED_MODULE_9__["WebGLBufferRenderer"](
							_gl,
							extensions,
							info,
							capabilities
						);
						indexedBufferRenderer = new _webgl_WebGLIndexedBufferRenderer_js__WEBPACK_IMPORTED_MODULE_16__["WebGLIndexedBufferRenderer"](
							_gl,
							extensions,
							info,
							capabilities
						);

						info.programs = programCache.programs;

						_this.capabilities = capabilities;
						_this.extensions = extensions;
						_this.properties = properties;
						_this.renderLists = renderLists;
						_this.shadowMap = shadowMap;
						_this.state = state;
						_this.info = info;
					}

					initGLContext();

					// xr

					// const xr = new WebXRManager(_this, _gl);

					// this.xr = xr;

					// API

					this.getContext = function () {
						return _gl;
					};

					this.getContextAttributes = function () {
						return _gl.getContextAttributes();
					};

					this.forceContextLoss = function () {
						const extension = extensions.get('WEBGL_lose_context');
						if (extension) extension.loseContext();
					};

					this.forceContextRestore = function () {
						const extension = extensions.get('WEBGL_lose_context');
						if (extension) extension.restoreContext();
					};

					this.getPixelRatio = function () {
						return _pixelRatio;
					};

					this.setPixelRatio = function (value) {
						if (value === undefined) return;

						_pixelRatio = value;

						this.setSize(_width, _height, false);
					};

					this.getSize = function (target) {
						return target.set(_width, _height);
					};

					this.setSize = function (width, height, updateStyle = false) {
						// if (xr.isPresenting) {
						//   console.warn(
						//     "THREE.WebGLRenderer: Can't change size while VR device is presenting."
						//   );
						//   return;
						// }

						_width = width;
						_height = height;
						_canvas.width = Math.floor(width * _pixelRatio);
						_canvas.height = Math.floor(height * _pixelRatio);

						if (updateStyle !== false) {
							// _canvas.style.width = width + 'px';
							// _canvas.style.height = height + 'px';
						}

						this.setViewport(0, 0, width, height);
					};

					this.getDrawingBufferSize = function (target) {
						return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
					};

					this.setDrawingBufferSize = function (width, height, pixelRatio) {
						_width = width;
						_height = height;

						_pixelRatio = pixelRatio;

						_canvas.width = Math.floor(width * pixelRatio);
						_canvas.height = Math.floor(height * pixelRatio);

						this.setViewport(0, 0, width, height);
					};

					this.getCurrentViewport = function (target) {
						return target.copy(_currentViewport);
					};

					this.getViewport = function (target) {
						return target.copy(_viewport);
					};

					this.setViewport = function (x, y, width, height) {
						if (x.isVector4) {
							_viewport.set(x.x, x.y, x.z, x.w);
						} else {
							_viewport.set(x, y, width, height);
						}

						state.viewport(
							_currentViewport
								.copy(_viewport)
								.multiplyScalar(_pixelRatio)
								.floor()
						);
					};

					this.getScissor = function (target) {
						return target.copy(_scissor);
					};

					this.setScissor = function (x, y, width, height) {
						if (x.isVector4) {
							_scissor.set(x.x, x.y, x.z, x.w);
						} else {
							_scissor.set(x, y, width, height);
						}

						state.scissor(
							_currentScissor
								.copy(_scissor)
								.multiplyScalar(_pixelRatio)
								.floor()
						);
					};

					this.getScissorTest = function () {
						return _scissorTest;
					};

					this.setScissorTest = function (boolean) {
						state.setScissorTest((_scissorTest = boolean));
					};

					this.setOpaqueSort = function (method) {
						_opaqueSort = method;
					};

					this.setTransparentSort = function (method) {
						_transparentSort = method;
					};

					// Clearing

					this.getClearColor = function (target) {
						return target.copy(background.getClearColor());
					};

					this.setClearColor = function () {
						background.setClearColor.apply(background, arguments);
					};

					this.getClearAlpha = function () {
						return background.getClearAlpha();
					};

					this.setClearAlpha = function () {
						background.setClearAlpha.apply(background, arguments);
					};

					this.clear = function (color, depth, stencil) {
						let bits = 0;

						if (color === undefined || color) bits |= _gl.COLOR_BUFFER_BIT;
						if (depth === undefined || depth) bits |= _gl.DEPTH_BUFFER_BIT;
						if (stencil === undefined || stencil) bits |= _gl.STENCIL_BUFFER_BIT;

						_gl.clear(bits);
					};

					this.clearColor = function () {
						this.clear(true, false, false);
					};

					this.clearDepth = function () {
						this.clear(false, true, false);
					};

					this.clearStencil = function () {
						this.clear(false, false, true);
					};

					//

					this.dispose = function () {
						_canvas.removeEventListener('webglcontextlost', onContextLost, false);
						_canvas.removeEventListener(
							'webglcontextrestored',
							onContextRestore,
							false
						);

						renderLists.dispose();
						renderStates.dispose();
						properties.dispose();
						cubemaps.dispose();
						cubeuvmaps.dispose();
						objects.dispose();
						bindingStates.dispose();

						// xr.dispose();

						// xr.removeEventListener('sessionstart', onXRSessionStart);
						// xr.removeEventListener('sessionend', onXRSessionEnd);

						if (_transmissionRenderTarget) {
							_transmissionRenderTarget.dispose();
							_transmissionRenderTarget = null;
						}

						animation.stop();
					};

					// Events
					function onContextLost(event) {
						event.preventDefault();

						console.log('THREE.WebGLRenderer: Context Lost.');

						_isContextLost = true;
					}

					function onContextRestore(/* event */) {
						console.log('THREE.WebGLRenderer: Context Restored.');

						_isContextLost = false;

						const infoAutoReset = info.autoReset;
						const shadowMapEnabled = shadowMap.enabled;
						const shadowMapAutoUpdate = shadowMap.autoUpdate;
						const shadowMapNeedsUpdate = shadowMap.needsUpdate;
						const shadowMapType = shadowMap.type;

						initGLContext();

						info.autoReset = infoAutoReset;
						shadowMap.enabled = shadowMapEnabled;
						shadowMap.autoUpdate = shadowMapAutoUpdate;
						shadowMap.needsUpdate = shadowMapNeedsUpdate;
						shadowMap.type = shadowMapType;
					}

					function onMaterialDispose(event) {
						const material = event.target;

						material.removeEventListener('dispose', onMaterialDispose);

						deallocateMaterial(material);
					}

					// Buffer deallocation

					function deallocateMaterial(material) {
						releaseMaterialProgramReferences(material);

						properties.remove(material);
					}

					function releaseMaterialProgramReferences(material) {
						const programs = properties.get(material).programs;

						if (programs !== undefined) {
							programs.forEach(function (program) {
								programCache.releaseProgram(program);
							});
						}
					}

					// Buffer rendering

					this.renderBufferDirect = function (
						camera,
						scene,
						geometry,
						material,
						object,
						group
					) {
						if (scene === null) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

						const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;

						const program = setProgram(camera, scene, geometry, material, object);

						state.setMaterial(material, frontFaceCW);

						//

						let index = geometry.index;
						const position = geometry.attributes.position;

						//

						if (index === null) {
							if (position === undefined || position.count === 0) return;
						} else if (index.count === 0) {
							return;
						}

						//

						let rangeFactor = 1;

						if (material.wireframe === true) {
							index = geometries.getWireframeAttribute(geometry);
							rangeFactor = 2;
						}

						bindingStates.setup(object, material, program, geometry, index);

						let attribute;
						let renderer = bufferRenderer;

						if (index !== null) {
							attribute = attributes.get(index);

							renderer = indexedBufferRenderer;
							renderer.setIndex(attribute);
						}

						//

						const dataCount = index !== null ? index.count : position.count;

						const rangeStart = geometry.drawRange.start * rangeFactor;
						const rangeCount = geometry.drawRange.count * rangeFactor;

						const groupStart = group !== null ? group.start * rangeFactor : 0;
						const groupCount = group !== null ? group.count * rangeFactor : Infinity;

						const drawStart = Math.max(rangeStart, groupStart);
						const drawEnd =
							Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;

						const drawCount = Math.max(0, drawEnd - drawStart + 1);

						if (drawCount === 0) return;

						//

						if (material.name === 'BackgroundCubeMaterial')
							console.log(object.isMesh, material.wireframe);

						if (object.isMesh) {
							if (material.wireframe === true) {
								state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
								renderer.setMode(_gl.LINES);
							} else {
								renderer.setMode(_gl.TRIANGLES);
							}
						} else if (object.isLine) {
							let lineWidth = material.linewidth;

							if (lineWidth === undefined) lineWidth = 1; // Not using Line*Material

							state.setLineWidth(lineWidth * getTargetPixelRatio());

							if (object.isLineSegments) {
								renderer.setMode(_gl.LINES);
							} else if (object.isLineLoop) {
								renderer.setMode(_gl.LINE_LOOP);
							} else {
								renderer.setMode(_gl.LINE_STRIP);
							}
						} else if (object.isPoints) {
							renderer.setMode(_gl.POINTS);
						} else if (object.isSprite) {
							renderer.setMode(_gl.TRIANGLES);
						}
						if (object.isInstancedMesh) {
							renderer.renderInstances(drawStart, drawCount, object.count);
						} else if (geometry.isInstancedBufferGeometry) {
							const instanceCount = Math.min(
								geometry.instanceCount,
								geometry._maxInstanceCount
							);

							renderer.renderInstances(drawStart, drawCount, instanceCount);
						} else {
							renderer.render(drawStart, drawCount);
						}
					};

					// Compile

					this.compile = function (scene, camera) {
						currentRenderState = renderStates.get(scene);
						currentRenderState.init();

						renderStateStack.push(currentRenderState);

						scene.traverseVisible(function (object) {
							if (object.isLight && object.layers.test(camera.layers)) {
								currentRenderState.pushLight(object);

								if (object.castShadow) {
									currentRenderState.pushShadow(object);
								}
							}
						});

						currentRenderState.setupLights(_this.physicallyCorrectLights);

						scene.traverse(function (object) {
							const material = object.material;

							if (material) {
								if (Array.isArray(material)) {
									for (let i = 0; i < material.length; i++) {
										const material2 = material[i];

										getProgram(material2, scene, object);
									}
								} else {
									getProgram(material, scene, object);
								}
							}
						});

						renderStateStack.pop();
						currentRenderState = null;
					};

					// Animation Loop

					let onAnimationFrameCallback = null;

					function onAnimationFrame(time) {
						if (onAnimationFrameCallback) onAnimationFrameCallback(time);
					}

					// function onXRSessionStart() {
					//   animation.stop();
					// }

					// function onXRSessionEnd() {
					//   animation.start();
					// }

					const animation = new _webgl_WebGLAnimation_js__WEBPACK_IMPORTED_MODULE_5__["WebGLAnimation"]();
					animation.setAnimationLoop(onAnimationFrame);

					if (typeof window !== 'undefined') animation.setContext(window);

					this.setAnimationLoop = function (callback) {
						onAnimationFrameCallback = callback;
						// xr.setAnimationLoop(callback);

						callback === null ? animation.stop() : animation.start();
					};

					// xr.addEventListener('sessionstart', onXRSessionStart);
					// xr.addEventListener('sessionend', onXRSessionEnd);

					// Rendering

					this.render = function (scene, camera) {
						if (camera !== undefined && camera.isCamera !== true) {
							console.error(
								'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
							);
							return;
						}

						if (_isContextLost === true) return;

						// update scene graph

						if (scene.autoUpdate === true) scene.updateMatrixWorld();

						// update camera matrices and frustum

						if (camera.parent === null) camera.updateMatrixWorld();

						// if (xr.enabled === true && xr.isPresenting === true) {
						//   if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);

						//   camera = xr.getCamera(); // use XR camera for rendering
						// }

						//
						if (scene.isScene === true)
							scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);

						currentRenderState = renderStates.get(scene, renderStateStack.length);
						currentRenderState.init();

						renderStateStack.push(currentRenderState);

						_projScreenMatrix.multiplyMatrices(
							camera.projectionMatrix,
							camera.matrixWorldInverse
						);
						_frustum.setFromProjectionMatrix(_projScreenMatrix);

						_localClippingEnabled = this.localClippingEnabled;
						_clippingEnabled = clipping.init(
							this.clippingPlanes,
							_localClippingEnabled,
							camera
						);

						currentRenderList = renderLists.get(scene, renderListStack.length);
						currentRenderList.init();

						renderListStack.push(currentRenderList);

						projectObject(scene, camera, 0, _this.sortObjects);

						currentRenderList.finish();

						if (_this.sortObjects === true) {
							currentRenderList.sort(_opaqueSort, _transparentSort);
						}

						//

						if (_clippingEnabled === true) clipping.beginShadows();

						const shadowsArray = currentRenderState.state.shadowsArray;

						shadowMap.render(shadowsArray, scene, camera);

						if (_clippingEnabled === true) clipping.endShadows();

						//

						if (this.info.autoReset === true) this.info.reset();

						//

						background.render(currentRenderList, scene);

						// render scene

						currentRenderState.setupLights(_this.physicallyCorrectLights);

						if (camera.isArrayCamera) {
							const cameras = camera.cameras;

							for (let i = 0, l = cameras.length; i < l; i++) {
								const camera2 = cameras[i];

								renderScene(currentRenderList, scene, camera2, camera2.viewport);
							}
						} else {
							renderScene(currentRenderList, scene, camera);
						}

						//

						if (_currentRenderTarget !== null) {
							// resolve multisample renderbuffers to a single-sample texture if necessary

							textures.updateMultisampleRenderTarget(_currentRenderTarget);

							// Generate mipmap if we're using any kind of mipmap filtering

							textures.updateRenderTargetMipmap(_currentRenderTarget);
						}

						//

						if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);

						// Ensure depth buffer writing is enabled so it can be cleared on next render

						state.buffers.depth.setTest(true);
						state.buffers.depth.setMask(true);
						state.buffers.color.setMask(true);

						state.setPolygonOffset(false);

						// _gl.finish();

						bindingStates.resetDefaultState();
						_currentMaterialId = -1;
						_currentCamera = null;

						renderStateStack.pop();

						if (renderStateStack.length > 0) {
							currentRenderState = renderStateStack[renderStateStack.length - 1];
						} else {
							currentRenderState = null;
						}

						renderListStack.pop();

						if (renderListStack.length > 0) {
							currentRenderList = renderListStack[renderListStack.length - 1];
						} else {
							currentRenderList = null;
						}
					};

					function projectObject(object, camera, groupOrder, sortObjects) {
						if (object.visible === false) return;

						const visible = object.layers.test(camera.layers);

						if (visible) {
							if (object.isGroup) {
								groupOrder = object.renderOrder;
							} else if (object.isLOD) {
								if (object.autoUpdate === true) object.update(camera);
							} else if (object.isLight) {
								currentRenderState.pushLight(object);

								if (object.castShadow) {
									currentRenderState.pushShadow(object);
								}
							} else if (object.isSprite) {
								if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
									if (sortObjects) {
										_vector3
											.setFromMatrixPosition(object.matrixWorld)
											.applyMatrix4(_projScreenMatrix);
									}

									const geometry = objects.update(object);
									const material = object.material;

									if (material.visible) {
										currentRenderList.push(
											object,
											geometry,
											material,
											groupOrder,
											_vector3.z,
											null
										);
									}
								}
							} else if (object.isMesh || object.isLine || object.isPoints) {
								if (object.isSkinnedMesh) {
									// update skeleton only once in a frame

									if (object.skeleton.frame !== info.render.frame) {
										object.skeleton.update();
										object.skeleton.frame = info.render.frame;
									}
								}

								if (!object.frustumCulled || _frustum.intersectsObject(object)) {
									if (sortObjects) {
										_vector3
											.setFromMatrixPosition(object.matrixWorld)
											.applyMatrix4(_projScreenMatrix);
									}

									const geometry = objects.update(object);
									const material = object.material;

									if (Array.isArray(material)) {
										const groups = geometry.groups;

										for (let i = 0, l = groups.length; i < l; i++) {
											const group = groups[i];
											const groupMaterial = material[group.materialIndex];

											if (groupMaterial && groupMaterial.visible) {
												currentRenderList.push(
													object,
													geometry,
													groupMaterial,
													groupOrder,
													_vector3.z,
													group
												);
											}
										}
									} else if (material.visible) {
										currentRenderList.push(
											object,
											geometry,
											material,
											groupOrder,
											_vector3.z,
											null
										);
									}
								}
							}
						}

						const children = object.children;

						for (let i = 0, l = children.length; i < l; i++) {
							projectObject(children[i], camera, groupOrder, sortObjects);
						}
					}

					function renderScene(currentRenderList, scene, camera, viewport) {
						const opaqueObjects = currentRenderList.opaque;
						const transmissiveObjects = currentRenderList.transmissive;
						const transparentObjects = currentRenderList.transparent;

						currentRenderState.setupLightsView(camera);

						if (transmissiveObjects.length > 0)
							renderTransmissionPass(opaqueObjects, scene, camera);

						if (viewport) state.viewport(_currentViewport.copy(viewport));

						if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
						if (transmissiveObjects.length > 0)
							renderObjects(transmissiveObjects, scene, camera);
						if (transparentObjects.length > 0)
							renderObjects(transparentObjects, scene, camera);
					}

					function renderTransmissionPass(opaqueObjects, scene, camera) {
						if (_transmissionRenderTarget === null) {
							const needsAntialias =
								_antialias === true && capabilities.isWebGL2 === true;
							const renderTargetType = needsAntialias
								? _WebGLMultisampleRenderTarget_js__WEBPACK_IMPORTED_MODULE_19__["WebGLMultisampleRenderTarget"]
								: _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_25__["WebGLRenderTarget"];

							_transmissionRenderTarget = new renderTargetType(1024, 1024, {
								generateMipmaps: true,
								type:
									utils.convert(_constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"]) !== null
										? _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"]
										: _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"],
								minFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"],
								magFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
								wrapS: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"],
								wrapT: _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"]
							});
						}

						const currentRenderTarget = _this.getRenderTarget();
						_this.setRenderTarget(_transmissionRenderTarget);
						_this.clear();

						// Turn off the features which can affect the frag color for opaque objects pass.
						// Otherwise they are applied twice in opaque objects pass and transmission objects pass.
						const currentToneMapping = _this.toneMapping;
						_this.toneMapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoToneMapping"];

						renderObjects(opaqueObjects, scene, camera);

						_this.toneMapping = currentToneMapping;

						textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
						textures.updateRenderTargetMipmap(_transmissionRenderTarget);

						_this.setRenderTarget(currentRenderTarget);
					}

					function renderObjects(renderList, scene, camera) {
						const overrideMaterial =
							scene.isScene === true ? scene.overrideMaterial : null;

						for (let i = 0, l = renderList.length; i < l; i++) {
							const renderItem = renderList[i];

							const object = renderItem.object;
							const geometry = renderItem.geometry;
							const material =
								overrideMaterial === null ? renderItem.material : overrideMaterial;
							const group = renderItem.group;

							if (object.layers.test(camera.layers)) {
								renderObject(object, scene, camera, geometry, material, group);
							}
						}
					}

					function renderObject(object, scene, camera, geometry, material, group) {
						object.onBeforeRender(_this, scene, camera, geometry, material, group);

						object.modelViewMatrix.multiplyMatrices(
							camera.matrixWorldInverse,
							object.matrixWorld
						);
						object.normalMatrix.getNormalMatrix(object.modelViewMatrix);

						material.onBeforeRender(_this, scene, camera, geometry, object, group);

						if (material.transparent === true && material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"]) {
							material.side = _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"];
							material.needsUpdate = true;
							_this.renderBufferDirect(
								camera,
								scene,
								geometry,
								material,
								object,
								group
							);

							material.side = _constants_js__WEBPACK_IMPORTED_MODULE_0__["FrontSide"];
							material.needsUpdate = true;
							_this.renderBufferDirect(
								camera,
								scene,
								geometry,
								material,
								object,
								group
							);

							material.side = _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"];
						} else {
							_this.renderBufferDirect(
								camera,
								scene,
								geometry,
								material,
								object,
								group
							);
						}

						object.onAfterRender(_this, scene, camera, geometry, material, group);
					}

					function getProgram(material, scene, object) {
						if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

						const materialProperties = properties.get(material);

						const lights = currentRenderState.state.lights;
						const shadowsArray = currentRenderState.state.shadowsArray;

						const lightsStateVersion = lights.state.version;

						const parameters = programCache.getParameters(
							material,
							lights.state,
							shadowsArray,
							scene,
							object
						);
						const programCacheKey = programCache.getProgramCacheKey(parameters);

						let programs = materialProperties.programs;

						// always update environment and fog - changing these trigger an getProgram call, but it's possible that the program doesn't change

						materialProperties.environment = material.isMeshStandardMaterial
							? scene.environment
							: null;
						materialProperties.fog = scene.fog;
						materialProperties.envMap = (material.isMeshStandardMaterial
							? cubeuvmaps
							: cubemaps
						).get(material.envMap || materialProperties.environment);

						if (programs === undefined) {
							// new material

							material.addEventListener('dispose', onMaterialDispose);

							programs = new Map();
							materialProperties.programs = programs;
						}

						let program = programs.get(programCacheKey);

						if (program !== undefined) {
							// early out if program and light state is identical

							if (
								materialProperties.currentProgram === program &&
								materialProperties.lightsStateVersion === lightsStateVersion
							) {
								updateCommonMaterialProperties(material, parameters);

								return program;
							}
						} else {
							parameters.uniforms = programCache.getUniforms(material);

							material.onBuild(object, parameters, _this);

							material.onBeforeCompile(parameters, _this);

							program = programCache.acquireProgram(parameters, programCacheKey);
							programs.set(programCacheKey, program);

							materialProperties.uniforms = parameters.uniforms;
						}

						const uniforms = materialProperties.uniforms;

						if (
							(!material.isShaderMaterial && !material.isRawShaderMaterial) ||
							material.clipping === true
						) {
							uniforms.clippingPlanes = clipping.uniform;
						}

						updateCommonMaterialProperties(material, parameters);

						// store the light setup it was created for

						materialProperties.needsLights = materialNeedsLights(material);
						materialProperties.lightsStateVersion = lightsStateVersion;

						if (materialProperties.needsLights) {
							// wire up the material to this renderer's lighting state

							uniforms.ambientLightColor.value = lights.state.ambient;
							uniforms.lightProbe.value = lights.state.probe;
							uniforms.directionalLights.value = lights.state.directional;
							uniforms.directionalLightShadows.value = lights.state.directionalShadow;
							uniforms.spotLights.value = lights.state.spot;
							uniforms.spotLightShadows.value = lights.state.spotShadow;
							uniforms.rectAreaLights.value = lights.state.rectArea;
							uniforms.ltc_1.value = lights.state.rectAreaLTC1;
							uniforms.ltc_2.value = lights.state.rectAreaLTC2;
							uniforms.pointLights.value = lights.state.point;
							uniforms.pointLightShadows.value = lights.state.pointShadow;
							uniforms.hemisphereLights.value = lights.state.hemi;

							uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
							uniforms.directionalShadowMatrix.value =
								lights.state.directionalShadowMatrix;
							uniforms.spotShadowMap.value = lights.state.spotShadowMap;
							uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
							uniforms.pointShadowMap.value = lights.state.pointShadowMap;
							uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
							// TODO (abelnation): add area lights shadow info to uniforms
						}

						const progUniforms = program.getUniforms();
						const uniformsList = _webgl_WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_29__["WebGLUniforms"].seqWithValue(progUniforms.seq, uniforms);

						materialProperties.currentProgram = program;
						materialProperties.uniformsList = uniformsList;

						return program;
					}

					function updateCommonMaterialProperties(material, parameters) {
						const materialProperties = properties.get(material);

						materialProperties.outputEncoding = parameters.outputEncoding;
						materialProperties.instancing = parameters.instancing;
						materialProperties.skinning = parameters.skinning;
						materialProperties.morphTargets = parameters.morphTargets;
						materialProperties.morphNormals = parameters.morphNormals;
						materialProperties.morphTargetsCount = parameters.morphTargetsCount;
						materialProperties.numClippingPlanes = parameters.numClippingPlanes;
						materialProperties.numIntersection = parameters.numClipIntersection;
						materialProperties.vertexAlphas = parameters.vertexAlphas;
						materialProperties.vertexTangents = parameters.vertexTangents;
					}

					function setProgram(camera, scene, geometry, material, object) {
						if (scene.isScene !== true) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

						textures.resetTextureUnits();

						const fog = scene.fog;
						const environment = material.isMeshStandardMaterial
							? scene.environment
							: null;
						const encoding =
							_currentRenderTarget === null
								? _this.outputEncoding
								: _currentRenderTarget.texture.encoding;
						const envMap = (material.isMeshStandardMaterial
							? cubeuvmaps
							: cubemaps
						).get(material.envMap || environment);
						const vertexAlphas =
							material.vertexColors === true &&
							!!geometry.attributes.color &&
							geometry.attributes.color.itemSize === 4;
						const vertexTangents =
							!!material.normalMap && !!geometry.attributes.tangent;
						const morphTargets = !!geometry.morphAttributes.position;
						const morphNormals = !!geometry.morphAttributes.normal;
						const morphTargetsCount = !!geometry.morphAttributes.position
							? geometry.morphAttributes.position.length
							: 0;

						const materialProperties = properties.get(material);
						const lights = currentRenderState.state.lights;

						if (_clippingEnabled === true) {
							if (_localClippingEnabled === true || camera !== _currentCamera) {
								const useCache =
									camera === _currentCamera && material.id === _currentMaterialId;

								// we might want to call this function with some ClippingGroup
								// object instead of the material, once it becomes feasible
								// (#8465, #8379)
								clipping.setState(material, camera, useCache);
							}
						}

						//
						if (material.name === 'BackgroundCubeMaterial')
							console.log(material.isShaderMaterial, materialProperties.envMap, envMap);

						let needsProgramChange = false;

						if (material.version === materialProperties.__version) {
							if (
								materialProperties.needsLights &&
								materialProperties.lightsStateVersion !== lights.state.version
							) {
								needsProgramChange = true;
							} else if (materialProperties.outputEncoding !== encoding) {
								needsProgramChange = true;
							} else if (
								object.isInstancedMesh &&
								materialProperties.instancing === false
							) {
								needsProgramChange = true;
							} else if (
								!object.isInstancedMesh &&
								materialProperties.instancing === true
							) {
								needsProgramChange = true;
							} else if (
								object.isSkinnedMesh &&
								materialProperties.skinning === false
							) {
								needsProgramChange = true;
							} else if (
								!object.isSkinnedMesh &&
								materialProperties.skinning === true
							) {
								needsProgramChange = true;
							} else if (materialProperties.envMap !== envMap) {
								needsProgramChange = true;
							} else if (material.fog && materialProperties.fog !== fog) {
								needsProgramChange = true;
							} else if (
								materialProperties.numClippingPlanes !== undefined &&
								(materialProperties.numClippingPlanes !== clipping.numPlanes ||
									materialProperties.numIntersection !== clipping.numIntersection)
							) {
								needsProgramChange = true;
							} else if (materialProperties.vertexAlphas !== vertexAlphas) {
								needsProgramChange = true;
							} else if (materialProperties.vertexTangents !== vertexTangents) {
								needsProgramChange = true;
							} else if (materialProperties.morphTargets !== morphTargets) {
								needsProgramChange = true;
							} else if (materialProperties.morphNormals !== morphNormals) {
								needsProgramChange = true;
							} else if (
								capabilities.isWebGL2 === true &&
								materialProperties.morphTargetsCount !== morphTargetsCount
							) {
								needsProgramChange = true;
							}
						} else {
							needsProgramChange = true;
							materialProperties.__version = material.version;
						}

						//

						let program = materialProperties.currentProgram;

						if (needsProgramChange === true) {
							program = getProgram(material, scene, object);
						}

						let refreshProgram = false;
						let refreshMaterial = false;
						let refreshLights = false;

						const p_uniforms = program.getUniforms(),
							m_uniforms = materialProperties.uniforms;

						if (state.useProgram(program.program)) {
							refreshProgram = true;
							refreshMaterial = true;
							refreshLights = true;
						}

						if (material.id !== _currentMaterialId) {
							_currentMaterialId = material.id;

							refreshMaterial = true;
						}

						if (refreshProgram || _currentCamera !== camera) {
							p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);

							if (capabilities.logarithmicDepthBuffer) {
								p_uniforms.setValue(
									_gl,
									'logDepthBufFC',
									2.0 / (Math.log(camera.far + 1.0) / Math.LN2)
								);
							}

							if (_currentCamera !== camera) {
								_currentCamera = camera;

								// lighting uniforms depend on the camera so enforce an update
								// now, in case this material supports lights - or later, when
								// the next material that does gets activated:

								refreshMaterial = true; // set to true on material change
								refreshLights = true; // remains set until update done
							}

							// load material specific uniforms
							// (shader material also gets them for the sake of genericity)

							if (
								material.isShaderMaterial ||
								material.isMeshPhongMaterial ||
								material.isMeshToonMaterial ||
								material.isMeshStandardMaterial ||
								material.envMap
							) {
								const uCamPos = p_uniforms.map.cameraPosition;

								if (uCamPos !== undefined) {
									uCamPos.setValue(
										_gl,
										_vector3.setFromMatrixPosition(camera.matrixWorld)
									);
								}
							}

							if (
								material.isMeshPhongMaterial ||
								material.isMeshToonMaterial ||
								material.isMeshLambertMaterial ||
								material.isMeshBasicMaterial ||
								material.isMeshStandardMaterial ||
								material.isShaderMaterial
							) {
								p_uniforms.setValue(
									_gl,
									'isOrthographic',
									camera.isOrthographicCamera === true
								);
							}

							if (
								material.isMeshPhongMaterial ||
								material.isMeshToonMaterial ||
								material.isMeshLambertMaterial ||
								material.isMeshBasicMaterial ||
								material.isMeshStandardMaterial ||
								material.isShaderMaterial ||
								material.isShadowMaterial ||
								object.isSkinnedMesh
							) {
								p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
							}
						}

						// skinning and morph target uniforms must be set even if material didn't change
						// auto-setting of texture unit for bone and morph texture must go before other textures
						// otherwise textures used for skinning and morphing can take over texture units reserved for other material textures

						if (object.isSkinnedMesh) {
							p_uniforms.setOptional(_gl, object, 'bindMatrix');
							p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');

							const skeleton = object.skeleton;

							if (skeleton) {
								if (capabilities.floatVertexTextures) {
									if (skeleton.boneTexture === null) skeleton.computeBoneTexture();

									p_uniforms.setValue(
										_gl,
										'boneTexture',
										skeleton.boneTexture,
										textures
									);
									p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize);
								} else {
									p_uniforms.setOptional(_gl, skeleton, 'boneMatrices');
								}
							}
						}

						if (
							!!geometry &&
							(geometry.morphAttributes.position !== undefined ||
								geometry.morphAttributes.normal !== undefined)
						) {
							morphtargets.update(object, geometry, material, program);
						}

						if (
							refreshMaterial ||
							materialProperties.receiveShadow !== object.receiveShadow
						) {
							materialProperties.receiveShadow = object.receiveShadow;
							p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow);
						}

						if (refreshMaterial) {
							p_uniforms.setValue(
								_gl,
								'toneMappingExposure',
								_this.toneMappingExposure
							);

							if (materialProperties.needsLights) {
								// the current material requires lighting info

								// note: all lighting uniforms are always set correctly
								// they simply reference the renderer's state for their
								// values
								//
								// use the current material's .needsUpdate flags to set
								// the GL state when required

								markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
							}

							// refresh uniforms common to several materials

							if (fog && material.fog) {
								materials.refreshFogUniforms(m_uniforms, fog);
							}

							materials.refreshMaterialUniforms(
								m_uniforms,
								material,
								_pixelRatio,
								_height,
								_transmissionRenderTarget
							);

							_webgl_WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_29__["WebGLUniforms"].upload(
								_gl,
								materialProperties.uniformsList,
								m_uniforms,
								textures
							);
						}

						if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
							_webgl_WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_29__["WebGLUniforms"].upload(
								_gl,
								materialProperties.uniformsList,
								m_uniforms,
								textures
							);
							material.uniformsNeedUpdate = false;
						}

						if (material.isSpriteMaterial) {
							p_uniforms.setValue(_gl, 'center', object.center);
						}

						// common matrices

						p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
						p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
						p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);

						return program;
					}

					// If uniforms are marked as clean, they don't need to be loaded to the GPU.

					function markUniformsLightsNeedsUpdate(uniforms, value) {
						uniforms.ambientLightColor.needsUpdate = value;
						uniforms.lightProbe.needsUpdate = value;

						uniforms.directionalLights.needsUpdate = value;
						uniforms.directionalLightShadows.needsUpdate = value;
						uniforms.pointLights.needsUpdate = value;
						uniforms.pointLightShadows.needsUpdate = value;
						uniforms.spotLights.needsUpdate = value;
						uniforms.spotLightShadows.needsUpdate = value;
						uniforms.rectAreaLights.needsUpdate = value;
						uniforms.hemisphereLights.needsUpdate = value;
					}

					function materialNeedsLights(material) {
						return (
							material.isMeshLambertMaterial ||
							material.isMeshToonMaterial ||
							material.isMeshPhongMaterial ||
							material.isMeshStandardMaterial ||
							material.isShadowMaterial ||
							(material.isShaderMaterial && material.lights === true)
						);
					}

					this.getActiveCubeFace = function () {
						return _currentActiveCubeFace;
					};

					this.getActiveMipmapLevel = function () {
						return _currentActiveMipmapLevel;
					};

					this.getRenderTarget = function () {
						return _currentRenderTarget;
					};

					this.setRenderTarget = function (
						renderTarget,
						activeCubeFace = 0,
						activeMipmapLevel = 0
					) {
						_currentRenderTarget = renderTarget;
						_currentActiveCubeFace = activeCubeFace;
						_currentActiveMipmapLevel = activeMipmapLevel;

						if (
							renderTarget &&
							properties.get(renderTarget).__webglFramebuffer === undefined
						) {
							textures.setupRenderTarget(renderTarget);
						}

						let framebuffer = null;
						let isCube = false;
						let isRenderTarget3D = false;

						if (renderTarget) {
							const texture = renderTarget.texture;

							if (texture.isDataTexture3D || texture.isDataTexture2DArray) {
								isRenderTarget3D = true;
							}

							const __webglFramebuffer = properties.get(renderTarget)
								.__webglFramebuffer;

							if (renderTarget.isWebGLCubeRenderTarget) {
								framebuffer = __webglFramebuffer[activeCubeFace];
								isCube = true;
							} else if (renderTarget.isWebGLMultisampleRenderTarget) {
								framebuffer = properties.get(renderTarget)
									.__webglMultisampledFramebuffer;
							} else {
								framebuffer = __webglFramebuffer;
							}

							_currentViewport.copy(renderTarget.viewport);
							_currentScissor.copy(renderTarget.scissor);
							_currentScissorTest = renderTarget.scissorTest;
						} else {
							_currentViewport
								.copy(_viewport)
								.multiplyScalar(_pixelRatio)
								.floor();
							_currentScissor
								.copy(_scissor)
								.multiplyScalar(_pixelRatio)
								.floor();
							_currentScissorTest = _scissorTest;
						}

						const framebufferBound = state.bindFramebuffer(
							_gl.FRAMEBUFFER,
							framebuffer
						);

						if (framebufferBound && capabilities.drawBuffers) {
							let needsUpdate = false;

							if (renderTarget) {
								if (renderTarget.isWebGLMultipleRenderTargets) {
									const textures = renderTarget.texture;

									if (
										_currentDrawBuffers.length !== textures.length ||
										_currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0
									) {
										for (let i = 0, il = textures.length; i < il; i++) {
											_currentDrawBuffers[i] = _gl.COLOR_ATTACHMENT0 + i;
										}

										_currentDrawBuffers.length = textures.length;

										needsUpdate = true;
									}
								} else {
									if (
										_currentDrawBuffers.length !== 1 ||
										_currentDrawBuffers[0] !== _gl.COLOR_ATTACHMENT0
									) {
										_currentDrawBuffers[0] = _gl.COLOR_ATTACHMENT0;
										_currentDrawBuffers.length = 1;

										needsUpdate = true;
									}
								}
							} else {
								if (
									_currentDrawBuffers.length !== 1 ||
									_currentDrawBuffers[0] !== _gl.BACK
								) {
									_currentDrawBuffers[0] = _gl.BACK;
									_currentDrawBuffers.length = 1;

									needsUpdate = true;
								}
							}

							if (needsUpdate) {
								if (capabilities.isWebGL2) {
									_gl.drawBuffers(_currentDrawBuffers);
								} else {
									extensions
										.get('WEBGL_draw_buffers')
										.drawBuffersWEBGL(_currentDrawBuffers);
								}
							}
						}

						state.viewport(_currentViewport);
						state.scissor(_currentScissor);
						state.setScissorTest(_currentScissorTest);

						if (isCube) {
							const textureProperties = properties.get(renderTarget.texture);
							_gl.framebufferTexture2D(
								_gl.FRAMEBUFFER,
								_gl.COLOR_ATTACHMENT0,
								_gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace,
								textureProperties.__webglTexture,
								activeMipmapLevel
							);
						} else if (isRenderTarget3D) {
							const textureProperties = properties.get(renderTarget.texture);
							const layer = activeCubeFace || 0;
							_gl.framebufferTextureLayer(
								_gl.FRAMEBUFFER,
								_gl.COLOR_ATTACHMENT0,
								textureProperties.__webglTexture,
								activeMipmapLevel || 0,
								layer
							);
						}

						_currentMaterialId = -1; // reset current material to ensure correct uniform bindings
					};

					this.readRenderTargetPixels = function (
						renderTarget,
						x,
						y,
						width,
						height,
						buffer,
						activeCubeFaceIndex
					) {
						if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
							console.error(
								'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
							);
							return;
						}

						let framebuffer = properties.get(renderTarget).__webglFramebuffer;

						if (
							renderTarget.isWebGLCubeRenderTarget &&
							activeCubeFaceIndex !== undefined
						) {
							framebuffer = framebuffer[activeCubeFaceIndex];
						}

						if (framebuffer) {
							state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

							try {
								const texture = renderTarget.texture;
								const textureFormat = texture.format;
								const textureType = texture.type;

								if (
									textureFormat !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] &&
									utils.convert(textureFormat) !==
									_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)
								) {
									console.error(
										'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
									);
									return;
								}

								const halfFloatSupportedByExt =
									textureType === _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"] &&
									(extensions.has('EXT_color_buffer_half_float') ||
										(capabilities.isWebGL2 &&
											extensions.has('EXT_color_buffer_float')));

								if (
									textureType !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"] &&
									utils.convert(textureType) !==
									_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
									!(
										textureType === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] &&
										(capabilities.isWebGL2 ||
											extensions.has('OES_texture_float') ||
											extensions.has('WEBGL_color_buffer_float'))
									) && // Chrome Mac >= 52 and Firefox
									!halfFloatSupportedByExt
								) {
									console.error(
										'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
									);
									return;
								}

								if (
									_gl.checkFramebufferStatus(_gl.FRAMEBUFFER) ===
									_gl.FRAMEBUFFER_COMPLETE
								) {
									// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

									if (
										x >= 0 &&
										x <= renderTarget.width - width &&
										(y >= 0 && y <= renderTarget.height - height)
									) {
										_gl.readPixels(
											x,
											y,
											width,
											height,
											utils.convert(textureFormat),
											utils.convert(textureType),
											buffer
										);
									}
								} else {
									console.error(
										'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.'
									);
								}
							} finally {
								// restore framebuffer of current render target if necessary

								const framebuffer =
									_currentRenderTarget !== null
										? properties.get(_currentRenderTarget).__webglFramebuffer
										: null;
								state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
							}
						}
					};

					this.copyFramebufferToTexture = function (position, texture, level = 0) {
						const levelScale = Math.pow(2, -level);
						const width = Math.floor(texture.image.width * levelScale);
						const height = Math.floor(texture.image.height * levelScale);

						let glFormat = utils.convert(texture.format);

						if (capabilities.isWebGL2) {
							// Workaround for https://bugs.chromium.org/p/chromium/issues/detail?id=1120100
							// Not needed in Chrome 93+

							if (glFormat === _gl.RGB) glFormat = _gl.RGB8;
							if (glFormat === _gl.RGBA) glFormat = _gl.RGBA8;
						}

						textures.setTexture2D(texture, 0);

						_gl.copyTexImage2D(
							_gl.TEXTURE_2D,
							level,
							glFormat,
							position.x,
							position.y,
							width,
							height,
							0
						);

						state.unbindTexture();
					};

					this.copyTextureToTexture = function (
						position,
						srcTexture,
						dstTexture,
						level = 0
					) {
						const width = srcTexture.image.width;
						const height = srcTexture.image.height;
						const glFormat = utils.convert(dstTexture.format);
						const glType = utils.convert(dstTexture.type);

						textures.setTexture2D(dstTexture, 0);

						// As another texture upload may have changed pixelStorei
						// parameters, make sure they are correct for the dstTexture
						_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
						_gl.pixelStorei(
							_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
							dstTexture.premultiplyAlpha
						);
						_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

						if (srcTexture.isDataTexture) {
							_gl.texSubImage2D(
								_gl.TEXTURE_2D,
								level,
								position.x,
								position.y,
								width,
								height,
								glFormat,
								glType,
								srcTexture.image.data
							);
						} else {
							if (srcTexture.isCompressedTexture) {
								_gl.compressedTexSubImage2D(
									_gl.TEXTURE_2D,
									level,
									position.x,
									position.y,
									srcTexture.mipmaps[0].width,
									srcTexture.mipmaps[0].height,
									glFormat,
									srcTexture.mipmaps[0].data
								);
							} else {
								_gl.texSubImage2D(
									_gl.TEXTURE_2D,
									level,
									position.x,
									position.y,
									glFormat,
									glType,
									srcTexture.image
								);
							}
						}

						// Generate mipmaps only when copying level 0
						if (level === 0 && dstTexture.generateMipmaps)
							_gl.generateMipmap(_gl.TEXTURE_2D);

						state.unbindTexture();
					};

					this.copyTextureToTexture3D = function (
						sourceBox,
						position,
						srcTexture,
						dstTexture,
						level = 0
					) {
						if (_this.isWebGL1Renderer) {
							console.warn(
								'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.'
							);
							return;
						}

						const width = sourceBox.max.x - sourceBox.min.x + 1;
						const height = sourceBox.max.y - sourceBox.min.y + 1;
						const depth = sourceBox.max.z - sourceBox.min.z + 1;
						const glFormat = utils.convert(dstTexture.format);
						const glType = utils.convert(dstTexture.type);
						let glTarget;

						if (dstTexture.isDataTexture3D) {
							textures.setTexture3D(dstTexture, 0);
							glTarget = _gl.TEXTURE_3D;
						} else if (dstTexture.isDataTexture2DArray) {
							textures.setTexture2DArray(dstTexture, 0);
							glTarget = _gl.TEXTURE_2D_ARRAY;
						} else {
							console.warn(
								'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.'
							);
							return;
						}

						_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
						_gl.pixelStorei(
							_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
							dstTexture.premultiplyAlpha
						);
						_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);

						const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
						const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
						const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
						const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
						const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);

						const image = srcTexture.isCompressedTexture
							? srcTexture.mipmaps[0]
							: srcTexture.image;

						_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
						_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
						_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
						_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
						_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);

						if (srcTexture.isDataTexture || srcTexture.isDataTexture3D) {
							_gl.texSubImage3D(
								glTarget,
								level,
								position.x,
								position.y,
								position.z,
								width,
								height,
								depth,
								glFormat,
								glType,
								image.data
							);
						} else {
							if (srcTexture.isCompressedTexture) {
								console.warn(
									'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.'
								);
								_gl.compressedTexSubImage3D(
									glTarget,
									level,
									position.x,
									position.y,
									position.z,
									width,
									height,
									depth,
									glFormat,
									image.data
								);
							} else {
								_gl.texSubImage3D(
									glTarget,
									level,
									position.x,
									position.y,
									position.z,
									width,
									height,
									depth,
									glFormat,
									glType,
									image
								);
							}
						}

						_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
						_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
						_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
						_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
						_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);

						// Generate mipmaps only when copying level 0
						if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);

						state.unbindTexture();
					};

					this.initTexture = function (texture) {
						textures.setTexture2D(texture, 0);

						state.unbindTexture();
					};

					this.resetState = function () {
						_currentActiveCubeFace = 0;
						_currentActiveMipmapLevel = 0;
						_currentRenderTarget = null;

						state.reset();
						bindingStates.reset();
					};

					if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
						__THREE_DEVTOOLS__.dispatchEvent(
							new CustomEvent('observe', { detail: this })
						); // eslint-disable-line no-undef
					}
				}

				WebGLRenderer.prototype.isWebGLRenderer = true;




				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk.js":
/*!*****************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk.js ***!
  \*****************************************************/
/*! exports provided: ShaderChunk */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function () { return ShaderChunk; });
/* harmony import */ var _ShaderChunk_alphamap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderChunk/alphamap_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/alphamap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_alphamap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ShaderChunk/alphamap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_alphatest_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShaderChunk/alphatest_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/alphatest_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_alphatest_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ShaderChunk/alphatest_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/alphatest_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_aomap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShaderChunk/aomap_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/aomap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_aomap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShaderChunk/aomap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_begin_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ShaderChunk/begin_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/begin_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_beginnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ShaderChunk/beginnormal_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_bsdfs_glsl_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ShaderChunk/bsdfs.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/bsdfs.glsl.js");
/* harmony import */ var _ShaderChunk_bumpmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ShaderChunk/bumpmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_clipping_planes_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ShaderChunk/clipping_planes_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_clipping_planes_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ShaderChunk/clipping_planes_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_clipping_planes_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ShaderChunk/clipping_planes_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_clipping_planes_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ShaderChunk/clipping_planes_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_color_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ShaderChunk/color_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/color_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_color_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./ShaderChunk/color_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/color_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_color_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./ShaderChunk/color_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/color_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_color_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./ShaderChunk/color_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/color_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_common_glsl_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./ShaderChunk/common.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/common.glsl.js");
/* harmony import */ var _ShaderChunk_cube_uv_reflection_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./ShaderChunk/cube_uv_reflection_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_defaultnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./ShaderChunk/defaultnormal_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_displacementmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./ShaderChunk/displacementmap_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_displacementmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./ShaderChunk/displacementmap_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_emissivemap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./ShaderChunk/emissivemap_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_emissivemap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./ShaderChunk/emissivemap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_encodings_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./ShaderChunk/encodings_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/encodings_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_encodings_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./ShaderChunk/encodings_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./ShaderChunk/envmap_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/envmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_common_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./ShaderChunk/envmap_common_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/envmap_common_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./ShaderChunk/envmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./ShaderChunk/envmap_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./ShaderChunk/envmap_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/envmap_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_fog_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./ShaderChunk/fog_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/fog_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_fog_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./ShaderChunk/fog_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/fog_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_fog_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./ShaderChunk/fog_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/fog_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_fog_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./ShaderChunk/fog_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_gradientmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./ShaderChunk/gradientmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/gradientmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lightmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./ShaderChunk/lightmap_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lightmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lightmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./ShaderChunk/lightmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_lambert_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./ShaderChunk/lights_lambert_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_lights_pars_begin_glsl_js__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./ShaderChunk/lights_pars_begin.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_pars_begin.glsl.js");
/* harmony import */ var _ShaderChunk_envmap_physical_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./ShaderChunk/envmap_physical_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/envmap_physical_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_toon_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./ShaderChunk/lights_toon_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_toon_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_toon_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./ShaderChunk/lights_toon_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_toon_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_phong_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./ShaderChunk/lights_phong_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_phong_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./ShaderChunk/lights_phong_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_physical_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./ShaderChunk/lights_physical_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_physical_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./ShaderChunk/lights_physical_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_lights_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./ShaderChunk/lights_fragment_begin.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_fragment_begin.glsl.js");
/* harmony import */ var _ShaderChunk_lights_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./ShaderChunk/lights_fragment_maps.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_fragment_maps.glsl.js");
/* harmony import */ var _ShaderChunk_lights_fragment_end_glsl_js__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./ShaderChunk/lights_fragment_end.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/lights_fragment_end.glsl.js");
/* harmony import */ var _ShaderChunk_logdepthbuf_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./ShaderChunk/logdepthbuf_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_logdepthbuf_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./ShaderChunk/logdepthbuf_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_logdepthbuf_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./ShaderChunk/logdepthbuf_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_logdepthbuf_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./ShaderChunk/logdepthbuf_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_map_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./ShaderChunk/map_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/map_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_map_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./ShaderChunk/map_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/map_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_map_particle_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./ShaderChunk/map_particle_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/map_particle_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_map_particle_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./ShaderChunk/map_particle_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_metalnessmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./ShaderChunk/metalnessmap_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_metalnessmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./ShaderChunk/metalnessmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_morphnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./ShaderChunk/morphnormal_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_morphtarget_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./ShaderChunk/morphtarget_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_morphtarget_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./ShaderChunk/morphtarget_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_normal_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./ShaderChunk/normal_fragment_begin.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/normal_fragment_begin.glsl.js");
/* harmony import */ var _ShaderChunk_normal_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./ShaderChunk/normal_fragment_maps.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/normal_fragment_maps.glsl.js");
/* harmony import */ var _ShaderChunk_normal_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./ShaderChunk/normal_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/normal_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_normal_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./ShaderChunk/normal_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/normal_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_normal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./ShaderChunk/normal_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/normal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_normalmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./ShaderChunk/normalmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_clearcoat_normal_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./ShaderChunk/clearcoat_normal_fragment_begin.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_begin.glsl.js");
/* harmony import */ var _ShaderChunk_clearcoat_normal_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./ShaderChunk/clearcoat_normal_fragment_maps.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_maps.glsl.js");
/* harmony import */ var _ShaderChunk_clearcoat_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./ShaderChunk/clearcoat_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/clearcoat_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_output_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./ShaderChunk/output_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/output_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_packing_glsl_js__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./ShaderChunk/packing.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/packing.glsl.js");
/* harmony import */ var _ShaderChunk_premultiplied_alpha_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./ShaderChunk/premultiplied_alpha_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_project_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./ShaderChunk/project_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/project_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_dithering_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./ShaderChunk/dithering_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/dithering_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_dithering_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./ShaderChunk/dithering_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/dithering_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_roughnessmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./ShaderChunk/roughnessmap_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_roughnessmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./ShaderChunk/roughnessmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_shadowmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./ShaderChunk/shadowmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_shadowmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./ShaderChunk/shadowmap_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_shadowmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./ShaderChunk/shadowmap_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_shadowmask_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./ShaderChunk/shadowmask_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_skinbase_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./ShaderChunk/skinbase_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/skinbase_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_skinning_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./ShaderChunk/skinning_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_skinning_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./ShaderChunk/skinning_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/skinning_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_skinnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./ShaderChunk/skinnormal_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_specularmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./ShaderChunk/specularmap_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/specularmap_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_specularmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./ShaderChunk/specularmap_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_tonemapping_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./ShaderChunk/tonemapping_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_tonemapping_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./ShaderChunk/tonemapping_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_transmission_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./ShaderChunk/transmission_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/transmission_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_transmission_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./ShaderChunk/transmission_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/transmission_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_uv_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./ShaderChunk/uv_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_uv_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./ShaderChunk/uv_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_uv_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./ShaderChunk/uv_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/uv_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_uv2_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./ShaderChunk/uv2_pars_fragment.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl.js");
/* harmony import */ var _ShaderChunk_uv2_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./ShaderChunk/uv2_pars_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_uv2_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./ShaderChunk/uv2_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/uv2_vertex.glsl.js");
/* harmony import */ var _ShaderChunk_worldpos_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./ShaderChunk/worldpos_vertex.glsl.js */ "./libs/three/renderers/shaders/ShaderChunk/worldpos_vertex.glsl.js");
/* harmony import */ var _ShaderLib_background_glsl_js__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./ShaderLib/background.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/background.glsl.js");
/* harmony import */ var _ShaderLib_cube_glsl_js__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./ShaderLib/cube.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/cube.glsl.js");
/* harmony import */ var _ShaderLib_depth_glsl_js__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./ShaderLib/depth.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/depth.glsl.js");
/* harmony import */ var _ShaderLib_distanceRGBA_glsl_js__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./ShaderLib/distanceRGBA.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/distanceRGBA.glsl.js");
/* harmony import */ var _ShaderLib_equirect_glsl_js__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./ShaderLib/equirect.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/equirect.glsl.js");
/* harmony import */ var _ShaderLib_linedashed_glsl_js__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./ShaderLib/linedashed.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/linedashed.glsl.js");
/* harmony import */ var _ShaderLib_meshbasic_glsl_js__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./ShaderLib/meshbasic.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/meshbasic.glsl.js");
/* harmony import */ var _ShaderLib_meshlambert_glsl_js__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./ShaderLib/meshlambert.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/meshlambert.glsl.js");
/* harmony import */ var _ShaderLib_meshmatcap_glsl_js__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./ShaderLib/meshmatcap.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/meshmatcap.glsl.js");
/* harmony import */ var _ShaderLib_meshnormal_glsl_js__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./ShaderLib/meshnormal.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/meshnormal.glsl.js");
/* harmony import */ var _ShaderLib_meshphong_glsl_js__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./ShaderLib/meshphong.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/meshphong.glsl.js");
/* harmony import */ var _ShaderLib_meshphysical_glsl_js__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./ShaderLib/meshphysical.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/meshphysical.glsl.js");
/* harmony import */ var _ShaderLib_meshtoon_glsl_js__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./ShaderLib/meshtoon.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/meshtoon.glsl.js");
/* harmony import */ var _ShaderLib_points_glsl_js__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./ShaderLib/points.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/points.glsl.js");
/* harmony import */ var _ShaderLib_shadow_glsl_js__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./ShaderLib/shadow.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/shadow.glsl.js");
/* harmony import */ var _ShaderLib_sprite_glsl_js__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./ShaderLib/sprite.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/sprite.glsl.js");
























































































































				const ShaderChunk = {
					alphamap_fragment: _ShaderChunk_alphamap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_0__["default"],
					alphamap_pars_fragment: _ShaderChunk_alphamap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_1__["default"],
					alphatest_fragment: _ShaderChunk_alphatest_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_2__["default"],
					alphatest_pars_fragment: _ShaderChunk_alphatest_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_3__["default"],
					aomap_fragment: _ShaderChunk_aomap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_4__["default"],
					aomap_pars_fragment: _ShaderChunk_aomap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_5__["default"],
					begin_vertex: _ShaderChunk_begin_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_6__["default"],
					beginnormal_vertex: _ShaderChunk_beginnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_7__["default"],
					bsdfs: _ShaderChunk_bsdfs_glsl_js__WEBPACK_IMPORTED_MODULE_8__["default"],
					bumpmap_pars_fragment: _ShaderChunk_bumpmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_9__["default"],
					clipping_planes_fragment: _ShaderChunk_clipping_planes_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_10__["default"],
					clipping_planes_pars_fragment: _ShaderChunk_clipping_planes_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_11__["default"],
					clipping_planes_pars_vertex: _ShaderChunk_clipping_planes_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_12__["default"],
					clipping_planes_vertex: _ShaderChunk_clipping_planes_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_13__["default"],
					color_fragment: _ShaderChunk_color_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_14__["default"],
					color_pars_fragment: _ShaderChunk_color_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_15__["default"],
					color_pars_vertex: _ShaderChunk_color_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_16__["default"],
					color_vertex: _ShaderChunk_color_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_17__["default"],
					common: _ShaderChunk_common_glsl_js__WEBPACK_IMPORTED_MODULE_18__["default"],
					cube_uv_reflection_fragment: _ShaderChunk_cube_uv_reflection_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_19__["default"],
					defaultnormal_vertex: _ShaderChunk_defaultnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_20__["default"],
					displacementmap_pars_vertex: _ShaderChunk_displacementmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_21__["default"],
					displacementmap_vertex: _ShaderChunk_displacementmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_22__["default"],
					emissivemap_fragment: _ShaderChunk_emissivemap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_23__["default"],
					emissivemap_pars_fragment: _ShaderChunk_emissivemap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_24__["default"],
					encodings_fragment: _ShaderChunk_encodings_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_25__["default"],
					encodings_pars_fragment: _ShaderChunk_encodings_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_26__["default"],
					envmap_fragment: _ShaderChunk_envmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_27__["default"],
					envmap_common_pars_fragment: _ShaderChunk_envmap_common_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_28__["default"],
					envmap_pars_fragment: _ShaderChunk_envmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_29__["default"],
					envmap_pars_vertex: _ShaderChunk_envmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_30__["default"],
					envmap_physical_pars_fragment: _ShaderChunk_envmap_physical_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_41__["default"],
					envmap_vertex: _ShaderChunk_envmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_31__["default"],
					fog_vertex: _ShaderChunk_fog_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_32__["default"],
					fog_pars_vertex: _ShaderChunk_fog_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_33__["default"],
					fog_fragment: _ShaderChunk_fog_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_34__["default"],
					fog_pars_fragment: _ShaderChunk_fog_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_35__["default"],
					gradientmap_pars_fragment: _ShaderChunk_gradientmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_36__["default"],
					lightmap_fragment: _ShaderChunk_lightmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_37__["default"],
					lightmap_pars_fragment: _ShaderChunk_lightmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_38__["default"],
					lights_lambert_vertex: _ShaderChunk_lights_lambert_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_39__["default"],
					lights_pars_begin: _ShaderChunk_lights_pars_begin_glsl_js__WEBPACK_IMPORTED_MODULE_40__["default"],
					lights_toon_fragment: _ShaderChunk_lights_toon_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_42__["default"],
					lights_toon_pars_fragment: _ShaderChunk_lights_toon_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_43__["default"],
					lights_phong_fragment: _ShaderChunk_lights_phong_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_44__["default"],
					lights_phong_pars_fragment: _ShaderChunk_lights_phong_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_45__["default"],
					lights_physical_fragment: _ShaderChunk_lights_physical_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_46__["default"],
					lights_physical_pars_fragment: _ShaderChunk_lights_physical_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_47__["default"],
					lights_fragment_begin: _ShaderChunk_lights_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_48__["default"],
					lights_fragment_maps: _ShaderChunk_lights_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_49__["default"],
					lights_fragment_end: _ShaderChunk_lights_fragment_end_glsl_js__WEBPACK_IMPORTED_MODULE_50__["default"],
					logdepthbuf_fragment: _ShaderChunk_logdepthbuf_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_51__["default"],
					logdepthbuf_pars_fragment: _ShaderChunk_logdepthbuf_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_52__["default"],
					logdepthbuf_pars_vertex: _ShaderChunk_logdepthbuf_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_53__["default"],
					logdepthbuf_vertex: _ShaderChunk_logdepthbuf_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_54__["default"],
					map_fragment: _ShaderChunk_map_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_55__["default"],
					map_pars_fragment: _ShaderChunk_map_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_56__["default"],
					map_particle_fragment: _ShaderChunk_map_particle_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_57__["default"],
					map_particle_pars_fragment: _ShaderChunk_map_particle_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_58__["default"],
					metalnessmap_fragment: _ShaderChunk_metalnessmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_59__["default"],
					metalnessmap_pars_fragment: _ShaderChunk_metalnessmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_60__["default"],
					morphnormal_vertex: _ShaderChunk_morphnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_61__["default"],
					morphtarget_pars_vertex: _ShaderChunk_morphtarget_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_62__["default"],
					morphtarget_vertex: _ShaderChunk_morphtarget_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_63__["default"],
					normal_fragment_begin: _ShaderChunk_normal_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_64__["default"],
					normal_fragment_maps: _ShaderChunk_normal_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_65__["default"],
					normal_pars_fragment: _ShaderChunk_normal_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_66__["default"],
					normal_pars_vertex: _ShaderChunk_normal_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_67__["default"],
					normal_vertex: _ShaderChunk_normal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_68__["default"],
					normalmap_pars_fragment: _ShaderChunk_normalmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_69__["default"],
					clearcoat_normal_fragment_begin: _ShaderChunk_clearcoat_normal_fragment_begin_glsl_js__WEBPACK_IMPORTED_MODULE_70__["default"],
					clearcoat_normal_fragment_maps: _ShaderChunk_clearcoat_normal_fragment_maps_glsl_js__WEBPACK_IMPORTED_MODULE_71__["default"],
					clearcoat_pars_fragment: _ShaderChunk_clearcoat_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_72__["default"],
					output_fragment: _ShaderChunk_output_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_73__["default"],
					packing: _ShaderChunk_packing_glsl_js__WEBPACK_IMPORTED_MODULE_74__["default"],
					premultiplied_alpha_fragment: _ShaderChunk_premultiplied_alpha_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_75__["default"],
					project_vertex: _ShaderChunk_project_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_76__["default"],
					dithering_fragment: _ShaderChunk_dithering_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_77__["default"],
					dithering_pars_fragment: _ShaderChunk_dithering_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_78__["default"],
					roughnessmap_fragment: _ShaderChunk_roughnessmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_79__["default"],
					roughnessmap_pars_fragment: _ShaderChunk_roughnessmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_80__["default"],
					shadowmap_pars_fragment: _ShaderChunk_shadowmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_81__["default"],
					shadowmap_pars_vertex: _ShaderChunk_shadowmap_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_82__["default"],
					shadowmap_vertex: _ShaderChunk_shadowmap_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_83__["default"],
					shadowmask_pars_fragment: _ShaderChunk_shadowmask_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_84__["default"],
					skinbase_vertex: _ShaderChunk_skinbase_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_85__["default"],
					skinning_pars_vertex: _ShaderChunk_skinning_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_86__["default"],
					skinning_vertex: _ShaderChunk_skinning_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_87__["default"],
					skinnormal_vertex: _ShaderChunk_skinnormal_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_88__["default"],
					specularmap_fragment: _ShaderChunk_specularmap_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_89__["default"],
					specularmap_pars_fragment: _ShaderChunk_specularmap_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_90__["default"],
					tonemapping_fragment: _ShaderChunk_tonemapping_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_91__["default"],
					tonemapping_pars_fragment: _ShaderChunk_tonemapping_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_92__["default"],
					transmission_fragment: _ShaderChunk_transmission_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_93__["default"],
					transmission_pars_fragment: _ShaderChunk_transmission_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_94__["default"],
					uv_pars_fragment: _ShaderChunk_uv_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_95__["default"],
					uv_pars_vertex: _ShaderChunk_uv_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_96__["default"],
					uv_vertex: _ShaderChunk_uv_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_97__["default"],
					uv2_pars_fragment: _ShaderChunk_uv2_pars_fragment_glsl_js__WEBPACK_IMPORTED_MODULE_98__["default"],
					uv2_pars_vertex: _ShaderChunk_uv2_pars_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_99__["default"],
					uv2_vertex: _ShaderChunk_uv2_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_100__["default"],
					worldpos_vertex: _ShaderChunk_worldpos_vertex_glsl_js__WEBPACK_IMPORTED_MODULE_101__["default"],

					background_vert: _ShaderLib_background_glsl_js__WEBPACK_IMPORTED_MODULE_102__["vertex"],
					background_frag: _ShaderLib_background_glsl_js__WEBPACK_IMPORTED_MODULE_102__["fragment"],
					cube_vert: _ShaderLib_cube_glsl_js__WEBPACK_IMPORTED_MODULE_103__["vertex"],
					cube_frag: _ShaderLib_cube_glsl_js__WEBPACK_IMPORTED_MODULE_103__["fragment"],
					depth_vert: _ShaderLib_depth_glsl_js__WEBPACK_IMPORTED_MODULE_104__["vertex"],
					depth_frag: _ShaderLib_depth_glsl_js__WEBPACK_IMPORTED_MODULE_104__["fragment"],
					distanceRGBA_vert: _ShaderLib_distanceRGBA_glsl_js__WEBPACK_IMPORTED_MODULE_105__["vertex"],
					distanceRGBA_frag: _ShaderLib_distanceRGBA_glsl_js__WEBPACK_IMPORTED_MODULE_105__["fragment"],
					equirect_vert: _ShaderLib_equirect_glsl_js__WEBPACK_IMPORTED_MODULE_106__["vertex"],
					equirect_frag: _ShaderLib_equirect_glsl_js__WEBPACK_IMPORTED_MODULE_106__["fragment"],
					linedashed_vert: _ShaderLib_linedashed_glsl_js__WEBPACK_IMPORTED_MODULE_107__["vertex"],
					linedashed_frag: _ShaderLib_linedashed_glsl_js__WEBPACK_IMPORTED_MODULE_107__["fragment"],
					meshbasic_vert: _ShaderLib_meshbasic_glsl_js__WEBPACK_IMPORTED_MODULE_108__["vertex"],
					meshbasic_frag: _ShaderLib_meshbasic_glsl_js__WEBPACK_IMPORTED_MODULE_108__["fragment"],
					meshlambert_vert: _ShaderLib_meshlambert_glsl_js__WEBPACK_IMPORTED_MODULE_109__["vertex"],
					meshlambert_frag: _ShaderLib_meshlambert_glsl_js__WEBPACK_IMPORTED_MODULE_109__["fragment"],
					meshmatcap_vert: _ShaderLib_meshmatcap_glsl_js__WEBPACK_IMPORTED_MODULE_110__["vertex"],
					meshmatcap_frag: _ShaderLib_meshmatcap_glsl_js__WEBPACK_IMPORTED_MODULE_110__["fragment"],
					meshnormal_vert: _ShaderLib_meshnormal_glsl_js__WEBPACK_IMPORTED_MODULE_111__["vertex"],
					meshnormal_frag: _ShaderLib_meshnormal_glsl_js__WEBPACK_IMPORTED_MODULE_111__["fragment"],
					meshphong_vert: _ShaderLib_meshphong_glsl_js__WEBPACK_IMPORTED_MODULE_112__["vertex"],
					meshphong_frag: _ShaderLib_meshphong_glsl_js__WEBPACK_IMPORTED_MODULE_112__["fragment"],
					meshphysical_vert: _ShaderLib_meshphysical_glsl_js__WEBPACK_IMPORTED_MODULE_113__["vertex"],
					meshphysical_frag: _ShaderLib_meshphysical_glsl_js__WEBPACK_IMPORTED_MODULE_113__["fragment"],
					meshtoon_vert: _ShaderLib_meshtoon_glsl_js__WEBPACK_IMPORTED_MODULE_114__["vertex"],
					meshtoon_frag: _ShaderLib_meshtoon_glsl_js__WEBPACK_IMPORTED_MODULE_114__["fragment"],
					points_vert: _ShaderLib_points_glsl_js__WEBPACK_IMPORTED_MODULE_115__["vertex"],
					points_frag: _ShaderLib_points_glsl_js__WEBPACK_IMPORTED_MODULE_115__["fragment"],
					shadow_vert: _ShaderLib_shadow_glsl_js__WEBPACK_IMPORTED_MODULE_116__["vertex"],
					shadow_frag: _ShaderLib_shadow_glsl_js__WEBPACK_IMPORTED_MODULE_116__["fragment"],
					sprite_vert: _ShaderLib_sprite_glsl_js__WEBPACK_IMPORTED_MODULE_117__["vertex"],
					sprite_frag: _ShaderLib_sprite_glsl_js__WEBPACK_IMPORTED_MODULE_117__["fragment"]
				};


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/alphamap_fragment.glsl.js":
/*!****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/alphamap_fragment.glsl.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl.js":
/*!*********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/alphatest_fragment.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/alphatest_fragment.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ALPHATEST

	if ( diffuseColor.a < alphaTest ) discard;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/alphatest_pars_fragment.glsl.js":
/*!**********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/alphatest_pars_fragment.glsl.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/aomap_fragment.glsl.js":
/*!*************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/aomap_fragment.glsl.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl.js":
/*!******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/begin_vertex.glsl.js":
/*!***********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/begin_vertex.glsl.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 transformed = vec3( position );
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/bsdfs.glsl.js":
/*!****************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/bsdfs.glsl.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disney’s reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( f0, f90, dotVH );

	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( V * D );

}

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light


float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( specularColor, 1.0, dotVH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float D_Charlie( float roughness, float dotNH ) {

	float alpha = pow2( roughness );

	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );

}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float V_Neubelt( float dotNV, float dotNL ) {

	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );

}

vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );

	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );

	return sheenColor * ( D * V );

}

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_begin.glsl.js":
/*!******************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_begin.glsl.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_maps.glsl.js":
/*!*****************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/clearcoat_normal_fragment_maps.glsl.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/clearcoat_pars_fragment.glsl.js":
/*!**********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/clearcoat_pars_fragment.glsl.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl.js":
/*!***********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl.js":
/*!****************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl.js":
/*!**************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl.js":
/*!*********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/color_fragment.glsl.js":
/*!*************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/color_fragment.glsl.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/color_pars_fragment.glsl.js":
/*!******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/color_pars_fragment.glsl.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/color_pars_vertex.glsl.js":
/*!****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/color_pars_vertex.glsl.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	varying vec3 vColor;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/color_vertex.glsl.js":
/*!***********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/color_vertex.glsl.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/common.glsl.js":
/*!*****************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/common.glsl.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }

// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {

	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );

	return fract( sin( sn ) * c );

}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl.js":
/*!**************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );

		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );

		vec2 f = fract( uv );

		uv += 0.5 - f;

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		if ( mipInt < cubeUV_maxMipLevel ) {

			uv.y += 2.0 * cubeUV_maxTileSize;

		}

		uv.y += filterInt * 2.0 * cubeUV_minTileSize;

		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );

		uv *= texelSize;

		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x += texelSize;

		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.y += texelSize;

		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x -= texelSize;

		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		vec3 tm = mix( tl, tr, f.x );

		vec3 bm = mix( bl, br, f.x );

		return mix( tm, bm, f.y );

	}

	// These defines must match with PMREMGenerator

	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= r1 ) {

			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;

		} else if ( roughness >= r4 ) {

			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;

		} else if ( roughness >= r5 ) {

			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;

		} else if ( roughness >= r6 ) {

			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/default_fragment.glsl.js":
/*!***************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/default_fragment.glsl.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/default_vertex.glsl.js":
/*!*************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/default_vertex.glsl.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl.js":
/*!**************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl.js":
/*!*********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/dithering_fragment.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/dithering_fragment.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/dithering_pars_fragment.glsl.js":
/*!**********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/dithering_pars_fragment.glsl.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl.js":
/*!************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/encodings_fragment.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/encodings_fragment.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
gl_FragColor = linearToOutputTexel( gl_FragColor );
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl.js":
/*!**********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
	// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	// NOTE: The implementation with min causes the shader to not compile on
	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests 
	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.
	// D = min( floor( D ) / 255.0, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/envmap_common_pars_fragment.glsl.js":
/*!**************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/envmap_common_pars_fragment.glsl.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/envmap_fragment.glsl.js":
/*!**************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/envmap_fragment.glsl.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

		envColor = envMapTexelToLinear( envColor );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/envmap_physical_pars_fragment.glsl.js":
/*!****************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/envmap_physical_pars_fragment.glsl.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_ENVMAP )

	#ifdef ENVMAP_MODE_REFRACTION

		uniform float refractionRatio;

	#endif

	vec3 getIBLIrradiance( const in vec3 normal ) {

		#if defined( ENVMAP_TYPE_CUBE_UV )

			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

			return PI * envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {

		#if defined( ENVMAP_TYPE_CUBE_UV )

			vec3 reflectVec;

			#ifdef ENVMAP_MODE_REFLECTION

				reflectVec = reflect( - viewDir, normal );

				// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

			#else

				reflectVec = refract( - viewDir, normal, refractionRatio );

			#endif

			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

			return envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/envmap_vertex.glsl.js":
/*!************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/envmap_vertex.glsl.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/fog_fragment.glsl.js":
/*!***********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/fog_fragment.glsl.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl.js":
/*!****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float vFogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/fog_pars_vertex.glsl.js":
/*!**************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/fog_pars_vertex.glsl.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_FOG

	varying float vFogDepth;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/fog_vertex.glsl.js":
/*!*********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/fog_vertex.glsl.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_FOG

	vFogDepth = - mvPosition.z;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/gradientmap_pars_fragment.glsl.js":
/*!************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/gradientmap_pars_fragment.glsl.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return texture2D( gradientMap, coord ).rgb;

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lightmap_fragment.glsl.js":
/*!****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lightmap_fragment.glsl.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		lightMapIrradiance *= PI;

	#endif

	reflectedLight.indirectDiffuse += lightMapIrradiance;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl.js":
/*!*********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_fragment_begin.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_fragment_begin.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef USE_CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_fragment_end.glsl.js":
/*!******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_fragment_end.glsl.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_fragment_maps.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_fragment_maps.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI;

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getIBLIrradiance( geometry.normal );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );

	#ifdef USE_CLEARCOAT

		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

vIndirectFront += getAmbientLightIrradiance( ambientLightColor );

vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );

#ifdef DOUBLE_SIDED

	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );

	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );

#endif

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointLightInfo( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotLightInfo( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;

		#endif
	}
	#pragma unroll_loop_end

#endif

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );

		#endif

	}
	#pragma unroll_loop_end

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_pars_begin.glsl.js":
/*!****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_pars_begin.glsl.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {

	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	return irradiance;

}

float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

	#if defined ( PHYSICALLY_CORRECT_LIGHTS )

		// based upon Frostbite 3 Moving to Physically-based Rendering
		// page 32, equation 26: E[window1]
		// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

		if ( cutoffDistance > 0.0 ) {

			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

		}

		return distanceFalloff;

	#else

		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );

		}

		return 1.0;

	#endif

}

float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {

	return smoothstep( coneCosine, penumbraCosine, angleCosine );

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {

		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {

		vec3 lVector = pointLight.position - geometry.position;

		light.direction = normalize( lVector );

		float lightDistance = length( lVector );

		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {

		vec3 lVector = spotLight.position - geometry.position;

		light.direction = normalize( lVector );

		float angleCos = dot( light.direction, spotLight.direction );

		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );

		if ( spotAttenuation > 0.0 ) {

			float lightDistance = length( lVector );

			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );

		} else {

			light.color = vec3( 0.0 );
			light.visible = false;

		}

	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {

		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		return irradiance;

	}

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl.js":
/*!*************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
varying vec3 vViewPosition;

struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl.js":
/*!***********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );

#ifdef IOR

	#ifdef SPECULAR

		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;

		#ifdef USE_SPECULARINTENSITYMAP

			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;

		#endif

		#ifdef USE_SPECULARCOLORMAP

			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;

		#endif

		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );

	#else

		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;

	#endif

	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;

#endif

#ifdef USE_CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheenColor;

	#ifdef USE_SHEENCOLORMAP

		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;

	#endif

	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );

	#ifdef USE_SHEENROUGHNESSMAP

		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl.js":
/*!****************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
struct PhysicalMaterial {

	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;

	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif

	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif

};

// temporary
vec3 clearcoatSpecular = vec3( 0.0 );

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;

	return fab;

}

vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	return specularColor * fab.x + specularF90 * fab.y;

}

// Fdez-Agüera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;

	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifdef USE_CLEARCOAT

		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = dotNLcc * directLight.color;

		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

	#endif

	#ifdef USE_SHEEN

		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );

	#endif

	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );


	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef USE_CLEARCOAT

		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

	#endif

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_toon_fragment.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_toon_fragment.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/lights_toon_pars_fragment.glsl.js":
/*!************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/lights_toon_pars_fragment.glsl.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
varying vec3 vViewPosition;

struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl.js":
/*!************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl.js":
/*!**********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/map_fragment.glsl.js":
/*!***********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/map_fragment.glsl.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/map_pars_fragment.glsl.js":
/*!****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/map_pars_fragment.glsl.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/map_particle_fragment.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/map_particle_fragment.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl.js":
/*!*************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl.js":
/*!*************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];

		}

	#else

		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl.js":
/*!**********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;

		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {

			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;

			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;

		}

	#else

		#ifndef USE_MORPHNORMALS

			uniform float morphTargetInfluences[ 8 ];

		#else

			uniform float morphTargetInfluences[ 4 ];

		#endif

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;

	#ifdef MORPHTARGETS_TEXTURE

		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

			#ifndef USE_MORPHNORMALS

				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];

			#else

				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];

			#endif

		}

	#else

		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];

		#ifndef USE_MORPHNORMALS

			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];

		#endif

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/normal_fragment_begin.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/normal_fragment_begin.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/normal_fragment_maps.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/normal_fragment_maps.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/normal_pars_fragment.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/normal_pars_fragment.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/normal_pars_vertex.glsl.js":
/*!*****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/normal_pars_vertex.glsl.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/normal_vertex.glsl.js":
/*!************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/normal_vertex.glsl.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl.js":
/*!**********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

	}

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/output_fragment.glsl.js":
/*!**************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/output_fragment.glsl.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif

// https://github.com/mrdoob/three.js/pull/22425
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif

gl_FragColor = vec4( outgoingLight, diffuseColor.a );
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/packing.glsl.js":
/*!******************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/packing.glsl.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}

vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl.js":
/*!***************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/project_vertex.glsl.js":
/*!*************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/project_vertex.glsl.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl.js":
/*!*************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js":
/*!**********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl.js":
/*!***************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0

		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;

	#endif

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl.js":
/*!***********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/skinbase_vertex.glsl.js":
/*!**************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/skinbase_vertex.glsl.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/skinning_vertex.glsl.js":
/*!**************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/skinning_vertex.glsl.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl.js":
/*!****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/specularmap_fragment.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/specularmap_fragment.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl.js":
/*!************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl.js":
/*!*******************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl.js":
/*!************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifndef saturate
// <common> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/transmission_fragment.glsl.js":
/*!********************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/transmission_fragment.glsl.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_TRANSMISSION

	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;

	#ifdef USE_TRANSMISSIONMAP

		transmissionFactor *= texture2D( transmissionMap, vUv ).r;

	#endif

	#ifdef USE_THICKNESSMAP

		thicknessFactor *= texture2D( thicknessMap, vUv ).g;

	#endif

	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );

	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );

	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/transmission_pars_fragment.glsl.js":
/*!*************************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/transmission_pars_fragment.glsl.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_TRANSMISSION

	// Transmission code is based on glTF-Sampler-Viewer
	// https://github.com/KhronosGroup/glTF-Sample-Viewer

	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;

	#ifdef USE_TRANSMISSIONMAP

		uniform sampler2D transmissionMap;

	#endif

	#ifdef USE_THICKNESSMAP

		uniform sampler2D thicknessMap;

	#endif

	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;

	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;

	varying vec3 vWorldPosition;

	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {

		// Direction of refracted light.
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );

		// Compute rotation-independant scaling of the model matrix.
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		// The thickness is specified in local space.
		return normalize( refractionVector ) * thickness * modelScale;

	}

	float applyIorToRoughness( float roughness, float ior ) {

		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );

	}

	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {

		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );

		#ifdef TEXTURE_LOD_EXT

			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );

		#else

			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );

		#endif

	}

	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {

		if ( attenuationDistance == 0.0 ) {

			// Attenuation distance is +∞ (which we indicate by zero), i.e. the transmitted color is not attenuated at all.
			return radiance;

		} else {

			// Compute light attenuation using Beer's law.
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
			return transmittance * radiance;

		}

	}

	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {

		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;

		// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;

		// Sample framebuffer to get pixel the refracted ray hits.
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );

		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );

		// Get the specular component.
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );

		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );

	}
#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl.js":
/*!****************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl.js":
/*!**************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/uv2_vertex.glsl.js":
/*!*********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/uv2_vertex.glsl.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl.js":
/*!***************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl.js":
/*!*************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/uv_vertex.glsl.js":
/*!********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/uv_vertex.glsl.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderChunk/worldpos_vertex.glsl.js":
/*!**************************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderChunk/worldpos_vertex.glsl.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (/* glsl */`
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`);


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib.js":
/*!***************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib.js ***!
  \***************************************************/
/*! exports provided: ShaderLib */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function () { return ShaderLib; });
/* harmony import */ var _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShaderChunk.js */ "./libs/three/renderers/shaders/ShaderChunk.js");
/* harmony import */ var _UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UniformsUtils.js */ "./libs/three/renderers/shaders/UniformsUtils.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./UniformsLib.js */ "./libs/three/renderers/shaders/UniformsLib.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../math/Color.js */ "./libs/three/math/Color.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../math/Matrix3.js */ "./libs/three/math/Matrix3.js");








				const ShaderLib = {
					basic: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].specularmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshbasic_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshbasic_frag
					},

					lambert: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].specularmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].emissivemap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
							{
								emissive: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](0x000000) }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshlambert_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshlambert_frag
					},

					phong: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].specularmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].emissivemap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
							{
								emissive: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](0x000000) },
								specular: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](0x111111) },
								shininess: { value: 30 }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphong_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphong_frag
					},

					standard: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].emissivemap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].roughnessmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].metalnessmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
							{
								emissive: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](0x000000) },
								roughness: { value: 1.0 },
								metalness: { value: 0.0 },
								envMapIntensity: { value: 1 } // temporary
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphysical_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphysical_frag
					},

					toon: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].aomap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lightmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].emissivemap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].gradientmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
							{
								emissive: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](0x000000) }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshtoon_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshtoon_frag
					},

					matcap: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
							{
								matcap: { value: null }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshmatcap_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshmatcap_frag
					},

					points: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].points, _UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].points_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].points_frag
					},

					dashed: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
							{
								scale: { value: 1 },
								dashSize: { value: 1 },
								totalSize: { value: 2 }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].linedashed_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].linedashed_frag
					},

					depth: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common, _UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].depth_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].depth_frag
					},

					normal: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].bumpmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].normalmap,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
							{
								opacity: { value: 1.0 }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshnormal_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshnormal_frag
					},

					sprite: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].sprite, _UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].sprite_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].sprite_frag
					},

					background: {
						uniforms: {
							uvTransform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_6__["Matrix3"]() },
							t2D: { value: null }
						},

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].background_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].background_frag
					},
					/* -------------------------------------------------------------------------
					  //	Cube map shader
					   ------------------------------------------------------------------------- */

					cube: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].envmap,
							{
								opacity: { value: 1.0 }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].cube_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].cube_frag
					},

					equirect: {
						uniforms: {
							tEquirect: { value: null }
						},

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].equirect_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].equirect_frag
					},

					distanceRGBA: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].common,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].displacementmap,
							{
								referencePosition: { value: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]() },
								nearDistance: { value: 1 },
								farDistance: { value: 1000 }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].distanceRGBA_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].distanceRGBA_frag
					},

					shadow: {
						uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].lights,
							_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].fog,
							{
								color: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](0x00000) },
								opacity: { value: 1.0 }
							}
						]),

						vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].shadow_vert,
						fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].shadow_frag
					}
				};

				ShaderLib.physical = {
					uniforms: Object(_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_1__["mergeUniforms"])([
						ShaderLib.standard.uniforms,
						{
							clearcoat: { value: 0 },
							clearcoatMap: { value: null },
							clearcoatRoughness: { value: 0 },
							clearcoatRoughnessMap: { value: null },
							clearcoatNormalScale: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](1, 1) },
							clearcoatNormalMap: { value: null },
							sheen: { value: 0 },
							sheenColor: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](0x000000) },
							sheenColorMap: { value: null },
							sheenRoughness: { value: 0 },
							sheenRoughnessMap: { value: null },
							transmission: { value: 0 },
							transmissionMap: { value: null },
							transmissionSamplerSize: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]() },
							transmissionSamplerMap: { value: null },
							thickness: { value: 0 },
							thicknessMap: { value: null },
							attenuationDistance: { value: 0 },
							attenuationColor: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](0x000000) },
							specularIntensity: { value: 0 },
							specularIntensityMap: { value: null },
							specularColor: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_5__["Color"](1, 1, 1) },
							specularColorMap: { value: null }
						}
					]),

					vertexShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphysical_vert,
					fragmentShader: _ShaderChunk_js__WEBPACK_IMPORTED_MODULE_0__["ShaderChunk"].meshphysical_frag
				};




				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/background.glsl.js":
/*!*******************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/background.glsl.js ***!
  \*******************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`;

				const fragment = /* glsl */ `
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/cube.glsl.js":
/*!*************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/cube.glsl.js ***!
  \*************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`;

				const fragment = /* glsl */ `
#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/depth.glsl.js":
/*!**************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/depth.glsl.js ***!
  \**************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`;

				const fragment = /* glsl */ `
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/distanceRGBA.glsl.js":
/*!*********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/distanceRGBA.glsl.js ***!
  \*********************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`;

				const fragment = /* glsl */ `
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/equirect.glsl.js":
/*!*****************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/equirect.glsl.js ***!
  \*****************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`;

				const fragment = /* glsl */ `
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/linedashed.glsl.js":
/*!*******************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/linedashed.glsl.js ***!
  \*******************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;

				const fragment = /* glsl */ `
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/meshbasic.glsl.js":
/*!******************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/meshbasic.glsl.js ***!
  \******************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`;

				const fragment = /* glsl */ `
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/meshlambert.glsl.js":
/*!********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/meshlambert.glsl.js ***!
  \********************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`;

				const fragment = /* glsl */ `
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation

	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/meshmatcap.glsl.js":
/*!*******************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/meshmatcap.glsl.js ***!
  \*******************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#define MATCAP

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`;

				const fragment = /* glsl */ `
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/meshnormal.glsl.js":
/*!*******************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/meshnormal.glsl.js ***!
  \*******************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`;

				const fragment = /* glsl */ `
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/meshphong.glsl.js":
/*!******************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/meshphong.glsl.js ***!
  \******************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#define PHONG

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

				const fragment = /* glsl */ `
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/meshphysical.glsl.js":
/*!*********************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/meshphysical.glsl.js ***!
  \*********************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#define STANDARD

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

	varying vec3 vWorldPosition;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

#ifdef USE_TRANSMISSION

	vWorldPosition = worldPosition.xyz;

#endif
}
`;

				const fragment = /* glsl */ `
#define STANDARD

#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
	uniform float ior;
#endif

#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;

	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif

	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif

#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;

	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif

	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	#include <transmission_fragment>

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	#ifdef USE_CLEARCOAT

		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

		outgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;

	#endif

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/meshtoon.glsl.js":
/*!*****************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/meshtoon.glsl.js ***!
  \*****************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#define TOON

varying vec3 vViewPosition;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

				const fragment = /* glsl */ `
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/points.glsl.js":
/*!***************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/points.glsl.js ***!
  \***************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`;

				const fragment = /* glsl */ `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/shadow.glsl.js":
/*!***************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/shadow.glsl.js ***!
  \***************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

				const fragment = /* glsl */ `
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/sprite.glsl.js":
/*!***************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/sprite.glsl.js ***!
  \***************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;

				const fragment = /* glsl */ `
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/ShaderLib/vsm.glsl.js":
/*!************************************************************!*\
  !*** ./libs/three/renderers/shaders/ShaderLib/vsm.glsl.js ***!
  \************************************************************/
/*! exports provided: vertex, fragment */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vertex", function () { return vertex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fragment", function () { return fragment; });
				const vertex = /* glsl */ `
void main() {

	gl_Position = vec4( position, 1.0 );

}
`;

				const fragment = /* glsl */ `
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	const float samples = float( VSM_SAMPLES );

	float mean = 0.0;
	float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	// float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );

	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {

		float uvOffset = uvStart + i * uvStride;

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean / samples;
	squared_mean = squared_mean / samples;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;


				/***/
}),

/***/ "./libs/three/renderers/shaders/UniformsLib.js":
/*!*****************************************************!*\
  !*** ./libs/three/renderers/shaders/UniformsLib.js ***!
  \*****************************************************/
/*! exports provided: UniformsLib */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function () { return UniformsLib; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Color.js */ "./libs/three/math/Color.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Matrix3.js */ "./libs/three/math/Matrix3.js");




				/**
				 * Uniforms library for shared webgl shaders
				 */

				const UniformsLib = {
					common: {
						diffuse: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
						opacity: { value: 1.0 },

						map: { value: null },
						uvTransform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__["Matrix3"]() },
						uv2Transform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__["Matrix3"]() },

						alphaMap: { value: null },
						alphaTest: { value: 0 }
					},

					specularmap: {
						specularMap: { value: null }
					},

					envmap: {
						envMap: { value: null },
						flipEnvMap: { value: -1 },
						reflectivity: { value: 1.0 }, // basic, lambert, phong
						ior: { value: 1.5 }, // standard, physical
						refractionRatio: { value: 0.98 },
						maxMipLevel: { value: 0 }
					},

					aomap: {
						aoMap: { value: null },
						aoMapIntensity: { value: 1 }
					},

					lightmap: {
						lightMap: { value: null },
						lightMapIntensity: { value: 1 }
					},

					emissivemap: {
						emissiveMap: { value: null }
					},

					bumpmap: {
						bumpMap: { value: null },
						bumpScale: { value: 1 }
					},

					normalmap: {
						normalMap: { value: null },
						normalScale: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](1, 1) }
					},

					displacementmap: {
						displacementMap: { value: null },
						displacementScale: { value: 1 },
						displacementBias: { value: 0 }
					},

					roughnessmap: {
						roughnessMap: { value: null }
					},

					metalnessmap: {
						metalnessMap: { value: null }
					},

					gradientmap: {
						gradientMap: { value: null }
					},

					fog: {
						fogDensity: { value: 0.00025 },
						fogNear: { value: 1 },
						fogFar: { value: 2000 },
						fogColor: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) }
					},

					lights: {
						ambientLightColor: { value: [] },

						lightProbe: { value: [] },

						directionalLights: {
							value: [],
							properties: {
								direction: {},
								color: {}
							}
						},

						directionalLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},

						directionalShadowMap: { value: [] },
						directionalShadowMatrix: { value: [] },

						spotLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								direction: {},
								distance: {},
								coneCos: {},
								penumbraCos: {},
								decay: {}
							}
						},

						spotLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},

						spotShadowMap: { value: [] },
						spotShadowMatrix: { value: [] },

						pointLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								decay: {},
								distance: {}
							}
						},

						pointLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {},
								shadowCameraNear: {},
								shadowCameraFar: {}
							}
						},

						pointShadowMap: { value: [] },
						pointShadowMatrix: { value: [] },

						hemisphereLights: {
							value: [],
							properties: {
								direction: {},
								skyColor: {},
								groundColor: {}
							}
						},

						// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
						rectAreaLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								width: {},
								height: {}
							}
						},

						ltc_1: { value: null },
						ltc_2: { value: null }
					},

					points: {
						diffuse: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
						opacity: { value: 1.0 },
						size: { value: 1.0 },
						scale: { value: 1.0 },
						map: { value: null },
						alphaMap: { value: null },
						alphaTest: { value: 0 },
						uvTransform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__["Matrix3"]() }
					},

					sprite: {
						diffuse: { value: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](0xffffff) },
						opacity: { value: 1.0 },
						center: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_1__["Vector2"](0.5, 0.5) },
						rotation: { value: 0.0 },
						map: { value: null },
						alphaMap: { value: null },
						alphaTest: { value: 0 },
						uvTransform: { value: new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_2__["Matrix3"]() }
					}
				};




				/***/
}),

/***/ "./libs/three/renderers/shaders/UniformsUtils.js":
/*!*******************************************************!*\
  !*** ./libs/three/renderers/shaders/UniformsUtils.js ***!
  \*******************************************************/
/*! exports provided: cloneUniforms, mergeUniforms, UniformsUtils */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneUniforms", function () { return cloneUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeUniforms", function () { return mergeUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function () { return UniformsUtils; });
				/**
				 * Uniform Utilities
				 */

				function cloneUniforms(src) {
					const dst = {};

					for (const u in src) {
						dst[u] = {};

						for (const p in src[u]) {
							const property = src[u][p];

							if (
								property &&
								(property.isColor ||
									property.isMatrix3 ||
									property.isMatrix4 ||
									property.isVector2 ||
									property.isVector3 ||
									property.isVector4 ||
									property.isTexture ||
									property.isQuaternion)
							) {
								dst[u][p] = property.clone();
							} else if (Array.isArray(property)) {
								dst[u][p] = property.slice();
							} else {
								dst[u][p] = property;
							}
						}
					}

					return dst;
				}

				function mergeUniforms(uniforms) {
					const merged = {};

					for (let u = 0; u < uniforms.length; u++) {
						const tmp = cloneUniforms(uniforms[u]);

						for (const p in tmp) {
							merged[p] = tmp[p];
						}
					}

					return merged;
				}

				// Legacy

				const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLAnimation.js":
/*!******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLAnimation.js ***!
  \******************************************************/
/*! exports provided: WebGLAnimation */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLAnimation", function () { return WebGLAnimation; });
				function WebGLAnimation() {
					let context = null;
					let isAnimating = false;
					let animationLoop = null;
					let requestId = null;

					function onAnimationFrame(time, frame) {
						animationLoop(time, frame);

						requestId = context.requestAnimationFrame(onAnimationFrame);
					}

					return {
						start: function () {
							if (isAnimating === true) return;
							if (animationLoop === null) return;

							requestId = context.requestAnimationFrame(onAnimationFrame);

							isAnimating = true;
						},

						stop: function () {
							context.cancelAnimationFrame(requestId);

							isAnimating = false;
						},

						setAnimationLoop: function (callback) {
							animationLoop = callback;
						},

						setContext: function (value) {
							context = value;
						}
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLAttributes.js":
/*!*******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLAttributes.js ***!
  \*******************************************************/
/*! exports provided: WebGLAttributes */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLAttributes", function () { return WebGLAttributes; });
				function WebGLAttributes(gl, capabilities) {
					const isWebGL2 = capabilities.isWebGL2;

					const buffers = new WeakMap();

					function createBuffer(attribute, bufferType) {
						const array = attribute.array;
						const usage = attribute.usage;

						const buffer = gl.createBuffer();

						gl.bindBuffer(bufferType, buffer);
						gl.bufferData(bufferType, array, usage);

						attribute.onUploadCallback();

						let type = gl.FLOAT;

						if (array instanceof Float32Array) {
							type = gl.FLOAT;
						} else if (array instanceof Float64Array) {
							console.warn(
								'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.'
							);
						} else if (array instanceof Uint16Array) {
							if (attribute.isFloat16BufferAttribute) {
								if (isWebGL2) {
									type = gl.HALF_FLOAT;
								} else {
									console.warn(
										'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.'
									);
								}
							} else {
								type = gl.UNSIGNED_SHORT;
							}
						} else if (array instanceof Int16Array) {
							type = gl.SHORT;
						} else if (array instanceof Uint32Array) {
							type = gl.UNSIGNED_INT;
						} else if (array instanceof Int32Array) {
							type = gl.INT;
						} else if (array instanceof Int8Array) {
							type = gl.BYTE;
						} else if (array instanceof Uint8Array) {
							type = gl.UNSIGNED_BYTE;
						} else if (array instanceof Uint8ClampedArray) {
							type = gl.UNSIGNED_BYTE;
						}

						return {
							buffer: buffer,
							type: type,
							bytesPerElement: array.BYTES_PER_ELEMENT,
							version: attribute.version
						};
					}

					function updateBuffer(buffer, attribute, bufferType) {
						const array = attribute.array;
						const updateRange = attribute.updateRange;

						gl.bindBuffer(bufferType, buffer);

						if (updateRange.count === -1) {
							// Not using update ranges

							gl.bufferSubData(bufferType, 0, array);
						} else {
							if (isWebGL2) {
								gl.bufferSubData(
									bufferType,
									updateRange.offset * array.BYTES_PER_ELEMENT,
									array,
									updateRange.offset,
									updateRange.count
								);
							} else {
								gl.bufferSubData(
									bufferType,
									updateRange.offset * array.BYTES_PER_ELEMENT,
									array.subarray(
										updateRange.offset,
										updateRange.offset + updateRange.count
									)
								);
							}

							updateRange.count = -1; // reset range
						}
					}

					//

					function get(attribute) {
						if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

						return buffers.get(attribute);
					}

					function remove(attribute) {
						if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

						const data = buffers.get(attribute);

						if (data) {
							gl.deleteBuffer(data.buffer);

							buffers.delete(attribute);
						}
					}

					function update(attribute, bufferType) {
						if (attribute.isGLBufferAttribute) {
							const cached = buffers.get(attribute);

							if (!cached || cached.version < attribute.version) {
								buffers.set(attribute, {
									buffer: attribute.buffer,
									type: attribute.type,
									bytesPerElement: attribute.elementSize,
									version: attribute.version
								});
							}

							return;
						}

						if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;

						const data = buffers.get(attribute);

						if (data === undefined) {
							buffers.set(attribute, createBuffer(attribute, bufferType));
						} else if (data.version < attribute.version) {
							updateBuffer(data.buffer, attribute, bufferType);

							data.version = attribute.version;
						}
					}

					return {
						get: get,
						remove: remove,
						update: update
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLBackground.js":
/*!*******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLBackground.js ***!
  \*******************************************************/
/*! exports provided: WebGLBackground */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLBackground", function () { return WebGLBackground; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../geometries/BoxGeometry.js */ "./libs/three/geometries/BoxGeometry.js");
/* harmony import */ var _geometries_PlaneGeometry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../geometries/PlaneGeometry.js */ "./libs/three/geometries/PlaneGeometry.js");
/* harmony import */ var _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../materials/ShaderMaterial.js */ "./libs/three/materials/ShaderMaterial.js");
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../math/Color.js */ "./libs/three/math/Color.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../objects/Mesh.js */ "./libs/three/objects/Mesh.js");
/* harmony import */ var _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../shaders/ShaderLib.js */ "./libs/three/renderers/shaders/ShaderLib.js");
/* harmony import */ var _shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../shaders/UniformsUtils.js */ "./libs/three/renderers/shaders/UniformsUtils.js");









				function WebGLBackground(
					renderer,
					cubemaps,
					state,
					objects,
					premultipliedAlpha
				) {
					const clearColor = new _math_Color_js__WEBPACK_IMPORTED_MODULE_4__["Color"](0x000000);
					let clearAlpha = 0;

					let planeMesh;
					let boxMesh;

					let currentBackground = null;
					let currentBackgroundVersion = 0;
					let currentTonemapping = null;

					function render(renderList, scene) {
						let forceClear = false;
						let background = scene.isScene === true ? scene.background : null;
						if (background && background.isTexture) {
							background = cubemaps.get(background);
						}

						// Ignore background in AR
						// TODO: Reconsider this.

						// const xr = renderer.xr;
						// const session = xr.getSession && xr.getSession();

						// if (session && session.environmentBlendMode === 'additive') {
						//   background = null;
						// }

						if (background === null) {
							setClear(clearColor, clearAlpha);
						} else if (background && background.isColor) {
							setClear(background, 1);
							forceClear = true;
						}

						if (renderer.autoClear || forceClear) {
							renderer.clear(
								renderer.autoClearColor,
								renderer.autoClearDepth,
								renderer.autoClearStencil
							);
						}

						if (
							background &&
							(background.isCubeTexture ||
								background.mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVReflectionMapping"])
						) {
							if (boxMesh === undefined) {
								boxMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_5__["Mesh"](
									new _geometries_BoxGeometry_js__WEBPACK_IMPORTED_MODULE_1__["BoxGeometry"](1, 1, 1),
									new _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__["ShaderMaterial"]({
										name: 'BackgroundCubeMaterial',
										uniforms: Object(_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_7__["cloneUniforms"])(_shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].cube.uniforms),
										vertexShader: _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].cube.vertexShader,
										fragmentShader: _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].cube.fragmentShader,
										side: _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"],
										depthTest: false,
										depthWrite: false,
										fog: false
									})
								);

								boxMesh.geometry.deleteAttribute('normal');
								boxMesh.geometry.deleteAttribute('uv');

								boxMesh.onBeforeRender = function (renderer, scene, camera) {
									this.matrixWorld.copyPosition(camera.matrixWorld);
								};

								// enable code injection for non-built-in material
								Object.defineProperty(boxMesh.material, 'envMap', {
									get: function () {
										return this.uniforms.envMap.value;
									}
								});

								objects.update(boxMesh);
							}

							boxMesh.material.uniforms.envMap.value = background;
							boxMesh.material.uniforms.flipEnvMap.value =
								background.isCubeTexture && background.isRenderTargetTexture === false
									? -1
									: 1;

							if (
								currentBackground !== background ||
								currentBackgroundVersion !== background.version ||
								currentTonemapping !== renderer.toneMapping
							) {
								boxMesh.material.needsUpdate = true;

								currentBackground = background;
								currentBackgroundVersion = background.version;
								currentTonemapping = renderer.toneMapping;
							}

							// push to the pre-sorted opaque render list
							renderList.unshift(
								boxMesh,
								boxMesh.geometry,
								boxMesh.material,
								0,
								0,
								null
							);
						} else if (background && background.isTexture) {
							if (planeMesh === undefined) {
								planeMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_5__["Mesh"](
									new _geometries_PlaneGeometry_js__WEBPACK_IMPORTED_MODULE_2__["PlaneGeometry"](2, 2),
									new _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__["ShaderMaterial"]({
										name: 'BackgroundMaterial',
										uniforms: Object(_shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_7__["cloneUniforms"])(_shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].background.uniforms),
										vertexShader: _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].background.vertexShader,
										fragmentShader: _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_6__["ShaderLib"].background.fragmentShader,
										side: _constants_js__WEBPACK_IMPORTED_MODULE_0__["FrontSide"],
										depthTest: false,
										depthWrite: false,
										fog: false
									})
								);

								planeMesh.geometry.deleteAttribute('normal');

								// enable code injection for non-built-in material
								Object.defineProperty(planeMesh.material, 'map', {
									get: function () {
										return this.uniforms.t2D.value;
									}
								});

								objects.update(planeMesh);
							}

							planeMesh.material.uniforms.t2D.value = background;

							if (background.matrixAutoUpdate === true) {
								background.updateMatrix();
							}

							planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);

							if (
								currentBackground !== background ||
								currentBackgroundVersion !== background.version ||
								currentTonemapping !== renderer.toneMapping
							) {
								planeMesh.material.needsUpdate = true;

								currentBackground = background;
								currentBackgroundVersion = background.version;
								currentTonemapping = renderer.toneMapping;
							}

							// push to the pre-sorted opaque render list
							renderList.unshift(
								planeMesh,
								planeMesh.geometry,
								planeMesh.material,
								0,
								0,
								null
							);
						}
					}

					function setClear(color, alpha) {
						state.buffers.color.setClear(
							color.r,
							color.g,
							color.b,
							alpha,
							premultipliedAlpha
						);
					}

					return {
						getClearColor: function () {
							return clearColor;
						},
						setClearColor: function (color, alpha = 1) {
							clearColor.set(color);
							clearAlpha = alpha;
							setClear(clearColor, clearAlpha);
						},
						getClearAlpha: function () {
							return clearAlpha;
						},
						setClearAlpha: function (alpha) {
							clearAlpha = alpha;
							setClear(clearColor, clearAlpha);
						},
						render: render
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLBindingStates.js":
/*!**********************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLBindingStates.js ***!
  \**********************************************************/
/*! exports provided: WebGLBindingStates */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLBindingStates", function () { return WebGLBindingStates; });
				function WebGLBindingStates(gl, extensions, attributes, capabilities) {
					const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);

					const extension = capabilities.isWebGL2
						? null
						: extensions.get('OES_vertex_array_object');
					const vaoAvailable = capabilities.isWebGL2 || extension !== null;

					const bindingStates = {};

					const defaultState = createBindingState(null);
					let currentState = defaultState;

					function setup(object, material, program, geometry, index) {
						let updateBuffers = false;

						if (vaoAvailable) {
							const state = getBindingState(geometry, program, material);

							if (currentState !== state) {
								currentState = state;
								bindVertexArrayObject(currentState.object);
							}

							updateBuffers = needsUpdate(geometry, index);

							if (updateBuffers) saveCache(geometry, index);
						} else {
							const wireframe = material.wireframe === true;

							if (
								currentState.geometry !== geometry.id ||
								currentState.program !== program.id ||
								currentState.wireframe !== wireframe
							) {
								currentState.geometry = geometry.id;
								currentState.program = program.id;
								currentState.wireframe = wireframe;

								updateBuffers = true;
							}
						}

						if (object.isInstancedMesh === true) {
							updateBuffers = true;
						}

						if (index !== null) {
							attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
						}

						if (updateBuffers) {
							setupVertexAttributes(object, material, program, geometry);

							if (index !== null) {
								gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
							}
						}
					}

					function createVertexArrayObject() {
						if (capabilities.isWebGL2) return gl.createVertexArray();

						return extension.createVertexArrayOES();
					}

					function bindVertexArrayObject(vao) {
						if (capabilities.isWebGL2) return gl.bindVertexArray(vao);

						return extension.bindVertexArrayOES(vao);
					}

					function deleteVertexArrayObject(vao) {
						if (capabilities.isWebGL2) return gl.deleteVertexArray(vao);

						return extension.deleteVertexArrayOES(vao);
					}

					function getBindingState(geometry, program, material) {
						const wireframe = material.wireframe === true;

						let programMap = bindingStates[geometry.id];

						if (programMap === undefined) {
							programMap = {};
							bindingStates[geometry.id] = programMap;
						}

						let stateMap = programMap[program.id];

						if (stateMap === undefined) {
							stateMap = {};
							programMap[program.id] = stateMap;
						}

						let state = stateMap[wireframe];

						if (state === undefined) {
							state = createBindingState(createVertexArrayObject());
							stateMap[wireframe] = state;
						}

						return state;
					}

					function createBindingState(vao) {
						const newAttributes = [];
						const enabledAttributes = [];
						const attributeDivisors = [];

						for (let i = 0; i < maxVertexAttributes; i++) {
							newAttributes[i] = 0;
							enabledAttributes[i] = 0;
							attributeDivisors[i] = 0;
						}

						return {
							// for backward compatibility on non-VAO support browser
							geometry: null,
							program: null,
							wireframe: false,

							newAttributes: newAttributes,
							enabledAttributes: enabledAttributes,
							attributeDivisors: attributeDivisors,
							object: vao,
							attributes: {},
							index: null
						};
					}

					function needsUpdate(geometry, index) {
						const cachedAttributes = currentState.attributes;
						const geometryAttributes = geometry.attributes;

						let attributesNum = 0;

						for (const key in geometryAttributes) {
							const cachedAttribute = cachedAttributes[key];
							const geometryAttribute = geometryAttributes[key];

							if (cachedAttribute === undefined) return true;

							if (cachedAttribute.attribute !== geometryAttribute) return true;

							if (cachedAttribute.data !== geometryAttribute.data) return true;

							attributesNum++;
						}

						if (currentState.attributesNum !== attributesNum) return true;

						if (currentState.index !== index) return true;

						return false;
					}

					function saveCache(geometry, index) {
						const cache = {};
						const attributes = geometry.attributes;
						let attributesNum = 0;

						for (const key in attributes) {
							const attribute = attributes[key];

							const data = {};
							data.attribute = attribute;

							if (attribute.data) {
								data.data = attribute.data;
							}

							cache[key] = data;

							attributesNum++;
						}

						currentState.attributes = cache;
						currentState.attributesNum = attributesNum;

						currentState.index = index;
					}

					function initAttributes() {
						const newAttributes = currentState.newAttributes;

						for (let i = 0, il = newAttributes.length; i < il; i++) {
							newAttributes[i] = 0;
						}
					}

					function enableAttribute(attribute) {
						enableAttributeAndDivisor(attribute, 0);
					}

					function enableAttributeAndDivisor(attribute, meshPerAttribute) {
						const newAttributes = currentState.newAttributes;
						const enabledAttributes = currentState.enabledAttributes;
						const attributeDivisors = currentState.attributeDivisors;

						newAttributes[attribute] = 1;

						if (enabledAttributes[attribute] === 0) {
							gl.enableVertexAttribArray(attribute);
							enabledAttributes[attribute] = 1;
						}

						if (attributeDivisors[attribute] !== meshPerAttribute) {
							const extension = capabilities.isWebGL2
								? gl
								: extensions.get('ANGLE_instanced_arrays');

							extension[
								capabilities.isWebGL2
									? 'vertexAttribDivisor'
									: 'vertexAttribDivisorANGLE'
							](attribute, meshPerAttribute);
							attributeDivisors[attribute] = meshPerAttribute;
						}
					}

					function disableUnusedAttributes() {
						const newAttributes = currentState.newAttributes;
						const enabledAttributes = currentState.enabledAttributes;

						for (let i = 0, il = enabledAttributes.length; i < il; i++) {
							if (enabledAttributes[i] !== newAttributes[i]) {
								gl.disableVertexAttribArray(i);
								enabledAttributes[i] = 0;
							}
						}
					}

					function vertexAttribPointer(index, size, type, normalized, stride, offset) {
						if (
							capabilities.isWebGL2 === true &&
							(type === gl.INT || type === gl.UNSIGNED_INT)
						) {
							gl.vertexAttribIPointer(index, size, type, stride, offset);
						} else {
							gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
						}
					}

					function setupVertexAttributes(object, material, program, geometry) {
						if (
							capabilities.isWebGL2 === false &&
							(object.isInstancedMesh || geometry.isInstancedBufferGeometry)
						) {
							if (extensions.get('ANGLE_instanced_arrays') === null) return;
						}

						initAttributes();

						const geometryAttributes = geometry.attributes;

						const programAttributes = program.getAttributes();

						const materialDefaultAttributeValues = material.defaultAttributeValues;

						for (const name in programAttributes) {
							const programAttribute = programAttributes[name];

							if (programAttribute.location >= 0) {
								let geometryAttribute = geometryAttributes[name];

								if (geometryAttribute === undefined) {
									if (name === 'instanceMatrix' && object.instanceMatrix)
										geometryAttribute = object.instanceMatrix;
									if (name === 'instanceColor' && object.instanceColor)
										geometryAttribute = object.instanceColor;
								}

								if (geometryAttribute !== undefined) {
									const normalized = geometryAttribute.normalized;
									const size = geometryAttribute.itemSize;

									const attribute = attributes.get(geometryAttribute);

									// TODO Attribute may not be available on context restore

									if (attribute === undefined) continue;

									const buffer = attribute.buffer;
									const type = attribute.type;
									const bytesPerElement = attribute.bytesPerElement;

									if (geometryAttribute.isInterleavedBufferAttribute) {
										const data = geometryAttribute.data;
										const stride = data.stride;
										const offset = geometryAttribute.offset;

										if (data && data.isInstancedInterleavedBuffer) {
											for (let i = 0; i < programAttribute.locationSize; i++) {
												enableAttributeAndDivisor(
													programAttribute.location + i,
													data.meshPerAttribute
												);
											}

											if (
												object.isInstancedMesh !== true &&
												geometry._maxInstanceCount === undefined
											) {
												geometry._maxInstanceCount = data.meshPerAttribute * data.count;
											}
										} else {
											for (let i = 0; i < programAttribute.locationSize; i++) {
												enableAttribute(programAttribute.location + i);
											}
										}

										gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

										for (let i = 0; i < programAttribute.locationSize; i++) {
											vertexAttribPointer(
												programAttribute.location + i,
												size / programAttribute.locationSize,
												type,
												normalized,
												stride * bytesPerElement,
												(offset + (size / programAttribute.locationSize) * i) *
												bytesPerElement
											);
										}
									} else {
										if (geometryAttribute.isInstancedBufferAttribute) {
											for (let i = 0; i < programAttribute.locationSize; i++) {
												enableAttributeAndDivisor(
													programAttribute.location + i,
													geometryAttribute.meshPerAttribute
												);
											}

											if (
												object.isInstancedMesh !== true &&
												geometry._maxInstanceCount === undefined
											) {
												geometry._maxInstanceCount =
													geometryAttribute.meshPerAttribute * geometryAttribute.count;
											}
										} else {
											for (let i = 0; i < programAttribute.locationSize; i++) {
												enableAttribute(programAttribute.location + i);
											}
										}

										gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

										for (let i = 0; i < programAttribute.locationSize; i++) {
											vertexAttribPointer(
												programAttribute.location + i,
												size / programAttribute.locationSize,
												type,
												normalized,
												size * bytesPerElement,
												(size / programAttribute.locationSize) * i * bytesPerElement
											);
										}
									}
								} else if (materialDefaultAttributeValues !== undefined) {
									const value = materialDefaultAttributeValues[name];

									if (value !== undefined) {
										switch (value.length) {
											case 2:
												gl.vertexAttrib2fv(programAttribute.location, value);
												break;

											case 3:
												gl.vertexAttrib3fv(programAttribute.location, value);
												break;

											case 4:
												gl.vertexAttrib4fv(programAttribute.location, value);
												break;

											default:
												gl.vertexAttrib1fv(programAttribute.location, value);
										}
									}
								}
							}
						}

						disableUnusedAttributes();
					}

					function dispose() {
						reset();

						for (const geometryId in bindingStates) {
							const programMap = bindingStates[geometryId];

							for (const programId in programMap) {
								const stateMap = programMap[programId];

								for (const wireframe in stateMap) {
									deleteVertexArrayObject(stateMap[wireframe].object);

									delete stateMap[wireframe];
								}

								delete programMap[programId];
							}

							delete bindingStates[geometryId];
						}
					}

					function releaseStatesOfGeometry(geometry) {
						if (bindingStates[geometry.id] === undefined) return;

						const programMap = bindingStates[geometry.id];

						for (const programId in programMap) {
							const stateMap = programMap[programId];

							for (const wireframe in stateMap) {
								deleteVertexArrayObject(stateMap[wireframe].object);

								delete stateMap[wireframe];
							}

							delete programMap[programId];
						}

						delete bindingStates[geometry.id];
					}

					function releaseStatesOfProgram(program) {
						for (const geometryId in bindingStates) {
							const programMap = bindingStates[geometryId];

							if (programMap[program.id] === undefined) continue;

							const stateMap = programMap[program.id];

							for (const wireframe in stateMap) {
								deleteVertexArrayObject(stateMap[wireframe].object);

								delete stateMap[wireframe];
							}

							delete programMap[program.id];
						}
					}

					function reset() {
						resetDefaultState();

						if (currentState === defaultState) return;

						currentState = defaultState;
						bindVertexArrayObject(currentState.object);
					}

					// for backward-compatilibity

					function resetDefaultState() {
						defaultState.geometry = null;
						defaultState.program = null;
						defaultState.wireframe = false;
					}

					return {
						setup: setup,
						reset: reset,
						resetDefaultState: resetDefaultState,
						dispose: dispose,
						releaseStatesOfGeometry: releaseStatesOfGeometry,
						releaseStatesOfProgram: releaseStatesOfProgram,

						initAttributes: initAttributes,
						enableAttribute: enableAttribute,
						disableUnusedAttributes: disableUnusedAttributes
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLBufferRenderer.js":
/*!***********************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLBufferRenderer.js ***!
  \***********************************************************/
/*! exports provided: WebGLBufferRenderer */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLBufferRenderer", function () { return WebGLBufferRenderer; });
				function WebGLBufferRenderer(gl, extensions, info, capabilities) {
					const isWebGL2 = capabilities.isWebGL2;

					let mode;

					function setMode(value) {
						mode = value;
					}

					function render(start, count) {
						gl.drawArrays(mode, start, count);

						info.update(count, mode, 1);
					}

					function renderInstances(start, count, primcount) {
						if (primcount === 0) return;

						let extension, methodName;

						if (isWebGL2) {
							extension = gl;
							methodName = 'drawArraysInstanced';
						} else {
							extension = extensions.get('ANGLE_instanced_arrays');
							methodName = 'drawArraysInstancedANGLE';

							if (extension === null) {
								console.error(
									'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
								);
								return;
							}
						}

						extension[methodName](mode, start, count, primcount);

						info.update(count, mode, primcount);
					}

					//

					this.setMode = setMode;
					this.render = render;
					this.renderInstances = renderInstances;
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLCapabilities.js":
/*!*********************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLCapabilities.js ***!
  \*********************************************************/
/*! exports provided: WebGLCapabilities */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCapabilities", function () { return WebGLCapabilities; });
				function WebGLCapabilities(gl, extensions, parameters) {
					let maxAnisotropy;

					function getMaxAnisotropy() {
						if (maxAnisotropy !== undefined) return maxAnisotropy;

						if (extensions.has('EXT_texture_filter_anisotropic') === true) {
							const extension = extensions.get('EXT_texture_filter_anisotropic');

							maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
						} else {
							maxAnisotropy = 0;
						}

						return maxAnisotropy;
					}

					function getMaxPrecision(precision) {
						if (precision === 'highp') {
							if (
								gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision >
								0 &&
								gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT)
									.precision > 0
							) {
								return 'highp';
							}

							precision = 'mediump';
						}

						if (precision === 'mediump') {
							if (
								gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT)
									.precision > 0 &&
								gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT)
									.precision > 0
							) {
								return 'mediump';
							}
						}

						return 'lowp';
					}

					/* eslint-disable no-undef */
					const isWebGL2 =
						(typeof WebGL2RenderingContext !== 'undefined' &&
							gl instanceof WebGL2RenderingContext) ||
						(typeof WebGL2ComputeRenderingContext !== 'undefined' &&
							gl instanceof WebGL2ComputeRenderingContext);
					/* eslint-enable no-undef */

					let precision =
						parameters.precision !== undefined ? parameters.precision : 'highp';
					const maxPrecision = getMaxPrecision(precision);

					if (maxPrecision !== precision) {
						console.warn(
							'THREE.WebGLRenderer:',
							precision,
							'not supported, using',
							maxPrecision,
							'instead.'
						);
						precision = maxPrecision;
					}

					const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers');

					const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

					const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
					const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
					const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
					const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);

					const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
					const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
					const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
					const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);

					const vertexTextures = maxVertexTextures > 0;
					const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float');
					const floatVertexTextures = vertexTextures && floatFragmentTextures;

					const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;

					return {
						isWebGL2: isWebGL2,

						drawBuffers: drawBuffers,

						getMaxAnisotropy: getMaxAnisotropy,
						getMaxPrecision: getMaxPrecision,

						precision: precision,
						logarithmicDepthBuffer: logarithmicDepthBuffer,

						maxTextures: maxTextures,
						maxVertexTextures: maxVertexTextures,
						maxTextureSize: maxTextureSize,
						maxCubemapSize: maxCubemapSize,

						maxAttributes: maxAttributes,
						maxVertexUniforms: maxVertexUniforms,
						maxVaryings: maxVaryings,
						maxFragmentUniforms: maxFragmentUniforms,

						vertexTextures: vertexTextures,
						floatFragmentTextures: floatFragmentTextures,
						floatVertexTextures: floatVertexTextures,

						maxSamples: maxSamples
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLClipping.js":
/*!*****************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLClipping.js ***!
  \*****************************************************/
/*! exports provided: WebGLClipping */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLClipping", function () { return WebGLClipping; });
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Matrix3.js */ "./libs/three/math/Matrix3.js");
/* harmony import */ var _math_Plane_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Plane.js */ "./libs/three/math/Plane.js");



				function WebGLClipping(properties) {
					const scope = this;

					let globalState = null,
						numGlobalPlanes = 0,
						localClippingEnabled = false,
						renderingShadows = false;

					const plane = new _math_Plane_js__WEBPACK_IMPORTED_MODULE_1__["Plane"](),
						viewNormalMatrix = new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_0__["Matrix3"](),
						uniform = { value: null, needsUpdate: false };

					this.uniform = uniform;
					this.numPlanes = 0;
					this.numIntersection = 0;

					this.init = function (planes, enableLocalClipping, camera) {
						const enabled =
							planes.length !== 0 ||
							enableLocalClipping ||
							// enable state of previous frame - the clipping code has to
							// run another frame in order to reset the state:
							numGlobalPlanes !== 0 ||
							localClippingEnabled;

						localClippingEnabled = enableLocalClipping;

						globalState = projectPlanes(planes, camera, 0);
						numGlobalPlanes = planes.length;

						return enabled;
					};

					this.beginShadows = function () {
						renderingShadows = true;
						projectPlanes(null);
					};

					this.endShadows = function () {
						renderingShadows = false;
						resetGlobalState();
					};

					this.setState = function (material, camera, useCache) {
						const planes = material.clippingPlanes,
							clipIntersection = material.clipIntersection,
							clipShadows = material.clipShadows;

						const materialProperties = properties.get(material);

						if (
							!localClippingEnabled ||
							planes === null ||
							planes.length === 0 ||
							(renderingShadows && !clipShadows)
						) {
							// there's no local clipping

							if (renderingShadows) {
								// there's no global clipping

								projectPlanes(null);
							} else {
								resetGlobalState();
							}
						} else {
							const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
								lGlobal = nGlobal * 4;

							let dstArray = materialProperties.clippingState || null;

							uniform.value = dstArray; // ensure unique state

							dstArray = projectPlanes(planes, camera, lGlobal, useCache);

							for (let i = 0; i !== lGlobal; ++i) {
								dstArray[i] = globalState[i];
							}

							materialProperties.clippingState = dstArray;
							this.numIntersection = clipIntersection ? this.numPlanes : 0;
							this.numPlanes += nGlobal;
						}
					};

					function resetGlobalState() {
						if (uniform.value !== globalState) {
							uniform.value = globalState;
							uniform.needsUpdate = numGlobalPlanes > 0;
						}

						scope.numPlanes = numGlobalPlanes;
						scope.numIntersection = 0;
					}

					function projectPlanes(planes, camera, dstOffset, skipTransform) {
						const nPlanes = planes !== null ? planes.length : 0;
						let dstArray = null;

						if (nPlanes !== 0) {
							dstArray = uniform.value;

							if (skipTransform !== true || dstArray === null) {
								const flatSize = dstOffset + nPlanes * 4,
									viewMatrix = camera.matrixWorldInverse;

								viewNormalMatrix.getNormalMatrix(viewMatrix);

								if (dstArray === null || dstArray.length < flatSize) {
									dstArray = new Float32Array(flatSize);
								}

								for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
									plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);

									plane.normal.toArray(dstArray, i4);
									dstArray[i4 + 3] = plane.constant;
								}
							}

							uniform.value = dstArray;
							uniform.needsUpdate = true;
						}

						scope.numPlanes = nPlanes;
						scope.numIntersection = 0;

						return dstArray;
					}
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLCubeMaps.js":
/*!*****************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLCubeMaps.js ***!
  \*****************************************************/
/*! exports provided: WebGLCubeMaps */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeMaps", function () { return WebGLCubeMaps; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _WebGLCubeRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebGLCubeRenderTarget.js */ "./libs/three/renderers/WebGLCubeRenderTarget.js");



				function WebGLCubeMaps(renderer) {
					let cubemaps = new WeakMap();

					function mapTextureMapping(texture, mapping) {
						if (mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"]) {
							texture.mapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeReflectionMapping"];
						} else if (mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularRefractionMapping"]) {
							texture.mapping = _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeRefractionMapping"];
						}

						return texture;
					}

					function get(texture) {
						if (
							texture &&
							texture.isTexture &&
							texture.isRenderTargetTexture === false
						) {
							const mapping = texture.mapping;

							if (
								mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"] ||
								mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularRefractionMapping"]
							) {
								if (cubemaps.has(texture)) {
									const cubemap = cubemaps.get(texture).texture;
									return mapTextureMapping(cubemap, texture.mapping);
								} else {
									const image = texture.image;

									if (image && image.height > 0) {
										const currentRenderTarget = renderer.getRenderTarget();

										const renderTarget = new _WebGLCubeRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLCubeRenderTarget"](image.height / 2);
										renderTarget.fromEquirectangularTexture(renderer, texture);
										cubemaps.set(texture, renderTarget);

										renderer.setRenderTarget(currentRenderTarget);

										texture.addEventListener('dispose', onTextureDispose);

										return mapTextureMapping(renderTarget.texture, texture.mapping);
									} else {
										// image not yet ready. try the conversion next frame

										return null;
									}
								}
							}
						}

						return texture;
					}

					function onTextureDispose(event) {
						const texture = event.target;

						texture.removeEventListener('dispose', onTextureDispose);

						const cubemap = cubemaps.get(texture);

						if (cubemap !== undefined) {
							cubemaps.delete(texture);
							cubemap.dispose();
						}
					}

					function dispose() {
						cubemaps = new WeakMap();
					}

					return {
						get: get,
						dispose: dispose
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLCubeUVMaps.js":
/*!*******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLCubeUVMaps.js ***!
  \*******************************************************/
/*! exports provided: WebGLCubeUVMaps */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLCubeUVMaps", function () { return WebGLCubeUVMaps; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _extras_PMREMGenerator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../extras/PMREMGenerator.js */ "./libs/three/extras/PMREMGenerator.js");



				function WebGLCubeUVMaps(renderer) {
					let cubeUVmaps = new WeakMap();

					let pmremGenerator = null;

					function get(texture) {
						if (
							texture &&
							texture.isTexture &&
							texture.isRenderTargetTexture === false
						) {
							const mapping = texture.mapping;

							const isEquirectMap =
								mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularReflectionMapping"] ||
								mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["EquirectangularRefractionMapping"];
							const isCubeMap =
								mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeReflectionMapping"] || mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeRefractionMapping"];

							if (isEquirectMap || isCubeMap) {
								// equirect/cube map to cubeUV conversion

								if (cubeUVmaps.has(texture)) {
									return cubeUVmaps.get(texture).texture;
								} else {
									const image = texture.image;

									if (
										(isEquirectMap && image && image.height > 0) ||
										(isCubeMap && image && isCubeTextureComplete(image))
									) {
										const currentRenderTarget = renderer.getRenderTarget();

										if (pmremGenerator === null)
											pmremGenerator = new _extras_PMREMGenerator_js__WEBPACK_IMPORTED_MODULE_1__["PMREMGenerator"](renderer);

										const renderTarget = isEquirectMap
											? pmremGenerator.fromEquirectangular(texture)
											: pmremGenerator.fromCubemap(texture);
										cubeUVmaps.set(texture, renderTarget);

										renderer.setRenderTarget(currentRenderTarget);

										texture.addEventListener('dispose', onTextureDispose);

										return renderTarget.texture;
									} else {
										// image not yet ready. try the conversion next frame

										return null;
									}
								}
							}
						}

						return texture;
					}

					function isCubeTextureComplete(image) {
						let count = 0;
						const length = 6;

						for (let i = 0; i < length; i++) {
							if (image[i] !== undefined) count++;
						}

						return count === length;
					}

					function onTextureDispose(event) {
						const texture = event.target;

						texture.removeEventListener('dispose', onTextureDispose);

						const cubemapUV = cubeUVmaps.get(texture);

						if (cubemapUV !== undefined) {
							cubeUVmaps.delete(texture);
							cubemapUV.dispose();
						}
					}

					function dispose() {
						cubeUVmaps = new WeakMap();

						if (pmremGenerator !== null) {
							pmremGenerator.dispose();
							pmremGenerator = null;
						}
					}

					return {
						get: get,
						dispose: dispose
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLExtensions.js":
/*!*******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLExtensions.js ***!
  \*******************************************************/
/*! exports provided: WebGLExtensions */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLExtensions", function () { return WebGLExtensions; });
				function WebGLExtensions(gl) {
					const extensions = {};

					function getExtension(name) {
						if (extensions[name] !== undefined) {
							return extensions[name];
						}

						let extension;

						switch (name) {
							case 'WEBGL_depth_texture':
								extension =
									gl.getExtension('WEBGL_depth_texture') ||
									gl.getExtension('MOZ_WEBGL_depth_texture') ||
									gl.getExtension('WEBKIT_WEBGL_depth_texture');
								break;

							case 'EXT_texture_filter_anisotropic':
								extension =
									gl.getExtension('EXT_texture_filter_anisotropic') ||
									gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
									gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
								break;

							case 'WEBGL_compressed_texture_s3tc':
								extension =
									gl.getExtension('WEBGL_compressed_texture_s3tc') ||
									gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
									gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
								break;

							case 'WEBGL_compressed_texture_pvrtc':
								extension =
									gl.getExtension('WEBGL_compressed_texture_pvrtc') ||
									gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
								break;

							default:
								extension = gl.getExtension(name);
						}

						extensions[name] = extension;

						return extension;
					}

					return {
						has: function (name) {
							return getExtension(name) !== null && getExtension(name) !== undefined;
						},

						init: function (capabilities) {
							if (capabilities.isWebGL2) {
								getExtension('EXT_color_buffer_float');
							} else {
								getExtension('WEBGL_depth_texture');
								getExtension('OES_texture_float');
								getExtension('OES_texture_half_float');
								getExtension('OES_texture_half_float_linear');
								getExtension('OES_standard_derivatives');
								getExtension('OES_element_index_uint');
								getExtension('OES_vertex_array_object');
								getExtension('ANGLE_instanced_arrays');
							}

							getExtension('OES_texture_float_linear');
							getExtension('EXT_color_buffer_half_float');
						},

						get: function (name) {
							const extension = getExtension(name);

							if (extension === null) {
								console.warn(
									'THREE.WebGLRenderer: ' + name + ' extension not supported.'
								);
							}

							return extension;
						}
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLGeometries.js":
/*!*******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLGeometries.js ***!
  \*******************************************************/
/*! exports provided: WebGLGeometries */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLGeometries", function () { return WebGLGeometries; });
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../core/BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils.js */ "./libs/three/utils.js");



				function WebGLGeometries(gl, attributes, info, bindingStates) {
					const geometries = {};
					const wireframeAttributes = new WeakMap();

					function onGeometryDispose(event) {
						const geometry = event.target;

						if (geometry.index !== null) {
							attributes.remove(geometry.index);
						}

						for (const name in geometry.attributes) {
							attributes.remove(geometry.attributes[name]);
						}

						geometry.removeEventListener('dispose', onGeometryDispose);

						delete geometries[geometry.id];

						const attribute = wireframeAttributes.get(geometry);

						if (attribute) {
							attributes.remove(attribute);
							wireframeAttributes.delete(geometry);
						}

						bindingStates.releaseStatesOfGeometry(geometry);

						if (geometry.isInstancedBufferGeometry === true) {
							delete geometry._maxInstanceCount;
						}

						info.memory.geometries--;
						console.log(`%c======销毁geometry======当前geometry数：${info.memory.geometries}======`, 'color:orange;')
					}

					function get(object, geometry) {
						if (geometries[geometry.id] === true) return geometry;

						geometry.addEventListener('dispose', onGeometryDispose);

						geometries[geometry.id] = true;

						info.memory.geometries++;

						return geometry;
					}

					function update(geometry) {
						const geometryAttributes = geometry.attributes;

						// Updating index buffer in VAO now. See WebGLBindingStates.

						for (const name in geometryAttributes) {
							attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
						}

						// morph targets

						const morphAttributes = geometry.morphAttributes;

						for (const name in morphAttributes) {
							const array = morphAttributes[name];

							for (let i = 0, l = array.length; i < l; i++) {
								attributes.update(array[i], gl.ARRAY_BUFFER);
							}
						}
					}

					function updateWireframeAttribute(geometry) {
						const indices = [];

						const geometryIndex = geometry.index;
						const geometryPosition = geometry.attributes.position;
						let version = 0;

						if (geometryIndex !== null) {
							const array = geometryIndex.array;
							version = geometryIndex.version;

							for (let i = 0, l = array.length; i < l; i += 3) {
								const a = array[i + 0];
								const b = array[i + 1];
								const c = array[i + 2];

								indices.push(a, b, b, c, c, a);
							}
						} else {
							const array = geometryPosition.array;
							version = geometryPosition.version;

							for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
								const a = i + 0;
								const b = i + 1;
								const c = i + 2;

								indices.push(a, b, b, c, c, a);
							}
						}

						const attribute = new (Object(_utils_js__WEBPACK_IMPORTED_MODULE_1__["arrayMax"])(indices) > 65535
							? _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["Uint32BufferAttribute"]
							: _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__["Uint16BufferAttribute"])(indices, 1);
						attribute.version = version;

						// Updating index buffer in VAO now. See WebGLBindingStates

						//

						const previousAttribute = wireframeAttributes.get(geometry);

						if (previousAttribute) attributes.remove(previousAttribute);

						//

						wireframeAttributes.set(geometry, attribute);
					}

					function getWireframeAttribute(geometry) {
						const currentAttribute = wireframeAttributes.get(geometry);

						if (currentAttribute) {
							const geometryIndex = geometry.index;

							if (geometryIndex !== null) {
								// if the attribute is obsolete, create a new one

								if (currentAttribute.version < geometryIndex.version) {
									updateWireframeAttribute(geometry);
								}
							}
						} else {
							updateWireframeAttribute(geometry);
						}

						return wireframeAttributes.get(geometry);
					}

					return {
						get: get,
						update: update,

						getWireframeAttribute: getWireframeAttribute
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLIndexedBufferRenderer.js":
/*!******************************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLIndexedBufferRenderer.js ***!
  \******************************************************************/
/*! exports provided: WebGLIndexedBufferRenderer */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLIndexedBufferRenderer", function () { return WebGLIndexedBufferRenderer; });
				function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
					const isWebGL2 = capabilities.isWebGL2;

					let mode;

					function setMode(value) {
						mode = value;
					}

					let type, bytesPerElement;

					function setIndex(value) {
						type = value.type;
						bytesPerElement = value.bytesPerElement;
					}

					function render(start, count) {
						gl.drawElements(mode, count, type, start * bytesPerElement);

						info.update(count, mode, 1);
					}

					function renderInstances(start, count, primcount) {
						if (primcount === 0) return;

						let extension, methodName;

						if (isWebGL2) {
							extension = gl;
							methodName = 'drawElementsInstanced';
						} else {
							extension = extensions.get('ANGLE_instanced_arrays');
							methodName = 'drawElementsInstancedANGLE';

							if (extension === null) {
								console.error(
									'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
								);
								return;
							}
						}

						extension[methodName](
							mode,
							count,
							type,
							start * bytesPerElement,
							primcount
						);

						info.update(count, mode, primcount);
					}

					//

					this.setMode = setMode;
					this.setIndex = setIndex;
					this.render = render;
					this.renderInstances = renderInstances;
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLInfo.js":
/*!*************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLInfo.js ***!
  \*************************************************/
/*! exports provided: WebGLInfo */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLInfo", function () { return WebGLInfo; });
				function WebGLInfo(gl) {
					const memory = {
						geometries: 0,
						textures: 0
					};

					const render = {
						frame: 0,
						calls: 0,
						triangles: 0,
						points: 0,
						lines: 0
					};

					function update(count, mode, instanceCount) {
						render.calls++;

						switch (mode) {
							case gl.TRIANGLES:
								render.triangles += instanceCount * (count / 3);
								break;

							case gl.LINES:
								render.lines += instanceCount * (count / 2);
								break;

							case gl.LINE_STRIP:
								render.lines += instanceCount * (count - 1);
								break;

							case gl.LINE_LOOP:
								render.lines += instanceCount * count;
								break;

							case gl.POINTS:
								render.points += instanceCount * count;
								break;

							default:
								console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
								break;
						}
					}

					function reset() {
						render.frame++;
						render.calls = 0;
						render.triangles = 0;
						render.points = 0;
						render.lines = 0;
					}

					return {
						memory: memory,
						render: render,
						programs: null,
						autoReset: true,
						reset: reset,
						update: update
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLLights.js":
/*!***************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLLights.js ***!
  \***************************************************/
/*! exports provided: WebGLLights */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLLights", function () { return WebGLLights; });
/* harmony import */ var _math_Color_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../math/Color.js */ "./libs/three/math/Color.js");
/* harmony import */ var _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Matrix4.js */ "./libs/three/math/Matrix4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../shaders/UniformsLib.js */ "./libs/three/renderers/shaders/UniformsLib.js");






				function UniformsCache() {
					const lights = {};

					return {
						get: function (light) {
							if (lights[light.id] !== undefined) {
								return lights[light.id];
							}

							let uniforms;

							switch (light.type) {
								case 'DirectionalLight':
									uniforms = {
										direction: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
										color: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]()
									};
									break;

								case 'SpotLight':
									uniforms = {
										position: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
										direction: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
										color: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](),
										distance: 0,
										coneCos: 0,
										penumbraCos: 0,
										decay: 0
									};
									break;

								case 'PointLight':
									uniforms = {
										position: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
										color: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](),
										distance: 0,
										decay: 0
									};
									break;

								case 'HemisphereLight':
									uniforms = {
										direction: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
										skyColor: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](),
										groundColor: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"]()
									};
									break;

								case 'RectAreaLight':
									uniforms = {
										color: new _math_Color_js__WEBPACK_IMPORTED_MODULE_0__["Color"](),
										position: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
										halfWidth: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"](),
										halfHeight: new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]()
									};
									break;
							}

							lights[light.id] = uniforms;

							return uniforms;
						}
					};
				}

				function ShadowUniformsCache() {
					const lights = {};

					return {
						get: function (light) {
							if (lights[light.id] !== undefined) {
								return lights[light.id];
							}

							let uniforms;

							switch (light.type) {
								case 'DirectionalLight':
									uniforms = {
										shadowBias: 0,
										shadowNormalBias: 0,
										shadowRadius: 1,
										shadowMapSize: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]()
									};
									break;

								case 'SpotLight':
									uniforms = {
										shadowBias: 0,
										shadowNormalBias: 0,
										shadowRadius: 1,
										shadowMapSize: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"]()
									};
									break;

								case 'PointLight':
									uniforms = {
										shadowBias: 0,
										shadowNormalBias: 0,
										shadowRadius: 1,
										shadowMapSize: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_2__["Vector2"](),
										shadowCameraNear: 1,
										shadowCameraFar: 1000
									};
									break;

								// TODO (abelnation): set RectAreaLight shadow uniforms
							}

							lights[light.id] = uniforms;

							return uniforms;
						}
					};
				}

				let nextVersion = 0;

				function shadowCastingLightsFirst(lightA, lightB) {
					return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
				}

				function WebGLLights(extensions, capabilities) {
					const cache = new UniformsCache();

					const shadowCache = ShadowUniformsCache();

					const state = {
						version: 0,

						hash: {
							directionalLength: -1,
							pointLength: -1,
							spotLength: -1,
							rectAreaLength: -1,
							hemiLength: -1,

							numDirectionalShadows: -1,
							numPointShadows: -1,
							numSpotShadows: -1
						},

						ambient: [0, 0, 0],
						probe: [],
						directional: [],
						directionalShadow: [],
						directionalShadowMap: [],
						directionalShadowMatrix: [],
						spot: [],
						spotShadow: [],
						spotShadowMap: [],
						spotShadowMatrix: [],
						rectArea: [],
						rectAreaLTC1: null,
						rectAreaLTC2: null,
						point: [],
						pointShadow: [],
						pointShadowMap: [],
						pointShadowMatrix: [],
						hemi: []
					};

					for (let i = 0; i < 9; i++) state.probe.push(new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]());

					const vector3 = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_3__["Vector3"]();
					const matrix4 = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();
					const matrix42 = new _math_Matrix4_js__WEBPACK_IMPORTED_MODULE_1__["Matrix4"]();

					function setup(lights, physicallyCorrectLights) {
						let r = 0,
							g = 0,
							b = 0;

						for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);

						let directionalLength = 0;
						let pointLength = 0;
						let spotLength = 0;
						let rectAreaLength = 0;
						let hemiLength = 0;

						let numDirectionalShadows = 0;
						let numPointShadows = 0;
						let numSpotShadows = 0;

						lights.sort(shadowCastingLightsFirst);

						// artist-friendly light intensity scaling factor
						const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1;

						for (let i = 0, l = lights.length; i < l; i++) {
							const light = lights[i];

							const color = light.color;
							const intensity = light.intensity;
							const distance = light.distance;

							const shadowMap =
								light.shadow && light.shadow.map ? light.shadow.map.texture : null;

							if (light.isAmbientLight) {
								r += color.r * intensity * scaleFactor;
								g += color.g * intensity * scaleFactor;
								b += color.b * intensity * scaleFactor;
							} else if (light.isLightProbe) {
								for (let j = 0; j < 9; j++) {
									state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
								}
							} else if (light.isDirectionalLight) {
								const uniforms = cache.get(light);

								uniforms.color
									.copy(light.color)
									.multiplyScalar(light.intensity * scaleFactor);

								if (light.castShadow) {
									const shadow = light.shadow;

									const shadowUniforms = shadowCache.get(light);

									shadowUniforms.shadowBias = shadow.bias;
									shadowUniforms.shadowNormalBias = shadow.normalBias;
									shadowUniforms.shadowRadius = shadow.radius;
									shadowUniforms.shadowMapSize = shadow.mapSize;

									state.directionalShadow[directionalLength] = shadowUniforms;
									state.directionalShadowMap[directionalLength] = shadowMap;
									state.directionalShadowMatrix[directionalLength] =
										light.shadow.matrix;

									numDirectionalShadows++;
								}

								state.directional[directionalLength] = uniforms;

								directionalLength++;
							} else if (light.isSpotLight) {
								const uniforms = cache.get(light);

								uniforms.position.setFromMatrixPosition(light.matrixWorld);

								uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
								uniforms.distance = distance;

								uniforms.coneCos = Math.cos(light.angle);
								uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
								uniforms.decay = light.decay;

								if (light.castShadow) {
									const shadow = light.shadow;

									const shadowUniforms = shadowCache.get(light);

									shadowUniforms.shadowBias = shadow.bias;
									shadowUniforms.shadowNormalBias = shadow.normalBias;
									shadowUniforms.shadowRadius = shadow.radius;
									shadowUniforms.shadowMapSize = shadow.mapSize;

									state.spotShadow[spotLength] = shadowUniforms;
									state.spotShadowMap[spotLength] = shadowMap;
									state.spotShadowMatrix[spotLength] = light.shadow.matrix;

									numSpotShadows++;
								}

								state.spot[spotLength] = uniforms;

								spotLength++;
							} else if (light.isRectAreaLight) {
								const uniforms = cache.get(light);

								// (a) intensity is the total visible light emitted
								//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

								// (b) intensity is the brightness of the light
								uniforms.color.copy(color).multiplyScalar(intensity);

								uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
								uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

								state.rectArea[rectAreaLength] = uniforms;

								rectAreaLength++;
							} else if (light.isPointLight) {
								const uniforms = cache.get(light);

								uniforms.color
									.copy(light.color)
									.multiplyScalar(light.intensity * scaleFactor);
								uniforms.distance = light.distance;
								uniforms.decay = light.decay;

								if (light.castShadow) {
									const shadow = light.shadow;

									const shadowUniforms = shadowCache.get(light);

									shadowUniforms.shadowBias = shadow.bias;
									shadowUniforms.shadowNormalBias = shadow.normalBias;
									shadowUniforms.shadowRadius = shadow.radius;
									shadowUniforms.shadowMapSize = shadow.mapSize;
									shadowUniforms.shadowCameraNear = shadow.camera.near;
									shadowUniforms.shadowCameraFar = shadow.camera.far;

									state.pointShadow[pointLength] = shadowUniforms;
									state.pointShadowMap[pointLength] = shadowMap;
									state.pointShadowMatrix[pointLength] = light.shadow.matrix;

									numPointShadows++;
								}

								state.point[pointLength] = uniforms;

								pointLength++;
							} else if (light.isHemisphereLight) {
								const uniforms = cache.get(light);

								uniforms.skyColor
									.copy(light.color)
									.multiplyScalar(intensity * scaleFactor);
								uniforms.groundColor
									.copy(light.groundColor)
									.multiplyScalar(intensity * scaleFactor);

								state.hemi[hemiLength] = uniforms;

								hemiLength++;
							}
						}

						if (rectAreaLength > 0) {
							if (capabilities.isWebGL2) {
								// WebGL 2

								state.rectAreaLTC1 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_FLOAT_1;
								state.rectAreaLTC2 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_FLOAT_2;
							} else {
								// WebGL 1

								if (extensions.has('OES_texture_float_linear') === true) {
									state.rectAreaLTC1 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_FLOAT_1;
									state.rectAreaLTC2 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_FLOAT_2;
								} else if (extensions.has('OES_texture_half_float_linear') === true) {
									state.rectAreaLTC1 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_HALF_1;
									state.rectAreaLTC2 = _shaders_UniformsLib_js__WEBPACK_IMPORTED_MODULE_4__["UniformsLib"].LTC_HALF_2;
								} else {
									console.error(
										'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.'
									);
								}
							}
						}

						state.ambient[0] = r;
						state.ambient[1] = g;
						state.ambient[2] = b;

						const hash = state.hash;

						if (
							hash.directionalLength !== directionalLength ||
							hash.pointLength !== pointLength ||
							hash.spotLength !== spotLength ||
							hash.rectAreaLength !== rectAreaLength ||
							hash.hemiLength !== hemiLength ||
							hash.numDirectionalShadows !== numDirectionalShadows ||
							hash.numPointShadows !== numPointShadows ||
							hash.numSpotShadows !== numSpotShadows
						) {
							state.directional.length = directionalLength;
							state.spot.length = spotLength;
							state.rectArea.length = rectAreaLength;
							state.point.length = pointLength;
							state.hemi.length = hemiLength;

							state.directionalShadow.length = numDirectionalShadows;
							state.directionalShadowMap.length = numDirectionalShadows;
							state.pointShadow.length = numPointShadows;
							state.pointShadowMap.length = numPointShadows;
							state.spotShadow.length = numSpotShadows;
							state.spotShadowMap.length = numSpotShadows;
							state.directionalShadowMatrix.length = numDirectionalShadows;
							state.pointShadowMatrix.length = numPointShadows;
							state.spotShadowMatrix.length = numSpotShadows;

							hash.directionalLength = directionalLength;
							hash.pointLength = pointLength;
							hash.spotLength = spotLength;
							hash.rectAreaLength = rectAreaLength;
							hash.hemiLength = hemiLength;

							hash.numDirectionalShadows = numDirectionalShadows;
							hash.numPointShadows = numPointShadows;
							hash.numSpotShadows = numSpotShadows;

							state.version = nextVersion++;
						}
					}

					function setupView(lights, camera) {
						let directionalLength = 0;
						let pointLength = 0;
						let spotLength = 0;
						let rectAreaLength = 0;
						let hemiLength = 0;

						const viewMatrix = camera.matrixWorldInverse;

						for (let i = 0, l = lights.length; i < l; i++) {
							const light = lights[i];

							if (light.isDirectionalLight) {
								const uniforms = state.directional[directionalLength];

								uniforms.direction.setFromMatrixPosition(light.matrixWorld);
								vector3.setFromMatrixPosition(light.target.matrixWorld);
								uniforms.direction.sub(vector3);
								uniforms.direction.transformDirection(viewMatrix);

								directionalLength++;
							} else if (light.isSpotLight) {
								const uniforms = state.spot[spotLength];

								uniforms.position.setFromMatrixPosition(light.matrixWorld);
								uniforms.position.applyMatrix4(viewMatrix);

								uniforms.direction.setFromMatrixPosition(light.matrixWorld);
								vector3.setFromMatrixPosition(light.target.matrixWorld);
								uniforms.direction.sub(vector3);
								uniforms.direction.transformDirection(viewMatrix);

								spotLength++;
							} else if (light.isRectAreaLight) {
								const uniforms = state.rectArea[rectAreaLength];

								uniforms.position.setFromMatrixPosition(light.matrixWorld);
								uniforms.position.applyMatrix4(viewMatrix);

								// extract local rotation of light to derive width/height half vectors
								matrix42.identity();
								matrix4.copy(light.matrixWorld);
								matrix4.premultiply(viewMatrix);
								matrix42.extractRotation(matrix4);

								uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
								uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);

								uniforms.halfWidth.applyMatrix4(matrix42);
								uniforms.halfHeight.applyMatrix4(matrix42);

								rectAreaLength++;
							} else if (light.isPointLight) {
								const uniforms = state.point[pointLength];

								uniforms.position.setFromMatrixPosition(light.matrixWorld);
								uniforms.position.applyMatrix4(viewMatrix);

								pointLength++;
							} else if (light.isHemisphereLight) {
								const uniforms = state.hemi[hemiLength];

								uniforms.direction.setFromMatrixPosition(light.matrixWorld);
								uniforms.direction.transformDirection(viewMatrix);
								uniforms.direction.normalize();

								hemiLength++;
							}
						}
					}

					return {
						setup: setup,
						setupView: setupView,
						state: state
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLMaterials.js":
/*!******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLMaterials.js ***!
  \******************************************************/
/*! exports provided: WebGLMaterials */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMaterials", function () { return WebGLMaterials; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");


				function WebGLMaterials(properties) {
					function refreshFogUniforms(uniforms, fog) {
						uniforms.fogColor.value.copy(fog.color);

						if (fog.isFog) {
							uniforms.fogNear.value = fog.near;
							uniforms.fogFar.value = fog.far;
						} else if (fog.isFogExp2) {
							uniforms.fogDensity.value = fog.density;
						}
					}

					function refreshMaterialUniforms(
						uniforms,
						material,
						pixelRatio,
						height,
						transmissionRenderTarget
					) {
						if (material.isMeshBasicMaterial) {
							refreshUniformsCommon(uniforms, material);
						} else if (material.isMeshLambertMaterial) {
							refreshUniformsCommon(uniforms, material);
							refreshUniformsLambert(uniforms, material);
						} else if (material.isMeshToonMaterial) {
							refreshUniformsCommon(uniforms, material);
							refreshUniformsToon(uniforms, material);
						} else if (material.isMeshPhongMaterial) {
							refreshUniformsCommon(uniforms, material);
							refreshUniformsPhong(uniforms, material);
						} else if (material.isMeshStandardMaterial) {
							refreshUniformsCommon(uniforms, material);

							if (material.isMeshPhysicalMaterial) {
								refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
							} else {
								refreshUniformsStandard(uniforms, material);
							}
						} else if (material.isMeshMatcapMaterial) {
							refreshUniformsCommon(uniforms, material);
							refreshUniformsMatcap(uniforms, material);
						} else if (material.isMeshDepthMaterial) {
							refreshUniformsCommon(uniforms, material);
							refreshUniformsDepth(uniforms, material);
						} else if (material.isMeshDistanceMaterial) {
							refreshUniformsCommon(uniforms, material);
							refreshUniformsDistance(uniforms, material);
						} else if (material.isMeshNormalMaterial) {
							refreshUniformsCommon(uniforms, material);
							refreshUniformsNormal(uniforms, material);
						} else if (material.isLineBasicMaterial) {
							refreshUniformsLine(uniforms, material);

							if (material.isLineDashedMaterial) {
								refreshUniformsDash(uniforms, material);
							}
						} else if (material.isPointsMaterial) {
							refreshUniformsPoints(uniforms, material, pixelRatio, height);
						} else if (material.isSpriteMaterial) {
							refreshUniformsSprites(uniforms, material);
						} else if (material.isShadowMaterial) {
							uniforms.color.value.copy(material.color);
							uniforms.opacity.value = material.opacity;
						} else if (material.isShaderMaterial) {
							material.uniformsNeedUpdate = false; // #15581
						}
					}

					function refreshUniformsCommon(uniforms, material) {
						uniforms.opacity.value = material.opacity;

						if (material.color) {
							uniforms.diffuse.value.copy(material.color);
						}

						if (material.emissive) {
							uniforms.emissive.value
								.copy(material.emissive)
								.multiplyScalar(material.emissiveIntensity);
						}

						if (material.map) {
							uniforms.map.value = material.map;
						}

						if (material.alphaMap) {
							uniforms.alphaMap.value = material.alphaMap;
						}

						if (material.specularMap) {
							uniforms.specularMap.value = material.specularMap;
						}

						if (material.alphaTest > 0) {
							uniforms.alphaTest.value = material.alphaTest;
						}

						const envMap = properties.get(material).envMap;

						if (envMap) {
							uniforms.envMap.value = envMap;

							uniforms.flipEnvMap.value =
								envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;

							uniforms.reflectivity.value = material.reflectivity;
							uniforms.ior.value = material.ior;
							uniforms.refractionRatio.value = material.refractionRatio;

							const maxMipLevel = properties.get(envMap).__maxMipLevel;

							if (maxMipLevel !== undefined) {
								uniforms.maxMipLevel.value = maxMipLevel;
							}
						}

						if (material.lightMap) {
							uniforms.lightMap.value = material.lightMap;
							uniforms.lightMapIntensity.value = material.lightMapIntensity;
						}

						if (material.aoMap) {
							uniforms.aoMap.value = material.aoMap;
							uniforms.aoMapIntensity.value = material.aoMapIntensity;
						}

						// uv repeat and offset setting priorities
						// 1. color map
						// 2. specular map
						// 3. displacementMap map
						// 4. normal map
						// 5. bump map
						// 6. roughnessMap map
						// 7. metalnessMap map
						// 8. alphaMap map
						// 9. emissiveMap map
						// 10. clearcoat map
						// 11. clearcoat normal map
						// 12. clearcoat roughnessMap map
						// 13. specular intensity map
						// 14. specular tint map
						// 15. transmission map
						// 16. thickness map

						let uvScaleMap;

						if (material.map) {
							uvScaleMap = material.map;
						} else if (material.specularMap) {
							uvScaleMap = material.specularMap;
						} else if (material.displacementMap) {
							uvScaleMap = material.displacementMap;
						} else if (material.normalMap) {
							uvScaleMap = material.normalMap;
						} else if (material.bumpMap) {
							uvScaleMap = material.bumpMap;
						} else if (material.roughnessMap) {
							uvScaleMap = material.roughnessMap;
						} else if (material.metalnessMap) {
							uvScaleMap = material.metalnessMap;
						} else if (material.alphaMap) {
							uvScaleMap = material.alphaMap;
						} else if (material.emissiveMap) {
							uvScaleMap = material.emissiveMap;
						} else if (material.clearcoatMap) {
							uvScaleMap = material.clearcoatMap;
						} else if (material.clearcoatNormalMap) {
							uvScaleMap = material.clearcoatNormalMap;
						} else if (material.clearcoatRoughnessMap) {
							uvScaleMap = material.clearcoatRoughnessMap;
						} else if (material.specularIntensityMap) {
							uvScaleMap = material.specularIntensityMap;
						} else if (material.specularColorMap) {
							uvScaleMap = material.specularColorMap;
						} else if (material.transmissionMap) {
							uvScaleMap = material.transmissionMap;
						} else if (material.thicknessMap) {
							uvScaleMap = material.thicknessMap;
						} else if (material.sheenColorMap) {
							uvScaleMap = material.sheenColorMap;
						} else if (material.sheenRoughnessMap) {
							uvScaleMap = material.sheenRoughnessMap;
						}

						if (uvScaleMap !== undefined) {
							// backwards compatibility
							if (uvScaleMap.isWebGLRenderTarget) {
								uvScaleMap = uvScaleMap.texture;
							}

							if (uvScaleMap.matrixAutoUpdate === true) {
								uvScaleMap.updateMatrix();
							}
							//TODO
							if (uvScaleMap.matrix) {
								uniforms.uvTransform.value.copy(uvScaleMap.matrix);
							}
						}

						// uv repeat and offset setting priorities for uv2
						// 1. ao map
						// 2. light map

						let uv2ScaleMap;

						if (material.aoMap) {
							uv2ScaleMap = material.aoMap;
						} else if (material.lightMap) {
							uv2ScaleMap = material.lightMap;
						}

						if (uv2ScaleMap !== undefined) {
							// backwards compatibility
							if (uv2ScaleMap.isWebGLRenderTarget) {
								uv2ScaleMap = uv2ScaleMap.texture;
							}

							if (uv2ScaleMap.matrixAutoUpdate === true) {
								uv2ScaleMap.updateMatrix();
							}

							uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
						}
					}

					function refreshUniformsLine(uniforms, material) {
						uniforms.diffuse.value.copy(material.color);
						uniforms.opacity.value = material.opacity;
					}

					function refreshUniformsDash(uniforms, material) {
						uniforms.dashSize.value = material.dashSize;
						uniforms.totalSize.value = material.dashSize + material.gapSize;
						uniforms.scale.value = material.scale;
					}

					function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
						uniforms.diffuse.value.copy(material.color);
						uniforms.opacity.value = material.opacity;
						uniforms.size.value = material.size * pixelRatio;
						uniforms.scale.value = height * 0.5;

						if (material.map) {
							uniforms.map.value = material.map;
						}

						if (material.alphaMap) {
							uniforms.alphaMap.value = material.alphaMap;
						}

						if (material.alphaTest > 0) {
							uniforms.alphaTest.value = material.alphaTest;
						}

						// uv repeat and offset setting priorities
						// 1. color map
						// 2. alpha map

						let uvScaleMap;

						if (material.map) {
							uvScaleMap = material.map;
						} else if (material.alphaMap) {
							uvScaleMap = material.alphaMap;
						}

						if (uvScaleMap !== undefined) {
							if (uvScaleMap.matrixAutoUpdate === true) {
								uvScaleMap.updateMatrix();
							}

							uniforms.uvTransform.value.copy(uvScaleMap.matrix);
						}
					}

					function refreshUniformsSprites(uniforms, material) {
						uniforms.diffuse.value.copy(material.color);
						uniforms.opacity.value = material.opacity;
						uniforms.rotation.value = material.rotation;

						if (material.map) {
							uniforms.map.value = material.map;
						}

						if (material.alphaMap) {
							uniforms.alphaMap.value = material.alphaMap;
						}

						if (material.alphaTest > 0) {
							uniforms.alphaTest.value = material.alphaTest;
						}

						// uv repeat and offset setting priorities
						// 1. color map
						// 2. alpha map

						let uvScaleMap;

						if (material.map) {
							uvScaleMap = material.map;
						} else if (material.alphaMap) {
							uvScaleMap = material.alphaMap;
						}

						if (uvScaleMap !== undefined) {
							if (uvScaleMap.matrixAutoUpdate === true) {
								uvScaleMap.updateMatrix();
							}

							uniforms.uvTransform.value.copy(uvScaleMap.matrix);
						}
					}

					function refreshUniformsLambert(uniforms, material) {
						if (material.emissiveMap) {
							uniforms.emissiveMap.value = material.emissiveMap;
						}
					}

					function refreshUniformsPhong(uniforms, material) {
						uniforms.specular.value.copy(material.specular);
						uniforms.shininess.value = Math.max(material.shininess, 1e-4); // to prevent pow( 0.0, 0.0 )

						if (material.emissiveMap) {
							uniforms.emissiveMap.value = material.emissiveMap;
						}

						if (material.bumpMap) {
							uniforms.bumpMap.value = material.bumpMap;
							uniforms.bumpScale.value = material.bumpScale;
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.bumpScale.value *= -1;
						}

						if (material.normalMap) {
							uniforms.normalMap.value = material.normalMap;
							uniforms.normalScale.value.copy(material.normalScale);
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.normalScale.value.negate();
						}

						if (material.displacementMap) {
							uniforms.displacementMap.value = material.displacementMap;
							uniforms.displacementScale.value = material.displacementScale;
							uniforms.displacementBias.value = material.displacementBias;
						}
					}

					function refreshUniformsToon(uniforms, material) {
						if (material.gradientMap) {
							uniforms.gradientMap.value = material.gradientMap;
						}

						if (material.emissiveMap) {
							uniforms.emissiveMap.value = material.emissiveMap;
						}

						if (material.bumpMap) {
							uniforms.bumpMap.value = material.bumpMap;
							uniforms.bumpScale.value = material.bumpScale;
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.bumpScale.value *= -1;
						}

						if (material.normalMap) {
							uniforms.normalMap.value = material.normalMap;
							uniforms.normalScale.value.copy(material.normalScale);
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.normalScale.value.negate();
						}

						if (material.displacementMap) {
							uniforms.displacementMap.value = material.displacementMap;
							uniforms.displacementScale.value = material.displacementScale;
							uniforms.displacementBias.value = material.displacementBias;
						}
					}

					function refreshUniformsStandard(uniforms, material) {
						uniforms.roughness.value = material.roughness;
						uniforms.metalness.value = material.metalness;

						if (material.roughnessMap) {
							uniforms.roughnessMap.value = material.roughnessMap;
						}

						if (material.metalnessMap) {
							uniforms.metalnessMap.value = material.metalnessMap;
						}

						if (material.emissiveMap) {
							uniforms.emissiveMap.value = material.emissiveMap;
						}

						if (material.bumpMap) {
							uniforms.bumpMap.value = material.bumpMap;
							uniforms.bumpScale.value = material.bumpScale;
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.bumpScale.value *= -1;
						}

						if (material.normalMap) {
							uniforms.normalMap.value = material.normalMap;
							uniforms.normalScale.value.copy(material.normalScale);
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.normalScale.value.negate();
						}

						if (material.displacementMap) {
							uniforms.displacementMap.value = material.displacementMap;
							uniforms.displacementScale.value = material.displacementScale;
							uniforms.displacementBias.value = material.displacementBias;
						}

						const envMap = properties.get(material).envMap;

						if (envMap) {
							//uniforms.envMap.value = material.envMap; // part of uniforms common
							uniforms.envMapIntensity.value = material.envMapIntensity;
						}
					}

					function refreshUniformsPhysical(
						uniforms,
						material,
						transmissionRenderTarget
					) {
						refreshUniformsStandard(uniforms, material);

						uniforms.ior.value = material.ior; // also part of uniforms common

						if (material.sheen > 0) {
							uniforms.sheenColor.value
								.copy(material.sheenColor)
								.multiplyScalar(material.sheen);

							uniforms.sheenRoughness.value = material.sheenRoughness;

							if (material.sheenColorMap) {
								uniforms.sheenColorMap.value = material.sheenColorMap;
							}

							if (material.sheenRoughnessMap) {
								uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
							}
						}

						if (material.clearcoat > 0) {
							uniforms.clearcoat.value = material.clearcoat;
							uniforms.clearcoatRoughness.value = material.clearcoatRoughness;

							if (material.clearcoatMap) {
								uniforms.clearcoatMap.value = material.clearcoatMap;
							}

							if (material.clearcoatRoughnessMap) {
								uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
							}

							if (material.clearcoatNormalMap) {
								uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
								uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

								if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) {
									uniforms.clearcoatNormalScale.value.negate();
								}
							}
						}

						if (material.transmission > 0) {
							uniforms.transmission.value = material.transmission;
							uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
							uniforms.transmissionSamplerSize.value.set(
								transmissionRenderTarget.width,
								transmissionRenderTarget.height
							);

							if (material.transmissionMap) {
								uniforms.transmissionMap.value = material.transmissionMap;
							}

							uniforms.thickness.value = material.thickness;

							if (material.thicknessMap) {
								uniforms.thicknessMap.value = material.thicknessMap;
							}

							uniforms.attenuationDistance.value = material.attenuationDistance;
							uniforms.attenuationColor.value.copy(material.attenuationColor);
						}

						uniforms.specularIntensity.value = material.specularIntensity;
						uniforms.specularColor.value.copy(material.specularColor);

						if (material.specularIntensityMap) {
							uniforms.specularIntensityMap.value = material.specularIntensityMap;
						}

						if (material.specularColorMap) {
							uniforms.specularColorMap.value = material.specularColorMap;
						}
					}

					function refreshUniformsMatcap(uniforms, material) {
						if (material.matcap) {
							uniforms.matcap.value = material.matcap;
						}

						if (material.bumpMap) {
							uniforms.bumpMap.value = material.bumpMap;
							uniforms.bumpScale.value = material.bumpScale;
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.bumpScale.value *= -1;
						}

						if (material.normalMap) {
							uniforms.normalMap.value = material.normalMap;
							uniforms.normalScale.value.copy(material.normalScale);
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.normalScale.value.negate();
						}

						if (material.displacementMap) {
							uniforms.displacementMap.value = material.displacementMap;
							uniforms.displacementScale.value = material.displacementScale;
							uniforms.displacementBias.value = material.displacementBias;
						}
					}

					function refreshUniformsDepth(uniforms, material) {
						if (material.displacementMap) {
							uniforms.displacementMap.value = material.displacementMap;
							uniforms.displacementScale.value = material.displacementScale;
							uniforms.displacementBias.value = material.displacementBias;
						}
					}

					function refreshUniformsDistance(uniforms, material) {
						if (material.displacementMap) {
							uniforms.displacementMap.value = material.displacementMap;
							uniforms.displacementScale.value = material.displacementScale;
							uniforms.displacementBias.value = material.displacementBias;
						}

						uniforms.referencePosition.value.copy(material.referencePosition);
						uniforms.nearDistance.value = material.nearDistance;
						uniforms.farDistance.value = material.farDistance;
					}

					function refreshUniformsNormal(uniforms, material) {
						if (material.bumpMap) {
							uniforms.bumpMap.value = material.bumpMap;
							uniforms.bumpScale.value = material.bumpScale;
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.bumpScale.value *= -1;
						}

						if (material.normalMap) {
							uniforms.normalMap.value = material.normalMap;
							uniforms.normalScale.value.copy(material.normalScale);
							if (material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"]) uniforms.normalScale.value.negate();
						}

						if (material.displacementMap) {
							uniforms.displacementMap.value = material.displacementMap;
							uniforms.displacementScale.value = material.displacementScale;
							uniforms.displacementBias.value = material.displacementBias;
						}
					}

					return {
						refreshFogUniforms: refreshFogUniforms,
						refreshMaterialUniforms: refreshMaterialUniforms
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLMorphtargets.js":
/*!*********************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLMorphtargets.js ***!
  \*********************************************************/
/*! exports provided: WebGLMorphtargets */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMorphtargets", function () { return WebGLMorphtargets; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _textures_DataTexture2DArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../textures/DataTexture2DArray.js */ "./libs/three/textures/DataTexture2DArray.js");
/* harmony import */ var _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/Vector3.js */ "./libs/three/math/Vector3.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../math/Vector2.js */ "./libs/three/math/Vector2.js");





				function numericalSort(a, b) {
					return a[0] - b[0];
				}

				function absNumericalSort(a, b) {
					return Math.abs(b[1]) - Math.abs(a[1]);
				}

				function denormalize(morph, attribute) {
					let denominator = 1;
					const array = attribute.isInterleavedBufferAttribute
						? attribute.data.array
						: attribute.array;

					if (array instanceof Int8Array) denominator = 127;
					else if (array instanceof Int16Array) denominator = 32767;
					else if (array instanceof Int32Array) denominator = 2147483647;
					else
						console.error(
							'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ',
							array
						);

					morph.divideScalar(denominator);
				}

				function WebGLMorphtargets(gl, capabilities, textures) {
					const influencesList = {};
					const morphInfluences = new Float32Array(8);
					const morphTextures = new WeakMap();
					const morph = new _math_Vector3_js__WEBPACK_IMPORTED_MODULE_2__["Vector3"]();

					const workInfluences = [];

					for (let i = 0; i < 8; i++) {
						workInfluences[i] = [i, 0];
					}

					function update(object, geometry, material, program) {
						const objectInfluences = object.morphTargetInfluences;

						if (capabilities.isWebGL2 === true) {
							// instead of using attributes, the WebGL 2 code path encodes morph targets
							// into an array of data textures. Each layer represents a single morph target.

							const numberOfMorphTargets = geometry.morphAttributes.position.length;

							let entry = morphTextures.get(geometry);

							if (entry === undefined || entry.count !== numberOfMorphTargets) {
								if (entry !== undefined) entry.texture.dispose();

								const hasMorphNormals = geometry.morphAttributes.normal !== undefined;

								const morphTargets = geometry.morphAttributes.position;
								const morphNormals = geometry.morphAttributes.normal || [];

								const numberOfVertices = geometry.attributes.position.count;
								const numberOfVertexData = hasMorphNormals === true ? 2 : 1; // (v,n) vs. (v)

								let width = numberOfVertices * numberOfVertexData;
								let height = 1;

								if (width > capabilities.maxTextureSize) {
									height = Math.ceil(width / capabilities.maxTextureSize);
									width = capabilities.maxTextureSize;
								}

								const buffer = new Float32Array(
									width * height * 4 * numberOfMorphTargets
								);

								const texture = new _textures_DataTexture2DArray_js__WEBPACK_IMPORTED_MODULE_1__["DataTexture2DArray"](
									buffer,
									width,
									height,
									numberOfMorphTargets
								);
								texture.format = _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"]; // using RGBA since RGB might be emulated (and is thus slower)
								texture.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"];

								// fill buffer

								const vertexDataStride = numberOfVertexData * 4;

								for (let i = 0; i < numberOfMorphTargets; i++) {
									const morphTarget = morphTargets[i];
									const morphNormal = morphNormals[i];

									const offset = width * height * 4 * i;

									for (let j = 0; j < morphTarget.count; j++) {
										morph.fromBufferAttribute(morphTarget, j);

										if (morphTarget.normalized === true)
											denormalize(morph, morphTarget);

										const stride = j * vertexDataStride;

										buffer[offset + stride + 0] = morph.x;
										buffer[offset + stride + 1] = morph.y;
										buffer[offset + stride + 2] = morph.z;
										buffer[offset + stride + 3] = 0;

										if (hasMorphNormals === true) {
											morph.fromBufferAttribute(morphNormal, j);

											if (morphNormal.normalized === true)
												denormalize(morph, morphNormal);

											buffer[offset + stride + 4] = morph.x;
											buffer[offset + stride + 5] = morph.y;
											buffer[offset + stride + 6] = morph.z;
											buffer[offset + stride + 7] = 0;
										}
									}
								}

								entry = {
									count: numberOfMorphTargets,
									texture: texture,
									size: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"](width, height)
								};

								morphTextures.set(geometry, entry);
							}

							//

							let morphInfluencesSum = 0;

							for (let i = 0; i < objectInfluences.length; i++) {
								morphInfluencesSum += objectInfluences[i];
							}

							const morphBaseInfluence = geometry.morphTargetsRelative
								? 1
								: 1 - morphInfluencesSum;

							program
								.getUniforms()
								.setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
							program
								.getUniforms()
								.setValue(gl, 'morphTargetInfluences', objectInfluences);

							program
								.getUniforms()
								.setValue(gl, 'morphTargetsTexture', entry.texture, textures);
							program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);
						} else {
							// When object doesn't have morph target influences defined, we treat it as a 0-length array
							// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

							const length =
								objectInfluences === undefined ? 0 : objectInfluences.length;

							let influences = influencesList[geometry.id];

							if (influences === undefined || influences.length !== length) {
								// initialise list

								influences = [];

								for (let i = 0; i < length; i++) {
									influences[i] = [i, 0];
								}

								influencesList[geometry.id] = influences;
							}

							// Collect influences

							for (let i = 0; i < length; i++) {
								const influence = influences[i];

								influence[0] = i;
								influence[1] = objectInfluences[i];
							}

							influences.sort(absNumericalSort);

							for (let i = 0; i < 8; i++) {
								if (i < length && influences[i][1]) {
									workInfluences[i][0] = influences[i][0];
									workInfluences[i][1] = influences[i][1];
								} else {
									workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
									workInfluences[i][1] = 0;
								}
							}

							workInfluences.sort(numericalSort);

							const morphTargets = geometry.morphAttributes.position;
							const morphNormals = geometry.morphAttributes.normal;

							let morphInfluencesSum = 0;

							for (let i = 0; i < 8; i++) {
								const influence = workInfluences[i];
								const index = influence[0];
								const value = influence[1];

								if (index !== Number.MAX_SAFE_INTEGER && value) {
									if (
										morphTargets &&
										geometry.getAttribute('morphTarget' + i) !== morphTargets[index]
									) {
										geometry.setAttribute('morphTarget' + i, morphTargets[index]);
									}

									if (
										morphNormals &&
										geometry.getAttribute('morphNormal' + i) !== morphNormals[index]
									) {
										geometry.setAttribute('morphNormal' + i, morphNormals[index]);
									}

									morphInfluences[i] = value;
									morphInfluencesSum += value;
								} else {
									if (
										morphTargets &&
										geometry.hasAttribute('morphTarget' + i) === true
									) {
										geometry.deleteAttribute('morphTarget' + i);
									}

									if (
										morphNormals &&
										geometry.hasAttribute('morphNormal' + i) === true
									) {
										geometry.deleteAttribute('morphNormal' + i);
									}

									morphInfluences[i] = 0;
								}
							}

							// GLSL shader uses formula baseinfluence * base + sum(target * influence)
							// This allows us to switch between absolute morphs and relative morphs without changing shader code
							// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
							const morphBaseInfluence = geometry.morphTargetsRelative
								? 1
								: 1 - morphInfluencesSum;

							program
								.getUniforms()
								.setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
							program
								.getUniforms()
								.setValue(gl, 'morphTargetInfluences', morphInfluences);
						}
					}

					return {
						update: update
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLObjects.js":
/*!****************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLObjects.js ***!
  \****************************************************/
/*! exports provided: WebGLObjects */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLObjects", function () { return WebGLObjects; });
				function WebGLObjects(gl, geometries, attributes, info) {
					let updateMap = new WeakMap();

					function update(object) {
						const frame = info.render.frame;

						const geometry = object.geometry;
						const buffergeometry = geometries.get(object, geometry);

						// Update once per frame

						if (updateMap.get(buffergeometry) !== frame) {
							geometries.update(buffergeometry);

							updateMap.set(buffergeometry, frame);
						}

						if (object.isInstancedMesh) {
							if (
								object.hasEventListener('dispose', onInstancedMeshDispose) === false
							) {
								object.addEventListener('dispose', onInstancedMeshDispose);
							}

							attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);

							if (object.instanceColor !== null) {
								attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
							}
						}

						return buffergeometry;
					}

					function dispose() {
						updateMap = new WeakMap();
					}

					function onInstancedMeshDispose(event) {
						const instancedMesh = event.target;

						instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);

						attributes.remove(instancedMesh.instanceMatrix);

						if (instancedMesh.instanceColor !== null)
							attributes.remove(instancedMesh.instanceColor);
					}

					return {
						update: update,
						dispose: dispose
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLProgram.js":
/*!****************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLProgram.js ***!
  \****************************************************/
/*! exports provided: WebGLProgram */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLProgram", function () { return WebGLProgram; });
/* harmony import */ var _WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLUniforms.js */ "./libs/three/renderers/webgl/WebGLUniforms.js");
/* harmony import */ var _WebGLShader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGLShader.js */ "./libs/three/renderers/webgl/WebGLShader.js");
/* harmony import */ var _shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders/ShaderChunk.js */ "./libs/three/renderers/shaders/ShaderChunk.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");





				let programIdCount = 0;

				function addLineNumbers(string) {
					const lines = string.split('\n');

					for (let i = 0; i < lines.length; i++) {
						lines[i] = i + 1 + ': ' + lines[i];
					}

					return lines.join('\n');
				}

				function getEncodingComponents(encoding) {
					switch (encoding) {
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["LinearEncoding"]:
							return ['Linear', '( value )'];
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["sRGBEncoding"]:
							return ['sRGB', '( value )'];
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBEEncoding"]:
							return ['RGBE', '( value )'];
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBM7Encoding"]:
							return ['RGBM', '( value, 7.0 )'];
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBM16Encoding"]:
							return ['RGBM', '( value, 16.0 )'];
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBDEncoding"]:
							return ['RGBD', '( value, 256.0 )'];
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["GammaEncoding"]:
							return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["LogLuvEncoding"]:
							return ['LogLuv', '( value )'];
						default:
							console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding);
							return ['Linear', '( value )'];
					}
				}

				function getShaderErrors(gl, shader, type) {
					const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
					const errors = gl.getShaderInfoLog(shader).trim();

					if (status && errors === '') return '';

					// --enable-privileged-webgl-extension
					// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

					return (
						type.toUpperCase() +
						'\n\n' +
						errors +
						'\n\n' +
						addLineNumbers(gl.getShaderSource(shader))
					);
				}

				function getTexelDecodingFunction(functionName, encoding) {
					const components = getEncodingComponents(encoding);
					return (
						'vec4 ' +
						functionName +
						'( vec4 value ) { return ' +
						components[0] +
						'ToLinear' +
						components[1] +
						'; }'
					);
				}

				function getTexelEncodingFunction(functionName, encoding) {
					const components = getEncodingComponents(encoding);
					return (
						'vec4 ' +
						functionName +
						'( vec4 value ) { return LinearTo' +
						components[0] +
						components[1] +
						'; }'
					);
				}

				function getToneMappingFunction(functionName, toneMapping) {
					let toneMappingName;

					switch (toneMapping) {
						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["LinearToneMapping"]:
							toneMappingName = 'Linear';
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["ReinhardToneMapping"]:
							toneMappingName = 'Reinhard';
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CineonToneMapping"]:
							toneMappingName = 'OptimizedCineon';
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["ACESFilmicToneMapping"]:
							toneMappingName = 'ACESFilmic';
							break;

						case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CustomToneMapping"]:
							toneMappingName = 'Custom';
							break;

						default:
							console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
							toneMappingName = 'Linear';
					}

					return (
						'vec3 ' +
						functionName +
						'( vec3 color ) { return ' +
						toneMappingName +
						'ToneMapping( color ); }'
					);
				}

				function generateExtensions(parameters) {
					const chunks = [
						parameters.extensionDerivatives ||
							parameters.envMapCubeUV ||
							parameters.bumpMap ||
							parameters.tangentSpaceNormalMap ||
							parameters.clearcoatNormalMap ||
							parameters.flatShading ||
							parameters.shaderID === 'physical'
							? '#extension GL_OES_standard_derivatives : enable'
							: '',
						(parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) &&
							parameters.rendererExtensionFragDepth
							? '#extension GL_EXT_frag_depth : enable'
							: '',
						parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers
							? '#extension GL_EXT_draw_buffers : require'
							: '',
						(parameters.extensionShaderTextureLOD ||
							parameters.envMap ||
							parameters.transmission) &&
							parameters.rendererExtensionShaderTextureLod
							? '#extension GL_EXT_shader_texture_lod : enable'
							: ''
					];

					return chunks.filter(filterEmptyLine).join('\n');
				}

				function generateDefines(defines) {
					const chunks = [];

					for (const name in defines) {
						const value = defines[name];

						if (value === false) continue;

						chunks.push('#define ' + name + ' ' + value);
					}

					return chunks.join('\n');
				}

				function fetchAttributeLocations(gl, program) {
					const attributes = {};

					const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

					for (let i = 0; i < n; i++) {
						const info = gl.getActiveAttrib(program, i);
						const name = info.name;

						let locationSize = 1;
						if (info.type === gl.FLOAT_MAT2) locationSize = 2;
						if (info.type === gl.FLOAT_MAT3) locationSize = 3;
						if (info.type === gl.FLOAT_MAT4) locationSize = 4;

						// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

						attributes[name] = {
							type: info.type,
							location: gl.getAttribLocation(program, name),
							locationSize: locationSize
						};
					}

					return attributes;
				}

				function filterEmptyLine(string) {
					return string !== '';
				}

				function replaceLightNums(string, parameters) {
					return string
						.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
						.replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
						.replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
						.replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
						.replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
						.replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
						.replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
						.replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
				}

				function replaceClippingPlaneNums(string, parameters) {
					return string
						.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
						.replace(
							/UNION_CLIPPING_PLANES/g,
							parameters.numClippingPlanes - parameters.numClipIntersection
						);
				}

				// Resolve Includes

				const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

				function resolveIncludes(string) {
					return string.replace(includePattern, includeReplacer);
				}

				function includeReplacer(match, include) {
					const string = _shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_2__["ShaderChunk"][include];

					if (string === undefined) {
						throw new Error('Can not resolve #include <' + include + '>');
					}

					return resolveIncludes(string);
				}

				// Unroll Loops

				const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
				const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

				function unrollLoops(string) {
					return string
						.replace(unrollLoopPattern, loopReplacer)
						.replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);
				}

				function deprecatedLoopReplacer(match, start, end, snippet) {
					console.warn(
						'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.'
					);
					return loopReplacer(match, start, end, snippet);
				}

				function loopReplacer(match, start, end, snippet) {
					let string = '';

					for (let i = parseInt(start); i < parseInt(end); i++) {
						string += snippet
							.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]')
							.replace(/UNROLLED_LOOP_INDEX/g, i);
					}

					return string;
				}

				//

				function generatePrecision(parameters) {
					let precisionstring =
						'precision ' +
						parameters.precision +
						' float;\nprecision ' +
						parameters.precision +
						' int;';

					if (parameters.precision === 'highp') {
						precisionstring += '\n#define HIGH_PRECISION';
					} else if (parameters.precision === 'mediump') {
						precisionstring += '\n#define MEDIUM_PRECISION';
					} else if (parameters.precision === 'lowp') {
						precisionstring += '\n#define LOW_PRECISION';
					}

					return precisionstring;
				}

				function generateShadowMapTypeDefine(parameters) {
					let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

					if (parameters.shadowMapType === _constants_js__WEBPACK_IMPORTED_MODULE_3__["PCFShadowMap"]) {
						shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
					} else if (parameters.shadowMapType === _constants_js__WEBPACK_IMPORTED_MODULE_3__["PCFSoftShadowMap"]) {
						shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
					} else if (parameters.shadowMapType === _constants_js__WEBPACK_IMPORTED_MODULE_3__["VSMShadowMap"]) {
						shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';
					}

					return shadowMapTypeDefine;
				}

				function generateEnvMapTypeDefine(parameters) {
					let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

					if (parameters.envMap) {
						switch (parameters.envMapMode) {
							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeReflectionMapping"]:
							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeRefractionMapping"]:
								envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeUVReflectionMapping"]:
							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeUVRefractionMapping"]:
								envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
								break;
						}
					}

					return envMapTypeDefine;
				}

				function generateEnvMapModeDefine(parameters) {
					let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

					if (parameters.envMap) {
						switch (parameters.envMapMode) {
							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeRefractionMapping"]:
							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["CubeUVRefractionMapping"]:
								envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
								break;
						}
					}

					return envMapModeDefine;
				}

				function generateEnvMapBlendingDefine(parameters) {
					let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

					if (parameters.envMap) {
						switch (parameters.combine) {
							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["MultiplyOperation"]:
								envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["MixOperation"]:
								envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
								break;

							case _constants_js__WEBPACK_IMPORTED_MODULE_3__["AddOperation"]:
								envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
								break;
						}
					}

					return envMapBlendingDefine;
				}

				function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
					// TODO Send this event to Three.js DevTools
					// console.log( 'WebGLProgram', cacheKey );

					const gl = renderer.getContext();

					const defines = parameters.defines;

					let vertexShader = parameters.vertexShader;
					let fragmentShader = parameters.fragmentShader;

					const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
					const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
					const envMapModeDefine = generateEnvMapModeDefine(parameters);
					const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);

					const gammaFactorDefine =
						renderer.gammaFactor > 0 ? renderer.gammaFactor : 1.0;

					const customExtensions = parameters.isWebGL2
						? ''
						: generateExtensions(parameters);

					const customDefines = generateDefines(defines);

					const program = gl.createProgram();

					let prefixVertex, prefixFragment;
					let versionString = parameters.glslVersion
						? '#version ' + parameters.glslVersion + '\n'
						: '';

					if (parameters.isRawShaderMaterial) {
						prefixVertex = [customDefines].filter(filterEmptyLine).join('\n');

						if (prefixVertex.length > 0) {
							prefixVertex += '\n';
						}

						prefixFragment = [customExtensions, customDefines]
							.filter(filterEmptyLine)
							.join('\n');

						if (prefixFragment.length > 0) {
							prefixFragment += '\n';
						}
					} else {
						prefixVertex = [
							generatePrecision(parameters),

							'#define SHADER_NAME ' + parameters.shaderName,

							customDefines,

							parameters.instancing ? '#define USE_INSTANCING' : '',
							parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

							parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

							'#define GAMMA_FACTOR ' + gammaFactorDefine,

							'#define MAX_BONES ' + parameters.maxBones,
							parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
							parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

							parameters.map ? '#define USE_MAP' : '',
							parameters.envMap ? '#define USE_ENVMAP' : '',
							parameters.envMap ? '#define ' + envMapModeDefine : '',
							parameters.lightMap ? '#define USE_LIGHTMAP' : '',
							parameters.aoMap ? '#define USE_AOMAP' : '',
							parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
							parameters.bumpMap ? '#define USE_BUMPMAP' : '',
							parameters.normalMap ? '#define USE_NORMALMAP' : '',
							parameters.normalMap && parameters.objectSpaceNormalMap
								? '#define OBJECTSPACE_NORMALMAP'
								: '',
							parameters.normalMap && parameters.tangentSpaceNormalMap
								? '#define TANGENTSPACE_NORMALMAP'
								: '',

							parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
							parameters.clearcoatRoughnessMap
								? '#define USE_CLEARCOAT_ROUGHNESSMAP'
								: '',
							parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

							parameters.displacementMap && parameters.supportsVertexTextures
								? '#define USE_DISPLACEMENTMAP'
								: '',

							parameters.specularMap ? '#define USE_SPECULARMAP' : '',
							parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
							parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',

							parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
							parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
							parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

							parameters.transmission ? '#define USE_TRANSMISSION' : '',
							parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
							parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

							parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
							parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

							parameters.vertexTangents ? '#define USE_TANGENT' : '',
							parameters.vertexColors ? '#define USE_COLOR' : '',
							parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
							parameters.vertexUvs ? '#define USE_UV' : '',
							parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

							parameters.flatShading ? '#define FLAT_SHADED' : '',

							parameters.skinning ? '#define USE_SKINNING' : '',
							parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

							parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
							parameters.morphNormals && parameters.flatShading === false
								? '#define USE_MORPHNORMALS'
								: '',
							parameters.morphTargets && parameters.isWebGL2
								? '#define MORPHTARGETS_TEXTURE'
								: '',
							parameters.morphTargets && parameters.isWebGL2
								? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount
								: '',
							parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
							parameters.flipSided ? '#define FLIP_SIDED' : '',

							parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
							parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

							parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

							parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
							parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth
								? '#define USE_LOGDEPTHBUF_EXT'
								: '',

							'uniform mat4 modelMatrix;',
							'uniform mat4 modelViewMatrix;',
							'uniform mat4 projectionMatrix;',
							'uniform mat4 viewMatrix;',
							'uniform mat3 normalMatrix;',
							'uniform vec3 cameraPosition;',
							'uniform bool isOrthographic;',

							'#ifdef USE_INSTANCING',

							'	attribute mat4 instanceMatrix;',

							'#endif',

							'#ifdef USE_INSTANCING_COLOR',

							'	attribute vec3 instanceColor;',

							'#endif',

							'attribute vec3 position;',
							'attribute vec3 normal;',
							'attribute vec2 uv;',

							'#ifdef USE_TANGENT',

							'	attribute vec4 tangent;',

							'#endif',

							'#if defined( USE_COLOR_ALPHA )',

							'	attribute vec4 color;',

							'#elif defined( USE_COLOR )',

							'	attribute vec3 color;',

							'#endif',

							'#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',

							'	attribute vec3 morphTarget0;',
							'	attribute vec3 morphTarget1;',
							'	attribute vec3 morphTarget2;',
							'	attribute vec3 morphTarget3;',

							'	#ifdef USE_MORPHNORMALS',

							'		attribute vec3 morphNormal0;',
							'		attribute vec3 morphNormal1;',
							'		attribute vec3 morphNormal2;',
							'		attribute vec3 morphNormal3;',

							'	#else',

							'		attribute vec3 morphTarget4;',
							'		attribute vec3 morphTarget5;',
							'		attribute vec3 morphTarget6;',
							'		attribute vec3 morphTarget7;',

							'	#endif',

							'#endif',

							'#ifdef USE_SKINNING',

							'	attribute vec4 skinIndex;',
							'	attribute vec4 skinWeight;',

							'#endif',

							'\n'
						]
							.filter(filterEmptyLine)
							.join('\n');

						prefixFragment = [
							customExtensions,

							generatePrecision(parameters),

							'#define SHADER_NAME ' + parameters.shaderName,

							customDefines,

							'#define GAMMA_FACTOR ' + gammaFactorDefine,

							parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
							parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',

							parameters.map ? '#define USE_MAP' : '',
							parameters.matcap ? '#define USE_MATCAP' : '',
							parameters.envMap ? '#define USE_ENVMAP' : '',
							parameters.envMap ? '#define ' + envMapTypeDefine : '',
							parameters.envMap ? '#define ' + envMapModeDefine : '',
							parameters.envMap ? '#define ' + envMapBlendingDefine : '',
							parameters.lightMap ? '#define USE_LIGHTMAP' : '',
							parameters.aoMap ? '#define USE_AOMAP' : '',
							parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
							parameters.bumpMap ? '#define USE_BUMPMAP' : '',
							parameters.normalMap ? '#define USE_NORMALMAP' : '',
							parameters.normalMap && parameters.objectSpaceNormalMap
								? '#define OBJECTSPACE_NORMALMAP'
								: '',
							parameters.normalMap && parameters.tangentSpaceNormalMap
								? '#define TANGENTSPACE_NORMALMAP'
								: '',

							parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
							parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
							parameters.clearcoatRoughnessMap
								? '#define USE_CLEARCOAT_ROUGHNESSMAP'
								: '',
							parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',

							parameters.specularMap ? '#define USE_SPECULARMAP' : '',
							parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
							parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
							parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
							parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',

							parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
							parameters.alphaTest ? '#define USE_ALPHATEST' : '',

							parameters.sheen ? '#define USE_SHEEN' : '',
							parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
							parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',

							parameters.transmission ? '#define USE_TRANSMISSION' : '',
							parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
							parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',

							parameters.vertexTangents ? '#define USE_TANGENT' : '',
							parameters.vertexColors || parameters.instancingColor
								? '#define USE_COLOR'
								: '',
							parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
							parameters.vertexUvs ? '#define USE_UV' : '',
							parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

							parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

							parameters.flatShading ? '#define FLAT_SHADED' : '',

							parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
							parameters.flipSided ? '#define FLIP_SIDED' : '',

							parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
							parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

							parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

							parameters.physicallyCorrectLights
								? '#define PHYSICALLY_CORRECT_LIGHTS'
								: '',

							parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
							parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth
								? '#define USE_LOGDEPTHBUF_EXT'
								: '',

							(parameters.extensionShaderTextureLOD || parameters.envMap) &&
								parameters.rendererExtensionShaderTextureLod
								? '#define TEXTURE_LOD_EXT'
								: '',

							'uniform mat4 viewMatrix;',
							'uniform vec3 cameraPosition;',
							'uniform bool isOrthographic;',

							parameters.toneMapping !== _constants_js__WEBPACK_IMPORTED_MODULE_3__["NoToneMapping"] ? '#define TONE_MAPPING' : '',
							parameters.toneMapping !== _constants_js__WEBPACK_IMPORTED_MODULE_3__["NoToneMapping"]
								? _shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_2__["ShaderChunk"]['tonemapping_pars_fragment']
								: '', // this code is required here because it is used by the toneMapping() function defined below
							parameters.toneMapping !== _constants_js__WEBPACK_IMPORTED_MODULE_3__["NoToneMapping"]
								? getToneMappingFunction('toneMapping', parameters.toneMapping)
								: '',

							parameters.dithering ? '#define DITHERING' : '',
							parameters.format === _constants_js__WEBPACK_IMPORTED_MODULE_3__["RGBFormat"] ? '#define OPAQUE' : '',

							_shaders_ShaderChunk_js__WEBPACK_IMPORTED_MODULE_2__["ShaderChunk"]['encodings_pars_fragment'], // this code is required here because it is used by the various encoding/decoding function defined below
							parameters.map
								? getTexelDecodingFunction('mapTexelToLinear', parameters.mapEncoding)
								: '',
							parameters.matcap
								? getTexelDecodingFunction(
									'matcapTexelToLinear',
									parameters.matcapEncoding
								)
								: '',
							parameters.envMap
								? getTexelDecodingFunction(
									'envMapTexelToLinear',
									parameters.envMapEncoding
								)
								: '',
							parameters.emissiveMap
								? getTexelDecodingFunction(
									'emissiveMapTexelToLinear',
									parameters.emissiveMapEncoding
								)
								: '',
							parameters.specularColorMap
								? getTexelDecodingFunction(
									'specularColorMapTexelToLinear',
									parameters.specularColorMapEncoding
								)
								: '',
							parameters.sheenColorMap
								? getTexelDecodingFunction(
									'sheenColorMapTexelToLinear',
									parameters.sheenColorMapEncoding
								)
								: '',
							parameters.lightMap
								? getTexelDecodingFunction(
									'lightMapTexelToLinear',
									parameters.lightMapEncoding
								)
								: '',
							getTexelEncodingFunction(
								'linearToOutputTexel',
								parameters.outputEncoding
							),

							parameters.depthPacking
								? '#define DEPTH_PACKING ' + parameters.depthPacking
								: '',

							'\n'
						]
							.filter(filterEmptyLine)
							.join('\n');
					}

					vertexShader = resolveIncludes(vertexShader);
					vertexShader = replaceLightNums(vertexShader, parameters);
					vertexShader = replaceClippingPlaneNums(vertexShader, parameters);

					fragmentShader = resolveIncludes(fragmentShader);
					fragmentShader = replaceLightNums(fragmentShader, parameters);
					fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);

					vertexShader = unrollLoops(vertexShader);
					fragmentShader = unrollLoops(fragmentShader);

					if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
						// GLSL 3.0 conversion for built-in materials and ShaderMaterial

						versionString = '#version 300 es\n';

						prefixVertex =
							[
								'precision mediump sampler2DArray;',
								'#define attribute in',
								'#define varying out',
								'#define texture2D texture'
							].join('\n') +
							'\n' +
							prefixVertex;

						prefixFragment =
							[
								'#define varying in',
								parameters.glslVersion === _constants_js__WEBPACK_IMPORTED_MODULE_3__["GLSL3"] ? '' : 'out highp vec4 pc_fragColor;',
								parameters.glslVersion === _constants_js__WEBPACK_IMPORTED_MODULE_3__["GLSL3"]
									? ''
									: '#define gl_FragColor pc_fragColor',
								'#define gl_FragDepthEXT gl_FragDepth',
								'#define texture2D texture',
								'#define textureCube texture',
								'#define texture2DProj textureProj',
								'#define texture2DLodEXT textureLod',
								'#define texture2DProjLodEXT textureProjLod',
								'#define textureCubeLodEXT textureLod',
								'#define texture2DGradEXT textureGrad',
								'#define texture2DProjGradEXT textureProjGrad',
								'#define textureCubeGradEXT textureGrad'
							].join('\n') +
							'\n' +
							prefixFragment;
					}

					const vertexGlsl = versionString + prefixVertex + vertexShader;
					const fragmentGlsl = versionString + prefixFragment + fragmentShader;

					// console.log( '*VERTEX*', vertexGlsl );
					// console.log( '*FRAGMENT*', fragmentGlsl );

					const glVertexShader = Object(_WebGLShader_js__WEBPACK_IMPORTED_MODULE_1__["WebGLShader"])(gl, gl.VERTEX_SHADER, vertexGlsl);
					const glFragmentShader = Object(_WebGLShader_js__WEBPACK_IMPORTED_MODULE_1__["WebGLShader"])(gl, gl.FRAGMENT_SHADER, fragmentGlsl);

					gl.attachShader(program, glVertexShader);
					gl.attachShader(program, glFragmentShader);

					// Force a particular attribute to index 0.

					if (parameters.index0AttributeName !== undefined) {
						gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
					} else if (parameters.morphTargets === true) {
						// programs with morphTargets displace position out of attribute 0
						gl.bindAttribLocation(program, 0, 'position');
					}

					gl.linkProgram(program);

					// check for link errors
					if (renderer.debug.checkShaderErrors) {
						const programLog = gl.getProgramInfoLog(program).trim();
						const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
						const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();

						let runnable = true;
						let haveDiagnostics = true;

						if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
							runnable = false;

							const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
							const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');

							console.error(
								'THREE.WebGLProgram: Shader Error ' +
								gl.getError() +
								' - ' +
								'VALIDATE_STATUS ' +
								gl.getProgramParameter(program, gl.VALIDATE_STATUS) +
								'\n\n' +
								'Program Info Log: ' +
								programLog +
								'\n' +
								vertexErrors +
								'\n' +
								fragmentErrors
							);
						} else if (programLog !== '') {
							console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
						} else if (vertexLog === '' || fragmentLog === '') {
							haveDiagnostics = false;
						}

						if (haveDiagnostics) {
							this.diagnostics = {
								runnable: runnable,

								programLog: programLog,

								vertexShader: {
									log: vertexLog,
									prefix: prefixVertex
								},

								fragmentShader: {
									log: fragmentLog,
									prefix: prefixFragment
								}
							};
						}
					}

					// Clean up

					// Crashes in iOS9 and iOS10. #18402
					// gl.detachShader( program, glVertexShader );
					// gl.detachShader( program, glFragmentShader );

					gl.deleteShader(glVertexShader);
					gl.deleteShader(glFragmentShader);

					// set up caching for uniform locations

					let cachedUniforms;

					this.getUniforms = function () {
						if (cachedUniforms === undefined) {
							cachedUniforms = new _WebGLUniforms_js__WEBPACK_IMPORTED_MODULE_0__["WebGLUniforms"](gl, program);
						}

						return cachedUniforms;
					};

					// set up caching for attribute locations

					let cachedAttributes;

					this.getAttributes = function () {
						if (cachedAttributes === undefined) {
							cachedAttributes = fetchAttributeLocations(gl, program);
						}

						return cachedAttributes;
					};

					// free resource

					this.destroy = function () {
						bindingStates.releaseStatesOfProgram(this);

						gl.deleteProgram(program);
						this.program = undefined;
					};

					//

					this.name = parameters.shaderName;
					this.id = programIdCount++;
					this.cacheKey = cacheKey;
					this.usedTimes = 1;
					this.program = program;
					this.vertexShader = glVertexShader;
					this.fragmentShader = glFragmentShader;

					return this;
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLPrograms.js":
/*!*****************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLPrograms.js ***!
  \*****************************************************/
/*! exports provided: WebGLPrograms */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLPrograms", function () { return WebGLPrograms; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _WebGLProgram_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebGLProgram.js */ "./libs/three/renderers/webgl/WebGLProgram.js");
/* harmony import */ var _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../shaders/ShaderLib.js */ "./libs/three/renderers/shaders/ShaderLib.js");
/* harmony import */ var _shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../shaders/UniformsUtils.js */ "./libs/three/renderers/shaders/UniformsUtils.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils.js */ "./libs/three/utils.js");






				function WebGLPrograms(
					renderer,
					cubemaps,
					cubeuvmaps,
					extensions,
					capabilities,
					bindingStates,
					clipping
				) {
					const programs = [];

					const isWebGL2 = capabilities.isWebGL2;
					const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
					const floatVertexTextures = capabilities.floatVertexTextures;
					const maxVertexUniforms = capabilities.maxVertexUniforms;
					const vertexTextures = capabilities.vertexTextures;

					let precision = capabilities.precision;

					const shaderIDs = {
						MeshDepthMaterial: 'depth',
						MeshDistanceMaterial: 'distanceRGBA',
						MeshNormalMaterial: 'normal',
						MeshBasicMaterial: 'basic',
						MeshLambertMaterial: 'lambert',
						MeshPhongMaterial: 'phong',
						MeshToonMaterial: 'toon',
						MeshStandardMaterial: 'physical',
						MeshPhysicalMaterial: 'physical',
						MeshMatcapMaterial: 'matcap',
						LineBasicMaterial: 'basic',
						LineDashedMaterial: 'dashed',
						PointsMaterial: 'points',
						ShadowMaterial: 'shadow',
						SpriteMaterial: 'sprite'
					};

					const parameterNames = [
						'precision',
						'isWebGL2',
						'supportsVertexTextures',
						'outputEncoding',
						'instancing',
						'instancingColor',
						'map',
						'mapEncoding',
						'matcap',
						'matcapEncoding',
						'envMap',
						'envMapMode',
						'envMapEncoding',
						'envMapCubeUV',
						'lightMap',
						'lightMapEncoding',
						'aoMap',
						'emissiveMap',
						'emissiveMapEncoding',
						'bumpMap',
						'normalMap',
						'objectSpaceNormalMap',
						'tangentSpaceNormalMap',
						'clearcoat',
						'clearcoatMap',
						'clearcoatRoughnessMap',
						'clearcoatNormalMap',
						'displacementMap',
						'specularMap',
						,
						'roughnessMap',
						'metalnessMap',
						'gradientMap',
						'alphaMap',
						'alphaTest',
						'combine',
						'vertexColors',
						'vertexAlphas',
						'vertexTangents',
						'vertexUvs',
						'uvsVertexOnly',
						'fog',
						'useFog',
						'fogExp2',
						'flatShading',
						'sizeAttenuation',
						'logarithmicDepthBuffer',
						'skinning',
						'maxBones',
						'useVertexTexture',
						'morphTargets',
						'morphNormals',
						'morphTargetsCount',
						'premultipliedAlpha',
						'numDirLights',
						'numPointLights',
						'numSpotLights',
						'numHemiLights',
						'numRectAreaLights',
						'numDirLightShadows',
						'numPointLightShadows',
						'numSpotLightShadows',
						'shadowMapEnabled',
						'shadowMapType',
						'toneMapping',
						'physicallyCorrectLights',
						'doubleSided',
						'flipSided',
						'numClippingPlanes',
						'numClipIntersection',
						'depthPacking',
						'dithering',
						'format',
						'specularIntensityMap',
						'specularColorMap',
						'specularColorMapEncoding',
						'transmission',
						'transmissionMap',
						'thicknessMap',
						'sheen',
						'sheenColorMap',
						'sheenColorMapEncoding',
						'sheenRoughnessMap'
					];

					function getMaxBones(object) {
						const skeleton = object.skeleton;
						const bones = skeleton.bones;

						if (floatVertexTextures) {
							return 1024;
						} else {
							// default for when object is not specified
							// ( for example when prebuilding shader to be used with multiple objects )
							//
							//  - leave some extra space for other uniforms
							//  - limit here is ANGLE's 254 max uniform vectors
							//    (up to 54 should be safe)

							const nVertexUniforms = maxVertexUniforms;
							const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);

							const maxBones = Math.min(nVertexMatrices, bones.length);

							if (maxBones < bones.length) {
								console.warn(
									'THREE.WebGLRenderer: Skeleton has ' +
									bones.length +
									' bones. This GPU supports ' +
									maxBones +
									'.'
								);
								return 0;
							}

							return maxBones;
						}
					}

					function getTextureEncodingFromMap(map) {
						let encoding;

						if (map && map.isTexture) {
							encoding = map.encoding;
						} else if (map && map.isWebGLRenderTarget) {
							console.warn(
								"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
							);
							encoding = map.texture.encoding;
						} else {
							encoding = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"];
						}

						if (
							isWebGL2 &&
							map &&
							map.isTexture &&
							map.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] &&
							map.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"] &&
							map.encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"]
						) {
							encoding = _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearEncoding"]; // disable inline decode for sRGB textures in WebGL 2
						}

						return encoding;
					}

					function getParameters(material, lights, shadows, scene, object) {
						const fog = scene.fog;
						const environment = material.isMeshStandardMaterial
							? scene.environment
							: null;

						const envMap = (material.isMeshStandardMaterial
							? cubeuvmaps
							: cubemaps
						).get(material.envMap || environment);

						const shaderID = shaderIDs[material.type];

						// heuristics to create shader parameters according to lights in the scene
						// (not to blow over maxLights budget)

						const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;

						if (material.precision !== null) {
							precision = capabilities.getMaxPrecision(material.precision);

							if (precision !== material.precision) {
								console.warn(
									'THREE.WebGLProgram.getParameters:',
									material.precision,
									'not supported, using',
									precision,
									'instead.'
								);
							}
						}

						let vertexShader, fragmentShader;

						if (shaderID) {
							const shader = _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_2__["ShaderLib"][shaderID];

							vertexShader = shader.vertexShader;
							fragmentShader = shader.fragmentShader;
						} else {
							vertexShader = material.vertexShader;
							fragmentShader = material.fragmentShader;
						}

						const currentRenderTarget = renderer.getRenderTarget();

						const useAlphaTest = material.alphaTest > 0;
						const useClearcoat = material.clearcoat > 0;

						const parameters = {
							isWebGL2: isWebGL2,

							shaderID: shaderID,
							shaderName: material.type,

							vertexShader: vertexShader,
							fragmentShader: fragmentShader,
							defines: material.defines,

							isRawShaderMaterial: material.isRawShaderMaterial === true,
							glslVersion: material.glslVersion,

							precision: precision,

							instancing: object.isInstancedMesh === true,
							instancingColor:
								object.isInstancedMesh === true && object.instanceColor !== null,

							supportsVertexTextures: vertexTextures,
							outputEncoding:
								currentRenderTarget !== null
									? getTextureEncodingFromMap(currentRenderTarget.texture)
									: renderer.outputEncoding,
							map: !!material.map,
							mapEncoding: getTextureEncodingFromMap(material.map),
							matcap: !!material.matcap,
							matcapEncoding: getTextureEncodingFromMap(material.matcap),
							envMap: !!envMap,
							envMapMode: envMap && envMap.mapping,
							envMapEncoding: getTextureEncodingFromMap(envMap),
							envMapCubeUV:
								!!envMap &&
								(envMap.mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVReflectionMapping"] ||
									envMap.mapping === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CubeUVRefractionMapping"]),
							lightMap: !!material.lightMap,
							lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
							aoMap: !!material.aoMap,
							emissiveMap: !!material.emissiveMap,
							emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
							bumpMap: !!material.bumpMap,
							normalMap: !!material.normalMap,
							objectSpaceNormalMap: material.normalMapType === _constants_js__WEBPACK_IMPORTED_MODULE_0__["ObjectSpaceNormalMap"],
							tangentSpaceNormalMap: material.normalMapType === _constants_js__WEBPACK_IMPORTED_MODULE_0__["TangentSpaceNormalMap"],

							clearcoat: useClearcoat,
							clearcoatMap: useClearcoat && !!material.clearcoatMap,
							clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
							clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,

							displacementMap: !!material.displacementMap,
							roughnessMap: !!material.roughnessMap,
							metalnessMap: !!material.metalnessMap,
							specularMap: !!material.specularMap,
							specularIntensityMap: !!material.specularIntensityMap,
							specularColorMap: !!material.specularColorMap,
							specularColorMapEncoding: getTextureEncodingFromMap(
								material.specularColorMap
							),

							alphaMap: !!material.alphaMap,
							alphaTest: useAlphaTest,

							gradientMap: !!material.gradientMap,

							sheen: material.sheen > 0,
							sheenColorMap: !!material.sheenColorMap,
							sheenColorMapEncoding: getTextureEncodingFromMap(material.sheenColorMap),
							sheenRoughnessMap: !!material.sheenRoughnessMap,

							transmission: material.transmission > 0,
							transmissionMap: !!material.transmissionMap,
							thicknessMap: !!material.thicknessMap,

							combine: material.combine,

							vertexTangents:
								!!material.normalMap &&
								!!object.geometry &&
								!!object.geometry.attributes.tangent,
							vertexColors: material.vertexColors,
							vertexAlphas:
								material.vertexColors === true &&
								!!object.geometry &&
								!!object.geometry.attributes.color &&
								object.geometry.attributes.color.itemSize === 4,
							vertexUvs:
								!!material.map ||
								!!material.bumpMap ||
								!!material.normalMap ||
								!!material.specularMap ||
								!!material.alphaMap ||
								!!material.emissiveMap ||
								!!material.roughnessMap ||
								!!material.metalnessMap ||
								!!material.clearcoatMap ||
								!!material.clearcoatRoughnessMap ||
								!!material.clearcoatNormalMap ||
								!!material.displacementMap ||
								!!material.transmissionMap ||
								!!material.thicknessMap ||
								!!material.specularIntensityMap ||
								!!material.specularColorMap ||
								!!material.sheenColorMap ||
								material.sheenRoughnessMap,
							uvsVertexOnly:
								!(
									!!material.map ||
									!!material.bumpMap ||
									!!material.normalMap ||
									!!material.specularMap ||
									!!material.alphaMap ||
									!!material.emissiveMap ||
									!!material.roughnessMap ||
									!!material.metalnessMap ||
									!!material.clearcoatNormalMap ||
									material.transmission > 0 ||
									!!material.transmissionMap ||
									!!material.thicknessMap ||
									!!material.specularIntensityMap ||
									!!material.specularColorMap ||
									!!material.sheen > 0 ||
									!!material.sheenColorMap ||
									!!material.sheenRoughnessMap
								) && !!material.displacementMap,

							fog: !!fog,
							useFog: material.fog,
							fogExp2: fog && fog.isFogExp2,

							flatShading: !!material.flatShading,

							sizeAttenuation: material.sizeAttenuation,
							logarithmicDepthBuffer: logarithmicDepthBuffer,

							skinning: object.isSkinnedMesh === true && maxBones > 0,
							maxBones: maxBones,
							useVertexTexture: floatVertexTextures,

							morphTargets:
								!!object.geometry && !!object.geometry.morphAttributes.position,
							morphNormals:
								!!object.geometry && !!object.geometry.morphAttributes.normal,
							morphTargetsCount:
								!!object.geometry && !!object.geometry.morphAttributes.position
									? object.geometry.morphAttributes.position.length
									: 0,

							numDirLights: lights.directional.length,
							numPointLights: lights.point.length,
							numSpotLights: lights.spot.length,
							numRectAreaLights: lights.rectArea.length,
							numHemiLights: lights.hemi.length,

							numDirLightShadows: lights.directionalShadowMap.length,
							numPointLightShadows: lights.pointShadowMap.length,
							numSpotLightShadows: lights.spotShadowMap.length,

							numClippingPlanes: clipping.numPlanes,
							numClipIntersection: clipping.numIntersection,

							format: material.format,
							dithering: material.dithering,

							shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
							shadowMapType: renderer.shadowMap.type,

							toneMapping: material.toneMapped ? renderer.toneMapping : _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoToneMapping"],
							physicallyCorrectLights: renderer.physicallyCorrectLights,

							premultipliedAlpha: material.premultipliedAlpha,

							doubleSided: material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"],
							flipSided: material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"],

							depthPacking:
								material.depthPacking !== undefined ? material.depthPacking : false,

							index0AttributeName: material.index0AttributeName,

							extensionDerivatives:
								material.extensions && material.extensions.derivatives,
							extensionFragDepth: material.extensions && material.extensions.fragDepth,
							extensionDrawBuffers:
								material.extensions && material.extensions.drawBuffers,
							extensionShaderTextureLOD:
								material.extensions && material.extensions.shaderTextureLOD,

							rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
							rendererExtensionDrawBuffers:
								isWebGL2 || extensions.has('WEBGL_draw_buffers'),
							rendererExtensionShaderTextureLod:
								isWebGL2 || extensions.has('EXT_shader_texture_lod'),

							customProgramCacheKey: material.customProgramCacheKey()
						};

						return parameters;
					}

					function getProgramCacheKey(parameters) {
						const array = [];

						if (parameters.shaderID) {
							array.push(parameters.shaderID);
						} else {
							array.push(Object(_utils_js__WEBPACK_IMPORTED_MODULE_4__["hashString"])(parameters.fragmentShader));
							array.push(Object(_utils_js__WEBPACK_IMPORTED_MODULE_4__["hashString"])(parameters.vertexShader));
						}

						if (parameters.defines !== undefined) {
							for (const name in parameters.defines) {
								array.push(name);
								array.push(parameters.defines[name]);
							}
						}

						if (parameters.isRawShaderMaterial === false) {
							for (let i = 0; i < parameterNames.length; i++) {
								array.push(parameters[parameterNames[i]]);
							}

							array.push(renderer.outputEncoding);
							array.push(renderer.gammaFactor);
						}

						array.push(parameters.customProgramCacheKey);

						return array.join();
					}

					function getUniforms(material) {
						const shaderID = shaderIDs[material.type];
						let uniforms;

						if (shaderID) {
							const shader = _shaders_ShaderLib_js__WEBPACK_IMPORTED_MODULE_2__["ShaderLib"][shaderID];
							uniforms = _shaders_UniformsUtils_js__WEBPACK_IMPORTED_MODULE_3__["UniformsUtils"].clone(shader.uniforms);
						} else {
							uniforms = material.uniforms;
						}

						return uniforms;
					}

					function acquireProgram(parameters, cacheKey) {
						let program;

						// Check if code has been already compiled
						for (let p = 0, pl = programs.length; p < pl; p++) {
							const preexistingProgram = programs[p];

							if (preexistingProgram.cacheKey === cacheKey) {
								program = preexistingProgram;
								++program.usedTimes;

								break;
							}
						}

						if (program === undefined) {
							program = new _WebGLProgram_js__WEBPACK_IMPORTED_MODULE_1__["WebGLProgram"](renderer, cacheKey, parameters, bindingStates);
							programs.push(program);
						}

						return program;
					}

					function releaseProgram(program) {
						if (--program.usedTimes === 0) {
							// Remove from unordered set
							const i = programs.indexOf(program);
							programs[i] = programs[programs.length - 1];
							programs.pop();

							// Free WebGL resources
							program.destroy();
						}
					}

					return {
						getParameters: getParameters,
						getProgramCacheKey: getProgramCacheKey,
						getUniforms: getUniforms,
						acquireProgram: acquireProgram,
						releaseProgram: releaseProgram,
						// Exposed for resource monitoring & error feedback via renderer.info:
						programs: programs
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLProperties.js":
/*!*******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLProperties.js ***!
  \*******************************************************/
/*! exports provided: WebGLProperties */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLProperties", function () { return WebGLProperties; });
				function WebGLProperties() {
					let properties = new WeakMap();

					function get(object) {
						let map = properties.get(object);

						if (map === undefined) {
							map = {};
							properties.set(object, map);
						}

						return map;
					}

					function remove(object) {
						properties.delete(object);
					}

					function update(object, key, value) {
						properties.get(object)[key] = value;
					}

					function dispose() {
						properties = new WeakMap();
					}

					return {
						get: get,
						remove: remove,
						update: update,
						dispose: dispose
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLRenderLists.js":
/*!********************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLRenderLists.js ***!
  \********************************************************/
/*! exports provided: WebGLRenderLists, WebGLRenderList */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderLists", function () { return WebGLRenderLists; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderList", function () { return WebGLRenderList; });
				function painterSortStable(a, b) {
					if (a.groupOrder !== b.groupOrder) {
						return a.groupOrder - b.groupOrder;
					} else if (a.renderOrder !== b.renderOrder) {
						return a.renderOrder - b.renderOrder;
					} else if (a.program !== b.program) {
						return a.program.id - b.program.id;
					} else if (a.material.id !== b.material.id) {
						return a.material.id - b.material.id;
					} else if (a.z !== b.z) {
						return a.z - b.z;
					} else {
						return a.id - b.id;
					}
				}

				function reversePainterSortStable(a, b) {
					if (a.groupOrder !== b.groupOrder) {
						return a.groupOrder - b.groupOrder;
					} else if (a.renderOrder !== b.renderOrder) {
						return a.renderOrder - b.renderOrder;
					} else if (a.z !== b.z) {
						return b.z - a.z;
					} else {
						return a.id - b.id;
					}
				}

				function WebGLRenderList(properties) {
					const renderItems = [];
					let renderItemsIndex = 0;

					const opaque = [];
					const transmissive = [];
					const transparent = [];

					const defaultProgram = { id: -1 };

					function init() {
						renderItemsIndex = 0;

						opaque.length = 0;
						transmissive.length = 0;
						transparent.length = 0;
					}

					function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
						let renderItem = renderItems[renderItemsIndex];
						const materialProperties = properties.get(material);

						if (renderItem === undefined) {
							renderItem = {
								id: object.id,
								object: object,
								geometry: geometry,
								material: material,
								program: materialProperties.program || defaultProgram,
								groupOrder: groupOrder,
								renderOrder: object.renderOrder,
								z: z,
								group: group
							};

							renderItems[renderItemsIndex] = renderItem;
						} else {
							renderItem.id = object.id;
							renderItem.object = object;
							renderItem.geometry = geometry;
							renderItem.material = material;
							renderItem.program = materialProperties.program || defaultProgram;
							renderItem.groupOrder = groupOrder;
							renderItem.renderOrder = object.renderOrder;
							renderItem.z = z;
							renderItem.group = group;
						}

						renderItemsIndex++;

						return renderItem;
					}

					function push(object, geometry, material, groupOrder, z, group) {
						const renderItem = getNextRenderItem(
							object,
							geometry,
							material,
							groupOrder,
							z,
							group
						);

						if (material.transmission > 0.0) {
							transmissive.push(renderItem);
						} else if (material.transparent === true) {
							transparent.push(renderItem);
						} else {
							opaque.push(renderItem);
						}
					}

					function unshift(object, geometry, material, groupOrder, z, group) {
						const renderItem = getNextRenderItem(
							object,
							geometry,
							material,
							groupOrder,
							z,
							group
						);

						if (material.transmission > 0.0) {
							transmissive.unshift(renderItem);
						} else if (material.transparent === true) {
							transparent.unshift(renderItem);
						} else {
							opaque.unshift(renderItem);
						}
					}

					function sort(customOpaqueSort, customTransparentSort) {
						if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
						if (transmissive.length > 1)
							transmissive.sort(customTransparentSort || reversePainterSortStable);
						if (transparent.length > 1)
							transparent.sort(customTransparentSort || reversePainterSortStable);
					}

					function finish() {
						// Clear references from inactive renderItems in the list

						for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
							const renderItem = renderItems[i];

							if (renderItem.id === null) break;

							renderItem.id = null;
							renderItem.object = null;
							renderItem.geometry = null;
							renderItem.material = null;
							renderItem.program = null;
							renderItem.group = null;
						}
					}

					return {
						opaque: opaque,
						transmissive: transmissive,
						transparent: transparent,

						init: init,
						push: push,
						unshift: unshift,
						finish: finish,

						sort: sort
					};
				}

				function WebGLRenderLists(properties) {
					let lists = new WeakMap();

					function get(scene, renderCallDepth) {
						let list;

						if (lists.has(scene) === false) {
							list = new WebGLRenderList(properties);
							lists.set(scene, [list]);
						} else {
							if (renderCallDepth >= lists.get(scene).length) {
								list = new WebGLRenderList(properties);
								lists.get(scene).push(list);
							} else {
								list = lists.get(scene)[renderCallDepth];
							}
						}

						return list;
					}

					function dispose() {
						lists = new WeakMap();
					}

					return {
						get: get,
						dispose: dispose
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLRenderStates.js":
/*!*********************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLRenderStates.js ***!
  \*********************************************************/
/*! exports provided: WebGLRenderStates */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderStates", function () { return WebGLRenderStates; });
/* harmony import */ var _WebGLLights_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLLights.js */ "./libs/three/renderers/webgl/WebGLLights.js");


				function WebGLRenderState(extensions, capabilities) {
					const lights = new _WebGLLights_js__WEBPACK_IMPORTED_MODULE_0__["WebGLLights"](extensions, capabilities);

					const lightsArray = [];
					const shadowsArray = [];

					function init() {
						lightsArray.length = 0;
						shadowsArray.length = 0;
					}

					function pushLight(light) {
						lightsArray.push(light);
					}

					function pushShadow(shadowLight) {
						shadowsArray.push(shadowLight);
					}

					function setupLights(physicallyCorrectLights) {
						lights.setup(lightsArray, physicallyCorrectLights);
					}

					function setupLightsView(camera) {
						lights.setupView(lightsArray, camera);
					}

					const state = {
						lightsArray: lightsArray,
						shadowsArray: shadowsArray,

						lights: lights
					};

					return {
						init: init,
						state: state,
						setupLights: setupLights,
						setupLightsView: setupLightsView,

						pushLight: pushLight,
						pushShadow: pushShadow
					};
				}

				function WebGLRenderStates(extensions, capabilities) {
					let renderStates = new WeakMap();

					function get(scene, renderCallDepth = 0) {
						let renderState;

						if (renderStates.has(scene) === false) {
							renderState = new WebGLRenderState(extensions, capabilities);
							renderStates.set(scene, [renderState]);
						} else {
							if (renderCallDepth >= renderStates.get(scene).length) {
								renderState = new WebGLRenderState(extensions, capabilities);
								renderStates.get(scene).push(renderState);
							} else {
								renderState = renderStates.get(scene)[renderCallDepth];
							}
						}

						return renderState;
					}

					function dispose() {
						renderStates = new WeakMap();
					}

					return {
						get: get,
						dispose: dispose
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLShader.js":
/*!***************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLShader.js ***!
  \***************************************************/
/*! exports provided: WebGLShader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLShader", function () { return WebGLShader; });
				function WebGLShader(gl, type, string) {
					const shader = gl.createShader(type);

					gl.shaderSource(shader, string);
					gl.compileShader(shader);

					return shader;
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLShadowMap.js":
/*!******************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLShadowMap.js ***!
  \******************************************************/
/*! exports provided: WebGLShadowMap */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLShadowMap", function () { return WebGLShadowMap; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../WebGLRenderTarget.js */ "./libs/three/renderers/WebGLRenderTarget.js");
/* harmony import */ var _materials_MeshDepthMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../materials/MeshDepthMaterial.js */ "./libs/three/materials/MeshDepthMaterial.js");
/* harmony import */ var _materials_MeshDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../materials/MeshDistanceMaterial.js */ "./libs/three/materials/MeshDistanceMaterial.js");
/* harmony import */ var _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../materials/ShaderMaterial.js */ "./libs/three/materials/ShaderMaterial.js");
/* harmony import */ var _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../core/BufferAttribute.js */ "./libs/three/core/BufferAttribute.js");
/* harmony import */ var _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../core/BufferGeometry.js */ "./libs/three/core/BufferGeometry.js");
/* harmony import */ var _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../objects/Mesh.js */ "./libs/three/objects/Mesh.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../math/Vector4.js */ "./libs/three/math/Vector4.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../math/Frustum.js */ "./libs/three/math/Frustum.js");
/* harmony import */ var _shaders_ShaderLib_vsm_glsl_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../shaders/ShaderLib/vsm.glsl.js */ "./libs/three/renderers/shaders/ShaderLib/vsm.glsl.js");














				function WebGLShadowMap(_renderer, _objects, _capabilities) {
					let _frustum = new _math_Frustum_js__WEBPACK_IMPORTED_MODULE_10__["Frustum"]();

					const _shadowMapSize = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_9__["Vector2"](),
						_viewportSize = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_9__["Vector2"](),
						_viewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_8__["Vector4"](),
						_depthMaterial = new _materials_MeshDepthMaterial_js__WEBPACK_IMPORTED_MODULE_2__["MeshDepthMaterial"]({ depthPacking: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBADepthPacking"] }),
						_distanceMaterial = new _materials_MeshDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_3__["MeshDistanceMaterial"](),
						_materialCache = {},
						_maxTextureSize = _capabilities.maxTextureSize;

					const shadowSide = { 0: _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"], 1: _constants_js__WEBPACK_IMPORTED_MODULE_0__["FrontSide"], 2: _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"] };

					const shadowMaterialVertical = new _materials_ShaderMaterial_js__WEBPACK_IMPORTED_MODULE_4__["ShaderMaterial"]({
						defines: {
							VSM_SAMPLES: 8
						},
						uniforms: {
							shadow_pass: { value: null },
							resolution: { value: new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_9__["Vector2"]() },
							radius: { value: 4.0 }
						},

						vertexShader: _shaders_ShaderLib_vsm_glsl_js__WEBPACK_IMPORTED_MODULE_11__["vertex"],
						fragmentShader: _shaders_ShaderLib_vsm_glsl_js__WEBPACK_IMPORTED_MODULE_11__["fragment"]
					});

					const shadowMaterialHorizontal = shadowMaterialVertical.clone();
					shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

					const fullScreenTri = new _core_BufferGeometry_js__WEBPACK_IMPORTED_MODULE_6__["BufferGeometry"]();
					fullScreenTri.setAttribute(
						'position',
						new _core_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_5__["BufferAttribute"](
							new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
							3
						)
					);

					const fullScreenMesh = new _objects_Mesh_js__WEBPACK_IMPORTED_MODULE_7__["Mesh"](fullScreenTri, shadowMaterialVertical);

					const scope = this;

					this.enabled = false;

					this.autoUpdate = true;
					this.needsUpdate = false;

					this.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__["PCFShadowMap"];

					this.render = function (lights, scene, camera) {
						if (scope.enabled === false) return;
						if (scope.autoUpdate === false && scope.needsUpdate === false) return;

						if (lights.length === 0) return;

						const currentRenderTarget = _renderer.getRenderTarget();
						const activeCubeFace = _renderer.getActiveCubeFace();
						const activeMipmapLevel = _renderer.getActiveMipmapLevel();

						const _state = _renderer.state;

						// Set GL state for depth map.
						_state.setBlending(_constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"]);
						_state.buffers.color.setClear(1, 1, 1, 1);
						_state.buffers.depth.setTest(true);
						_state.setScissorTest(false);

						// render depth map

						for (let i = 0, il = lights.length; i < il; i++) {
							const light = lights[i];
							const shadow = light.shadow;

							if (shadow === undefined) {
								console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
								continue;
							}

							if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;

							_shadowMapSize.copy(shadow.mapSize);

							const shadowFrameExtents = shadow.getFrameExtents();

							_shadowMapSize.multiply(shadowFrameExtents);

							_viewportSize.copy(shadow.mapSize);

							if (
								_shadowMapSize.x > _maxTextureSize ||
								_shadowMapSize.y > _maxTextureSize
							) {
								if (_shadowMapSize.x > _maxTextureSize) {
									_viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
									_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
									shadow.mapSize.x = _viewportSize.x;
								}

								if (_shadowMapSize.y > _maxTextureSize) {
									_viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
									_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
									shadow.mapSize.y = _viewportSize.y;
								}
							}

							if (
								shadow.map === null &&
								!shadow.isPointLightShadow &&
								this.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"]
							) {
								const pars = {
									minFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"],
									magFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"],
									format: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"]
								};

								shadow.map = new _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLRenderTarget"](
									_shadowMapSize.x,
									_shadowMapSize.y,
									pars
								);
								shadow.map.texture.name = light.name + '.shadowMap';

								shadow.mapPass = new _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLRenderTarget"](
									_shadowMapSize.x,
									_shadowMapSize.y,
									pars
								);

								shadow.camera.updateProjectionMatrix();
							}

							if (shadow.map === null) {
								const pars = {
									minFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
									magFilter: _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"],
									format: _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"]
								};

								shadow.map = new _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_1__["WebGLRenderTarget"](
									_shadowMapSize.x,
									_shadowMapSize.y,
									pars
								);
								shadow.map.texture.name = light.name + '.shadowMap';

								shadow.camera.updateProjectionMatrix();
							}

							_renderer.setRenderTarget(shadow.map);
							_renderer.clear();

							const viewportCount = shadow.getViewportCount();

							for (let vp = 0; vp < viewportCount; vp++) {
								const viewport = shadow.getViewport(vp);

								_viewport.set(
									_viewportSize.x * viewport.x,
									_viewportSize.y * viewport.y,
									_viewportSize.x * viewport.z,
									_viewportSize.y * viewport.w
								);

								_state.viewport(_viewport);

								shadow.updateMatrices(light, vp);

								_frustum = shadow.getFrustum();

								renderObject(scene, camera, shadow.camera, light, this.type);
							}

							// do blur pass for VSM

							if (!shadow.isPointLightShadow && this.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"]) {
								VSMPass(shadow, camera);
							}

							shadow.needsUpdate = false;
						}

						scope.needsUpdate = false;

						_renderer.setRenderTarget(
							currentRenderTarget,
							activeCubeFace,
							activeMipmapLevel
						);
					};

					function VSMPass(shadow, camera) {
						const geometry = _objects.update(fullScreenMesh);

						if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
							shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
							shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;

							shadowMaterialVertical.needsUpdate = true;
							shadowMaterialHorizontal.needsUpdate = true;
						}

						// vertical pass

						shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
						shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
						shadowMaterialVertical.uniforms.radius.value = shadow.radius;
						_renderer.setRenderTarget(shadow.mapPass);
						_renderer.clear();
						_renderer.renderBufferDirect(
							camera,
							null,
							geometry,
							shadowMaterialVertical,
							fullScreenMesh,
							null
						);

						// horizontal pass

						shadowMaterialHorizontal.uniforms.shadow_pass.value =
							shadow.mapPass.texture;
						shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
						shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
						_renderer.setRenderTarget(shadow.map);
						_renderer.clear();
						_renderer.renderBufferDirect(
							camera,
							null,
							geometry,
							shadowMaterialHorizontal,
							fullScreenMesh,
							null
						);
					}

					function getDepthMaterial(
						object,
						geometry,
						material,
						light,
						shadowCameraNear,
						shadowCameraFar,
						type
					) {
						let result = null;

						const customMaterial =
							light.isPointLight === true
								? object.customDistanceMaterial
								: object.customDepthMaterial;

						if (customMaterial !== undefined) {
							result = customMaterial;
						} else {
							result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
						}

						if (
							(_renderer.localClippingEnabled &&
								material.clipShadows === true &&
								material.clippingPlanes.length !== 0) ||
							(material.displacementMap && material.displacementScale !== 0) ||
							(material.alphaMap && material.alphaTest > 0)
						) {
							// in this case we need a unique material instance reflecting the
							// appropriate state

							const keyA = result.uuid,
								keyB = material.uuid;

							let materialsForVariant = _materialCache[keyA];

							if (materialsForVariant === undefined) {
								materialsForVariant = {};
								_materialCache[keyA] = materialsForVariant;
							}

							let cachedMaterial = materialsForVariant[keyB];

							if (cachedMaterial === undefined) {
								cachedMaterial = result.clone();
								materialsForVariant[keyB] = cachedMaterial;
							}

							result = cachedMaterial;
						}

						result.visible = material.visible;
						result.wireframe = material.wireframe;

						if (type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"]) {
							result.side =
								material.shadowSide !== null ? material.shadowSide : material.side;
						} else {
							result.side =
								material.shadowSide !== null
									? material.shadowSide
									: shadowSide[material.side];
						}

						result.alphaMap = material.alphaMap;
						result.alphaTest = material.alphaTest;

						result.clipShadows = material.clipShadows;
						result.clippingPlanes = material.clippingPlanes;
						result.clipIntersection = material.clipIntersection;

						result.displacementMap = material.displacementMap;
						result.displacementScale = material.displacementScale;
						result.displacementBias = material.displacementBias;

						result.wireframeLinewidth = material.wireframeLinewidth;
						result.linewidth = material.linewidth;

						if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
							result.referencePosition.setFromMatrixPosition(light.matrixWorld);
							result.nearDistance = shadowCameraNear;
							result.farDistance = shadowCameraFar;
						}

						return result;
					}

					function renderObject(object, camera, shadowCamera, light, type) {
						if (object.visible === false) return;

						const visible = object.layers.test(camera.layers);

						if (visible && (object.isMesh || object.isLine || object.isPoints)) {
							if (
								(object.castShadow ||
									(object.receiveShadow && type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["VSMShadowMap"])) &&
								(!object.frustumCulled || _frustum.intersectsObject(object))
							) {
								object.modelViewMatrix.multiplyMatrices(
									shadowCamera.matrixWorldInverse,
									object.matrixWorld
								);

								const geometry = _objects.update(object);
								const material = object.material;

								if (Array.isArray(material)) {
									const groups = geometry.groups;

									for (let k = 0, kl = groups.length; k < kl; k++) {
										const group = groups[k];
										const groupMaterial = material[group.materialIndex];

										if (groupMaterial && groupMaterial.visible) {
											const depthMaterial = getDepthMaterial(
												object,
												geometry,
												groupMaterial,
												light,
												shadowCamera.near,
												shadowCamera.far,
												type
											);

											_renderer.renderBufferDirect(
												shadowCamera,
												null,
												geometry,
												depthMaterial,
												object,
												group
											);
										}
									}
								} else if (material.visible) {
									const depthMaterial = getDepthMaterial(
										object,
										geometry,
										material,
										light,
										shadowCamera.near,
										shadowCamera.far,
										type
									);

									_renderer.renderBufferDirect(
										shadowCamera,
										null,
										geometry,
										depthMaterial,
										object,
										null
									);
								}
							}
						}

						const children = object.children;

						for (let i = 0, l = children.length; i < l; i++) {
							renderObject(children[i], camera, shadowCamera, light, type);
						}
					}
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLState.js":
/*!**************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLState.js ***!
  \**************************************************/
/*! exports provided: WebGLState */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLState", function () { return WebGLState; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/Vector4.js */ "./libs/three/math/Vector4.js");



				function WebGLState(gl, extensions, capabilities) {
					const isWebGL2 = capabilities.isWebGL2;

					function ColorBuffer() {
						let locked = false;

						const color = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__["Vector4"]();
						let currentColorMask = null;
						const currentColorClear = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__["Vector4"](0, 0, 0, 0);

						return {
							setMask: function (colorMask) {
								if (currentColorMask !== colorMask && !locked) {
									gl.colorMask(colorMask, colorMask, colorMask, colorMask);
									currentColorMask = colorMask;
								}
							},

							setLocked: function (lock) {
								locked = lock;
							},

							setClear: function (r, g, b, a, premultipliedAlpha) {
								if (premultipliedAlpha === true) {
									r *= a;
									g *= a;
									b *= a;
								}

								color.set(r, g, b, a);

								if (currentColorClear.equals(color) === false) {
									gl.clearColor(r, g, b, a);
									currentColorClear.copy(color);
								}
							},

							reset: function () {
								locked = false;

								currentColorMask = null;
								currentColorClear.set(-1, 0, 0, 0); // set to invalid state
							}
						};
					}

					function DepthBuffer() {
						let locked = false;

						let currentDepthMask = null;
						let currentDepthFunc = null;
						let currentDepthClear = null;

						return {
							setTest: function (depthTest) {
								if (depthTest) {
									enable(gl.DEPTH_TEST);
								} else {
									disable(gl.DEPTH_TEST);
								}
							},

							setMask: function (depthMask) {
								if (currentDepthMask !== depthMask && !locked) {
									gl.depthMask(depthMask);
									currentDepthMask = depthMask;
								}
							},

							setFunc: function (depthFunc) {
								if (currentDepthFunc !== depthFunc) {
									if (depthFunc) {
										switch (depthFunc) {
											case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NeverDepth"]:
												gl.depthFunc(gl.NEVER);
												break;

											case _constants_js__WEBPACK_IMPORTED_MODULE_0__["AlwaysDepth"]:
												gl.depthFunc(gl.ALWAYS);
												break;

											case _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessDepth"]:
												gl.depthFunc(gl.LESS);
												break;

											case _constants_js__WEBPACK_IMPORTED_MODULE_0__["LessEqualDepth"]:
												gl.depthFunc(gl.LEQUAL);
												break;

											case _constants_js__WEBPACK_IMPORTED_MODULE_0__["EqualDepth"]:
												gl.depthFunc(gl.EQUAL);
												break;

											case _constants_js__WEBPACK_IMPORTED_MODULE_0__["GreaterEqualDepth"]:
												gl.depthFunc(gl.GEQUAL);
												break;

											case _constants_js__WEBPACK_IMPORTED_MODULE_0__["GreaterDepth"]:
												gl.depthFunc(gl.GREATER);
												break;

											case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NotEqualDepth"]:
												gl.depthFunc(gl.NOTEQUAL);
												break;

											default:
												gl.depthFunc(gl.LEQUAL);
										}
									} else {
										gl.depthFunc(gl.LEQUAL);
									}

									currentDepthFunc = depthFunc;
								}
							},

							setLocked: function (lock) {
								locked = lock;
							},

							setClear: function (depth) {
								if (currentDepthClear !== depth) {
									gl.clearDepth(depth);
									currentDepthClear = depth;
								}
							},

							reset: function () {
								locked = false;

								currentDepthMask = null;
								currentDepthFunc = null;
								currentDepthClear = null;
							}
						};
					}

					function StencilBuffer() {
						let locked = false;

						let currentStencilMask = null;
						let currentStencilFunc = null;
						let currentStencilRef = null;
						let currentStencilFuncMask = null;
						let currentStencilFail = null;
						let currentStencilZFail = null;
						let currentStencilZPass = null;
						let currentStencilClear = null;

						return {
							setTest: function (stencilTest) {
								if (!locked) {
									if (stencilTest) {
										enable(gl.STENCIL_TEST);
									} else {
										disable(gl.STENCIL_TEST);
									}
								}
							},

							setMask: function (stencilMask) {
								if (currentStencilMask !== stencilMask && !locked) {
									gl.stencilMask(stencilMask);
									currentStencilMask = stencilMask;
								}
							},

							setFunc: function (stencilFunc, stencilRef, stencilMask) {
								if (
									currentStencilFunc !== stencilFunc ||
									currentStencilRef !== stencilRef ||
									currentStencilFuncMask !== stencilMask
								) {
									gl.stencilFunc(stencilFunc, stencilRef, stencilMask);

									currentStencilFunc = stencilFunc;
									currentStencilRef = stencilRef;
									currentStencilFuncMask = stencilMask;
								}
							},

							setOp: function (stencilFail, stencilZFail, stencilZPass) {
								if (
									currentStencilFail !== stencilFail ||
									currentStencilZFail !== stencilZFail ||
									currentStencilZPass !== stencilZPass
								) {
									gl.stencilOp(stencilFail, stencilZFail, stencilZPass);

									currentStencilFail = stencilFail;
									currentStencilZFail = stencilZFail;
									currentStencilZPass = stencilZPass;
								}
							},

							setLocked: function (lock) {
								locked = lock;
							},

							setClear: function (stencil) {
								if (currentStencilClear !== stencil) {
									gl.clearStencil(stencil);
									currentStencilClear = stencil;
								}
							},

							reset: function () {
								locked = false;

								currentStencilMask = null;
								currentStencilFunc = null;
								currentStencilRef = null;
								currentStencilFuncMask = null;
								currentStencilFail = null;
								currentStencilZFail = null;
								currentStencilZPass = null;
								currentStencilClear = null;
							}
						};
					}

					//

					const colorBuffer = new ColorBuffer();
					const depthBuffer = new DepthBuffer();
					const stencilBuffer = new StencilBuffer();

					let enabledCapabilities = {};

					let xrFramebuffer = null;
					let currentBoundFramebuffers = {};

					let currentProgram = null;

					let currentBlendingEnabled = false;
					let currentBlending = null;
					let currentBlendEquation = null;
					let currentBlendSrc = null;
					let currentBlendDst = null;
					let currentBlendEquationAlpha = null;
					let currentBlendSrcAlpha = null;
					let currentBlendDstAlpha = null;
					let currentPremultipledAlpha = false;

					let currentFlipSided = null;
					let currentCullFace = null;

					let currentLineWidth = null;

					let currentPolygonOffsetFactor = null;
					let currentPolygonOffsetUnits = null;

					const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);

					let lineWidthAvailable = false;
					let version = 0;
					const glVersion = gl.getParameter(gl.VERSION);

					if (glVersion.indexOf('WebGL') !== -1) {
						version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
						lineWidthAvailable = version >= 1.0;
					} else if (glVersion.indexOf('OpenGL ES') !== -1) {
						version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
						lineWidthAvailable = version >= 2.0;
					}

					let currentTextureSlot = null;
					let currentBoundTextures = {};

					const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
					const viewportParam = gl.getParameter(gl.VIEWPORT);

					const currentScissor = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__["Vector4"]().fromArray(scissorParam);
					const currentViewport = new _math_Vector4_js__WEBPACK_IMPORTED_MODULE_1__["Vector4"]().fromArray(viewportParam);

					function createTexture(type, target, count) {
						const data = new Uint8Array(4); // 4 is required to match default unpack alignment of 4.
						const texture = gl.createTexture();

						gl.bindTexture(type, texture);
						gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
						gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

						for (let i = 0; i < count; i++) {
							gl.texImage2D(
								target + i,
								0,
								gl.RGBA,
								1,
								1,
								0,
								gl.RGBA,
								gl.UNSIGNED_BYTE,
								data
							);
						}

						return texture;
					}

					const emptyTextures = {};
					emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
					emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(
						gl.TEXTURE_CUBE_MAP,
						gl.TEXTURE_CUBE_MAP_POSITIVE_X,
						6
					);

					// init

					colorBuffer.setClear(0, 0, 0, 1);
					depthBuffer.setClear(1);
					stencilBuffer.setClear(0);

					enable(gl.DEPTH_TEST);
					depthBuffer.setFunc(_constants_js__WEBPACK_IMPORTED_MODULE_0__["LessEqualDepth"]);

					setFlipSided(false);
					setCullFace(_constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceBack"]);
					enable(gl.CULL_FACE);

					setBlending(_constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"]);

					//

					function enable(id) {
						if (enabledCapabilities[id] !== true) {
							gl.enable(id);
							enabledCapabilities[id] = true;
						}
					}

					function disable(id) {
						if (enabledCapabilities[id] !== false) {
							gl.disable(id);
							enabledCapabilities[id] = false;
						}
					}

					function bindXRFramebuffer(framebuffer) {
						if (framebuffer !== xrFramebuffer) {
							gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

							xrFramebuffer = framebuffer;
						}
					}

					function bindFramebuffer(target, framebuffer) {
						if (framebuffer === null && xrFramebuffer !== null)
							framebuffer = xrFramebuffer; // use active XR framebuffer if available

						if (currentBoundFramebuffers[target] !== framebuffer) {
							gl.bindFramebuffer(target, framebuffer);

							currentBoundFramebuffers[target] = framebuffer;

							if (isWebGL2) {
								// gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

								if (target === gl.DRAW_FRAMEBUFFER) {
									currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
								}

								if (target === gl.FRAMEBUFFER) {
									currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
								}
							}

							return true;
						}

						return false;
					}

					function useProgram(program) {
						if (currentProgram !== program) {
							gl.useProgram(program);

							currentProgram = program;

							return true;
						}

						return false;
					}

					const equationToGL = {
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"]]: gl.FUNC_ADD,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["SubtractEquation"]]: gl.FUNC_SUBTRACT,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["ReverseSubtractEquation"]]: gl.FUNC_REVERSE_SUBTRACT
					};

					if (isWebGL2) {
						equationToGL[_constants_js__WEBPACK_IMPORTED_MODULE_0__["MinEquation"]] = gl.MIN;
						equationToGL[_constants_js__WEBPACK_IMPORTED_MODULE_0__["MaxEquation"]] = gl.MAX;
					} else {
						const extension = extensions.get('EXT_blend_minmax');

						if (extension !== null && extension !== undefined) {
							equationToGL[_constants_js__WEBPACK_IMPORTED_MODULE_0__["MinEquation"]] = extension.MIN_EXT;
							equationToGL[_constants_js__WEBPACK_IMPORTED_MODULE_0__["MaxEquation"]] = extension.MAX_EXT;
						}
					}

					const factorToGL = {
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["ZeroFactor"]]: gl.ZERO,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["OneFactor"]]: gl.ONE,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcColorFactor"]]: gl.SRC_COLOR,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcAlphaFactor"]]: gl.SRC_ALPHA,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["SrcAlphaSaturateFactor"]]: gl.SRC_ALPHA_SATURATE,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["DstColorFactor"]]: gl.DST_COLOR,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["DstAlphaFactor"]]: gl.DST_ALPHA,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusSrcColorFactor"]]: gl.ONE_MINUS_SRC_COLOR,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusSrcAlphaFactor"]]: gl.ONE_MINUS_SRC_ALPHA,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusDstColorFactor"]]: gl.ONE_MINUS_DST_COLOR,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["OneMinusDstAlphaFactor"]]: gl.ONE_MINUS_DST_ALPHA
					};

					function setBlending(
						blending,
						blendEquation,
						blendSrc,
						blendDst,
						blendEquationAlpha,
						blendSrcAlpha,
						blendDstAlpha,
						premultipliedAlpha
					) {
						if (blending === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"]) {
							if (currentBlendingEnabled === true) {
								disable(gl.BLEND);
								currentBlendingEnabled = false;
							}

							return;
						}

						if (currentBlendingEnabled === false) {
							enable(gl.BLEND);
							currentBlendingEnabled = true;
						}

						if (blending !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["CustomBlending"]) {
							if (
								blending !== currentBlending ||
								premultipliedAlpha !== currentPremultipledAlpha
							) {
								if (
									currentBlendEquation !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"] ||
									currentBlendEquationAlpha !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"]
								) {
									gl.blendEquation(gl.FUNC_ADD);

									currentBlendEquation = _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"];
									currentBlendEquationAlpha = _constants_js__WEBPACK_IMPORTED_MODULE_0__["AddEquation"];
								}

								if (premultipliedAlpha) {
									switch (blending) {
										case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalBlending"]:
											gl.blendFuncSeparate(
												gl.ONE,
												gl.ONE_MINUS_SRC_ALPHA,
												gl.ONE,
												gl.ONE_MINUS_SRC_ALPHA
											);
											break;

										case _constants_js__WEBPACK_IMPORTED_MODULE_0__["AdditiveBlending"]:
											gl.blendFunc(gl.ONE, gl.ONE);
											break;

										case _constants_js__WEBPACK_IMPORTED_MODULE_0__["SubtractiveBlending"]:
											gl.blendFuncSeparate(
												gl.ZERO,
												gl.ZERO,
												gl.ONE_MINUS_SRC_COLOR,
												gl.ONE_MINUS_SRC_ALPHA
											);
											break;

										case _constants_js__WEBPACK_IMPORTED_MODULE_0__["MultiplyBlending"]:
											gl.blendFuncSeparate(
												gl.ZERO,
												gl.SRC_COLOR,
												gl.ZERO,
												gl.SRC_ALPHA
											);
											break;

										default:
											console.error('THREE.WebGLState: Invalid blending: ', blending);
											break;
									}
								} else {
									switch (blending) {
										case _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalBlending"]:
											gl.blendFuncSeparate(
												gl.SRC_ALPHA,
												gl.ONE_MINUS_SRC_ALPHA,
												gl.ONE,
												gl.ONE_MINUS_SRC_ALPHA
											);
											break;

										case _constants_js__WEBPACK_IMPORTED_MODULE_0__["AdditiveBlending"]:
											gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
											break;

										case _constants_js__WEBPACK_IMPORTED_MODULE_0__["SubtractiveBlending"]:
											gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_COLOR);
											break;

										case _constants_js__WEBPACK_IMPORTED_MODULE_0__["MultiplyBlending"]:
											gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
											break;

										default:
											console.error('THREE.WebGLState: Invalid blending: ', blending);
											break;
									}
								}

								currentBlendSrc = null;
								currentBlendDst = null;
								currentBlendSrcAlpha = null;
								currentBlendDstAlpha = null;

								currentBlending = blending;
								currentPremultipledAlpha = premultipliedAlpha;
							}

							return;
						}

						// custom blending

						blendEquationAlpha = blendEquationAlpha || blendEquation;
						blendSrcAlpha = blendSrcAlpha || blendSrc;
						blendDstAlpha = blendDstAlpha || blendDst;

						if (
							blendEquation !== currentBlendEquation ||
							blendEquationAlpha !== currentBlendEquationAlpha
						) {
							gl.blendEquationSeparate(
								equationToGL[blendEquation],
								equationToGL[blendEquationAlpha]
							);

							currentBlendEquation = blendEquation;
							currentBlendEquationAlpha = blendEquationAlpha;
						}

						if (
							blendSrc !== currentBlendSrc ||
							blendDst !== currentBlendDst ||
							blendSrcAlpha !== currentBlendSrcAlpha ||
							blendDstAlpha !== currentBlendDstAlpha
						) {
							gl.blendFuncSeparate(
								factorToGL[blendSrc],
								factorToGL[blendDst],
								factorToGL[blendSrcAlpha],
								factorToGL[blendDstAlpha]
							);

							currentBlendSrc = blendSrc;
							currentBlendDst = blendDst;
							currentBlendSrcAlpha = blendSrcAlpha;
							currentBlendDstAlpha = blendDstAlpha;
						}

						currentBlending = blending;
						currentPremultipledAlpha = null;
					}

					function setMaterial(material, frontFaceCW) {
						material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DoubleSide"] ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);

						let flipSided = material.side === _constants_js__WEBPACK_IMPORTED_MODULE_0__["BackSide"];
						if (frontFaceCW) flipSided = !flipSided;

						setFlipSided(flipSided);

						material.blending === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NormalBlending"] && material.transparent === false
							? setBlending(_constants_js__WEBPACK_IMPORTED_MODULE_0__["NoBlending"])
							: setBlending(
								material.blending,
								material.blendEquation,
								material.blendSrc,
								material.blendDst,
								material.blendEquationAlpha,
								material.blendSrcAlpha,
								material.blendDstAlpha,
								material.premultipliedAlpha
							);

						depthBuffer.setFunc(material.depthFunc);
						depthBuffer.setTest(material.depthTest);
						depthBuffer.setMask(material.depthWrite);
						colorBuffer.setMask(material.colorWrite);

						const stencilWrite = material.stencilWrite;
						stencilBuffer.setTest(stencilWrite);
						if (stencilWrite) {
							stencilBuffer.setMask(material.stencilWriteMask);
							stencilBuffer.setFunc(
								material.stencilFunc,
								material.stencilRef,
								material.stencilFuncMask
							);
							stencilBuffer.setOp(
								material.stencilFail,
								material.stencilZFail,
								material.stencilZPass
							);
						}

						setPolygonOffset(
							material.polygonOffset,
							material.polygonOffsetFactor,
							material.polygonOffsetUnits
						);

						material.alphaToCoverage === true
							? enable(gl.SAMPLE_ALPHA_TO_COVERAGE)
							: disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
					}

					//

					function setFlipSided(flipSided) {
						if (currentFlipSided !== flipSided) {
							if (flipSided) {
								gl.frontFace(gl.CW);
							} else {
								gl.frontFace(gl.CCW);
							}

							currentFlipSided = flipSided;
						}
					}

					function setCullFace(cullFace) {
						if (cullFace !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceNone"]) {
							enable(gl.CULL_FACE);

							if (cullFace !== currentCullFace) {
								if (cullFace === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceBack"]) {
									gl.cullFace(gl.BACK);
								} else if (cullFace === _constants_js__WEBPACK_IMPORTED_MODULE_0__["CullFaceFront"]) {
									gl.cullFace(gl.FRONT);
								} else {
									gl.cullFace(gl.FRONT_AND_BACK);
								}
							}
						} else {
							disable(gl.CULL_FACE);
						}

						currentCullFace = cullFace;
					}

					function setLineWidth(width) {
						if (width !== currentLineWidth) {
							if (lineWidthAvailable) gl.lineWidth(width);

							currentLineWidth = width;
						}
					}

					function setPolygonOffset(polygonOffset, factor, units) {
						if (polygonOffset) {
							enable(gl.POLYGON_OFFSET_FILL);

							if (
								currentPolygonOffsetFactor !== factor ||
								currentPolygonOffsetUnits !== units
							) {
								gl.polygonOffset(factor, units);

								currentPolygonOffsetFactor = factor;
								currentPolygonOffsetUnits = units;
							}
						} else {
							disable(gl.POLYGON_OFFSET_FILL);
						}
					}

					function setScissorTest(scissorTest) {
						if (scissorTest) {
							enable(gl.SCISSOR_TEST);
						} else {
							disable(gl.SCISSOR_TEST);
						}
					}

					// texture

					function activeTexture(webglSlot) {
						if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;

						if (currentTextureSlot !== webglSlot) {
							gl.activeTexture(webglSlot);
							currentTextureSlot = webglSlot;
						}
					}

					function bindTexture(webglType, webglTexture) {
						if (currentTextureSlot === null) {
							activeTexture();
						}

						let boundTexture = currentBoundTextures[currentTextureSlot];

						if (boundTexture === undefined) {
							boundTexture = { type: undefined, texture: undefined };
							currentBoundTextures[currentTextureSlot] = boundTexture;
						}

						if (
							boundTexture.type !== webglType ||
							boundTexture.texture !== webglTexture
						) {
							gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);

							boundTexture.type = webglType;
							boundTexture.texture = webglTexture;
						}
					}

					function unbindTexture() {
						const boundTexture = currentBoundTextures[currentTextureSlot];

						if (boundTexture !== undefined && boundTexture.type !== undefined) {
							gl.bindTexture(boundTexture.type, null);

							boundTexture.type = undefined;
							boundTexture.texture = undefined;
						}
					}

					function compressedTexImage2D() {
						try {
							gl.compressedTexImage2D.apply(gl, arguments);
						} catch (error) {
							console.error('THREE.WebGLState:', error);
						}
					}

					function texImage2D() {
						try {
							gl.texImage2D.apply(gl, arguments);
						} catch (error) {
							console.error('THREE.WebGLState:', error);
						}
					}

					function texImage3D() {
						try {
							gl.texImage3D.apply(gl, arguments);
						} catch (error) {
							console.error('THREE.WebGLState:', error);
						}
					}

					//

					function scissor(scissor) {
						if (currentScissor.equals(scissor) === false) {
							gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
							currentScissor.copy(scissor);
						}
					}

					function viewport(viewport) {
						if (currentViewport.equals(viewport) === false) {
							gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
							currentViewport.copy(viewport);
						}
					}

					//

					function reset() {
						// reset state

						gl.disable(gl.BLEND);
						gl.disable(gl.CULL_FACE);
						gl.disable(gl.DEPTH_TEST);
						gl.disable(gl.POLYGON_OFFSET_FILL);
						gl.disable(gl.SCISSOR_TEST);
						gl.disable(gl.STENCIL_TEST);
						gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);

						gl.blendEquation(gl.FUNC_ADD);
						gl.blendFunc(gl.ONE, gl.ZERO);
						gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);

						gl.colorMask(true, true, true, true);
						gl.clearColor(0, 0, 0, 0);

						gl.depthMask(true);
						gl.depthFunc(gl.LESS);
						gl.clearDepth(1);

						gl.stencilMask(0xffffffff);
						gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
						gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
						gl.clearStencil(0);

						gl.cullFace(gl.BACK);
						gl.frontFace(gl.CCW);

						gl.polygonOffset(0, 0);

						gl.activeTexture(gl.TEXTURE0);

						gl.bindFramebuffer(gl.FRAMEBUFFER, null);

						if (isWebGL2 === true) {
							gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
							gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
						}

						gl.useProgram(null);

						gl.lineWidth(1);

						gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
						gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

						// reset internals

						enabledCapabilities = {};

						currentTextureSlot = null;
						currentBoundTextures = {};

						xrFramebuffer = null;
						currentBoundFramebuffers = {};

						currentProgram = null;

						currentBlendingEnabled = false;
						currentBlending = null;
						currentBlendEquation = null;
						currentBlendSrc = null;
						currentBlendDst = null;
						currentBlendEquationAlpha = null;
						currentBlendSrcAlpha = null;
						currentBlendDstAlpha = null;
						currentPremultipledAlpha = false;

						currentFlipSided = null;
						currentCullFace = null;

						currentLineWidth = null;

						currentPolygonOffsetFactor = null;
						currentPolygonOffsetUnits = null;

						currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
						currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);

						colorBuffer.reset();
						depthBuffer.reset();
						stencilBuffer.reset();
					}

					return {
						buffers: {
							color: colorBuffer,
							depth: depthBuffer,
							stencil: stencilBuffer
						},

						enable: enable,
						disable: disable,

						bindFramebuffer: bindFramebuffer,
						bindXRFramebuffer: bindXRFramebuffer,

						useProgram: useProgram,

						setBlending: setBlending,
						setMaterial: setMaterial,

						setFlipSided: setFlipSided,
						setCullFace: setCullFace,

						setLineWidth: setLineWidth,
						setPolygonOffset: setPolygonOffset,

						setScissorTest: setScissorTest,

						activeTexture: activeTexture,
						bindTexture: bindTexture,
						unbindTexture: unbindTexture,
						compressedTexImage2D: compressedTexImage2D,
						texImage2D: texImage2D,
						texImage3D: texImage3D,

						scissor: scissor,
						viewport: viewport,

						reset: reset
					};
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLTextures.js":
/*!*****************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLTextures.js ***!
  \*****************************************************/
/*! exports provided: WebGLTextures */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLTextures", function () { return WebGLTextures; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/MathUtils.js */ "./libs/three/math/MathUtils.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils.js */ "./libs/three/utils.js");




				function WebGLTextures(
					_gl,
					extensions,
					state,
					properties,
					capabilities,
					utils,
					info
				) {
					const isWebGL2 = capabilities.isWebGL2;
					const maxTextures = capabilities.maxTextures;
					const maxCubemapSize = capabilities.maxCubemapSize;
					const maxTextureSize = capabilities.maxTextureSize;
					const maxSamples = capabilities.maxSamples;

					const _videoTextures = new WeakMap();
					let _canvas;

					// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
					// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
					// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

					let useOffscreenCanvas = false;

					try {
						useOffscreenCanvas =
							typeof OffscreenCanvas !== 'undefined' &&
							new OffscreenCanvas(1, 1).getContext('2d') !== null;
					} catch (err) {
						// Ignore any errors
					}

					function createCanvas(width, height) {
						// Use OffscreenCanvas when available. Specially needed in web workers

						return useOffscreenCanvas
							? new OffscreenCanvas(width, height)
							: Object(_utils_js__WEBPACK_IMPORTED_MODULE_2__["createElementNS"])('canvas');
					}

					function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
						let scale = 1;

						// handle case if texture exceeds max size

						if (image.width > maxSize || image.height > maxSize) {
							scale = maxSize / Math.max(image.width, image.height);
						}

						// only perform resize if necessary

						if (scale < 1 || needsPowerOfTwo === true) {
							// only perform resize for certain image types

							if (
								(typeof HTMLImageElement !== 'undefined' &&
									image instanceof HTMLImageElement) ||
								(typeof HTMLCanvasElement !== 'undefined' &&
									image instanceof HTMLCanvasElement) ||
								(typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)
							) {
								const floor = needsPowerOfTwo ? _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["floorPowerOfTwo"] : Math.floor;

								const width = floor(scale * image.width);
								const height = floor(scale * image.height);

								if (_canvas === undefined) _canvas = createCanvas(width, height);

								// cube textures can't reuse the same canvas

								const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;

								canvas.width = width;
								canvas.height = height;

								const context = canvas.getContext('2d');
								context.drawImage(image, 0, 0, width, height);

								console.warn(
									'THREE.WebGLRenderer: Texture has been resized from (' +
									image.width +
									'x' +
									image.height +
									') to (' +
									width +
									'x' +
									height +
									').'
								);

								return canvas;
							} else {
								if ('data' in image) {
									console.warn(
										'THREE.WebGLRenderer: Image in DataTexture is too big (' +
										image.width +
										'x' +
										image.height +
										').'
									);
								}

								return image;
							}
						}

						return image;
					}

					function isPowerOfTwo(image) {
						return (
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["isPowerOfTwo"](image.width) &&
							_math_MathUtils_js__WEBPACK_IMPORTED_MODULE_1__["isPowerOfTwo"](image.height)
						);
					}

					function textureNeedsPowerOfTwo(texture) {
						if (isWebGL2) return false;

						return (
							texture.wrapS !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"] ||
							texture.wrapT !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"] ||
							(texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] &&
								texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"])
						);
					}

					function textureNeedsGenerateMipmaps(texture, supportsMips) {
						return (
							texture.generateMipmaps &&
							supportsMips &&
							texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] &&
							texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"]
						);
					}

					function generateMipmap(target, texture, width, height, depth = 1) {
						_gl.generateMipmap(target);

						const textureProperties = properties.get(texture);

						textureProperties.__maxMipLevel = Math.log2(Math.max(width, height, depth));
					}

					function getInternalFormat(internalFormatName, glFormat, glType, encoding) {
						if (isWebGL2 === false) return glFormat;

						if (internalFormatName !== null) {
							if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];

							console.warn(
								"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
								internalFormatName +
								"'"
							);
						}

						let internalFormat = glFormat;

						if (glFormat === _gl.RED) {
							if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
							if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
							if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
						}

						if (glFormat === _gl.RGB) {
							if (glType === _gl.FLOAT) internalFormat = _gl.RGB32F;
							if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGB16F;
							if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8;
						}

						if (glFormat === _gl.RGBA) {
							if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
							if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
							if (glType === _gl.UNSIGNED_BYTE)
								internalFormat =
									encoding === _constants_js__WEBPACK_IMPORTED_MODULE_0__["sRGBEncoding"] ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
						}

						if (
							internalFormat === _gl.R16F ||
							internalFormat === _gl.R32F ||
							internalFormat === _gl.RGBA16F ||
							internalFormat === _gl.RGBA32F
						) {
							extensions.get('EXT_color_buffer_float');
						}

						return internalFormat;
					}

					// Fallback filters for non-power-of-2 textures

					function filterFallback(f) {
						if (
							f === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] ||
							f === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapNearestFilter"] ||
							f === _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapLinearFilter"]
						) {
							return _gl.NEAREST;
						}

						return _gl.LINEAR;
					}

					//

					function onTextureDispose(event) {
						// console.log('销毁纹理前的纹理数:',info.memory.textures);
						const texture = event.target;

						texture.removeEventListener('dispose', onTextureDispose);

						deallocateTexture(texture);

						if (texture.isVideoTexture) {
							_videoTextures.delete(texture);
						}

						info.memory.textures--;
						console.log(`%c======销毁texture======当前texture数：${info.memory.textures}======`, 'color:orange;');
					}

					function onRenderTargetDispose(event) {
						const renderTarget = event.target;

						renderTarget.removeEventListener('dispose', onRenderTargetDispose);

						deallocateRenderTarget(renderTarget);
						console.log(`%c======销毁renderTarget======当前texture数：${info.memory.textures}======`, 'color:orange;');
					}

					//

					function deallocateTexture(texture) {
						const textureProperties = properties.get(texture);

						if (textureProperties.__webglInit === undefined) return;

						_gl.deleteTexture(textureProperties.__webglTexture);

						properties.remove(texture);
					}

					function deallocateRenderTarget(renderTarget) {
						const texture = renderTarget.texture;

						const renderTargetProperties = properties.get(renderTarget);
						const textureProperties = properties.get(texture);

						if (!renderTarget) return;

						if (textureProperties.__webglTexture !== undefined) {
							_gl.deleteTexture(textureProperties.__webglTexture);

							info.memory.textures--;
						}

						if (renderTarget.depthTexture) {
							renderTarget.depthTexture.dispose();
						}

						if (renderTarget.isWebGLCubeRenderTarget) {
							for (let i = 0; i < 6; i++) {
								_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
								if (renderTargetProperties.__webglDepthbuffer)
									_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
							}
						} else {
							_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
							if (renderTargetProperties.__webglDepthbuffer)
								_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
							if (renderTargetProperties.__webglMultisampledFramebuffer)
								_gl.deleteFramebuffer(
									renderTargetProperties.__webglMultisampledFramebuffer
								);
							if (renderTargetProperties.__webglColorRenderbuffer)
								_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);
							if (renderTargetProperties.__webglDepthRenderbuffer)
								_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
						}

						if (renderTarget.isWebGLMultipleRenderTargets) {
							for (let i = 0, il = texture.length; i < il; i++) {
								const attachmentProperties = properties.get(texture[i]);

								if (attachmentProperties.__webglTexture) {
									_gl.deleteTexture(attachmentProperties.__webglTexture);

									info.memory.textures--;
								}

								properties.remove(texture[i]);
							}
						}

						properties.remove(texture);
						properties.remove(renderTarget);
					}

					//

					let textureUnits = 0;

					function resetTextureUnits() {
						textureUnits = 0;
					}

					function allocateTextureUnit() {
						const textureUnit = textureUnits;

						if (textureUnit >= maxTextures) {
							console.warn(
								'THREE.WebGLTextures: Trying to use ' +
								textureUnit +
								' texture units while this GPU supports only ' +
								maxTextures
							);
						}

						textureUnits += 1;

						return textureUnit;
					}

					//

					function setTexture2D(texture, slot) {
						const textureProperties = properties.get(texture);

						if (texture.isVideoTexture) updateVideoTexture(texture);

						if (
							texture.version > 0 &&
							textureProperties.__version !== texture.version
						) {
							const image = texture.image;

							if (image === undefined) {
								console.warn(
									'THREE.WebGLRenderer: Texture marked for update but image is undefined'
								);
							} else if (image.complete === false) {
								console.warn(
									'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
								);
							} else {
								uploadTexture(textureProperties, texture, slot);
								return;
							}
						}

						state.activeTexture(_gl.TEXTURE0 + slot);
						state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);
					}

					function setTexture2DArray(texture, slot) {
						const textureProperties = properties.get(texture);

						if (
							texture.version > 0 &&
							textureProperties.__version !== texture.version
						) {
							uploadTexture(textureProperties, texture, slot);
							return;
						}

						state.activeTexture(_gl.TEXTURE0 + slot);
						state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);
					}

					function setTexture3D(texture, slot) {
						const textureProperties = properties.get(texture);

						if (
							texture.version > 0 &&
							textureProperties.__version !== texture.version
						) {
							uploadTexture(textureProperties, texture, slot);
							return;
						}

						state.activeTexture(_gl.TEXTURE0 + slot);
						state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);
					}

					function setTextureCube(texture, slot) {
						const textureProperties = properties.get(texture);

						if (
							texture.version > 0 &&
							textureProperties.__version !== texture.version
						) {
							uploadCubeTexture(textureProperties, texture, slot);
							return;
						}

						state.activeTexture(_gl.TEXTURE0 + slot);
						state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
					}

					const wrappingToGL = {
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["RepeatWrapping"]]: _gl.REPEAT,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"]]: _gl.CLAMP_TO_EDGE,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["MirroredRepeatWrapping"]]: _gl.MIRRORED_REPEAT
					};

					const filterToGL = {
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"]]: _gl.NEAREST,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapNearestFilter"]]: _gl.NEAREST_MIPMAP_NEAREST,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestMipmapLinearFilter"]]: _gl.NEAREST_MIPMAP_LINEAR,

						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"]]: _gl.LINEAR,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapNearestFilter"]]: _gl.LINEAR_MIPMAP_NEAREST,
						[_constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearMipmapLinearFilter"]]: _gl.LINEAR_MIPMAP_LINEAR
					};

					function setTextureParameters(textureType, texture, supportsMips) {
						if (supportsMips) {
							_gl.texParameteri(
								textureType,
								_gl.TEXTURE_WRAP_S,
								wrappingToGL[texture.wrapS]
							);
							_gl.texParameteri(
								textureType,
								_gl.TEXTURE_WRAP_T,
								wrappingToGL[texture.wrapT]
							);

							if (
								textureType === _gl.TEXTURE_3D ||
								textureType === _gl.TEXTURE_2D_ARRAY
							) {
								_gl.texParameteri(
									textureType,
									_gl.TEXTURE_WRAP_R,
									wrappingToGL[texture.wrapR]
								);
							}

							_gl.texParameteri(
								textureType,
								_gl.TEXTURE_MAG_FILTER,
								filterToGL[texture.magFilter]
							);
							_gl.texParameteri(
								textureType,
								_gl.TEXTURE_MIN_FILTER,
								filterToGL[texture.minFilter]
							);
						} else {
							_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
							_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);

							if (
								textureType === _gl.TEXTURE_3D ||
								textureType === _gl.TEXTURE_2D_ARRAY
							) {
								_gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
							}

							if (
								texture.wrapS !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"] ||
								texture.wrapT !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["ClampToEdgeWrapping"]
							) {
								console.warn(
									'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
								);
							}

							_gl.texParameteri(
								textureType,
								_gl.TEXTURE_MAG_FILTER,
								filterFallback(texture.magFilter)
							);
							_gl.texParameteri(
								textureType,
								_gl.TEXTURE_MIN_FILTER,
								filterFallback(texture.minFilter)
							);

							if (
								texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["NearestFilter"] &&
								texture.minFilter !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["LinearFilter"]
							) {
								console.warn(
									'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
								);
							}
						}

						if (extensions.has('EXT_texture_filter_anisotropic') === true) {
							const extension = extensions.get('EXT_texture_filter_anisotropic');

							if (
								texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] &&
								extensions.has('OES_texture_float_linear') === false
							)
								return; // verify extension for WebGL 1 and WebGL 2
							if (
								isWebGL2 === false &&
								(texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"] &&
									extensions.has('OES_texture_half_float_linear') === false)
							)
								return; // verify extension for WebGL 1 only

							if (
								texture.anisotropy > 1 ||
								properties.get(texture).__currentAnisotropy
							) {
								_gl.texParameterf(
									textureType,
									extension.TEXTURE_MAX_ANISOTROPY_EXT,
									Math.min(texture.anisotropy, capabilities.getMaxAnisotropy())
								);
								properties.get(texture).__currentAnisotropy = texture.anisotropy;
							}
						}
					}

					function initTexture(textureProperties, texture) {
						if (textureProperties.__webglInit === undefined) {
							textureProperties.__webglInit = true;
							// console.log("======texture监听事件dispose======")
							texture.addEventListener('dispose', onTextureDispose);

							textureProperties.__webglTexture = _gl.createTexture();
							info.memory.textures++;
							console.log(`%c======新增texture======当前texture数：${info.memory.textures}======`, 'color:green;');
							// let arr = texture.image&&texture.image.src?texture.image.src:texture;
							// console.log(arr)
						}
					}

					function uploadTexture(textureProperties, texture, slot) {
						let textureType = _gl.TEXTURE_2D;

						if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;
						if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;
						// 在这里会监听dispose事件
						initTexture(textureProperties, texture);

						state.activeTexture(_gl.TEXTURE0 + slot);
						state.bindTexture(textureType, textureProperties.__webglTexture);

						_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
						_gl.pixelStorei(
							_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
							texture.premultiplyAlpha
						);
						_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
						_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

						const needsPowerOfTwo =
							textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
						const image = resizeImage(
							texture.image,
							needsPowerOfTwo,
							false,
							maxTextureSize
						);

						const supportsMips = isPowerOfTwo(image) || isWebGL2,
							glFormat = utils.convert(texture.format);

						let glType = utils.convert(texture.type),
							glInternalFormat = getInternalFormat(
								texture.internalFormat,
								glFormat,
								glType,
								texture.encoding
							);

						setTextureParameters(textureType, texture, supportsMips);

						let mipmap;
						const mipmaps = texture.mipmaps;

						if (texture.isDepthTexture) {
							// populate depth texture with dummy data

							glInternalFormat = _gl.DEPTH_COMPONENT;

							if (isWebGL2) {
								if (texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"]) {
									glInternalFormat = _gl.DEPTH_COMPONENT32F;
								} else if (texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"]) {
									glInternalFormat = _gl.DEPTH_COMPONENT24;
								} else if (texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"]) {
									glInternalFormat = _gl.DEPTH24_STENCIL8;
								} else {
									glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D
								}
							} else {
								if (texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"]) {
									console.error(
										'WebGLRenderer: Floating point depth texture requires WebGL2.'
									);
								}
							}

							// validation checks for WebGL 1

							if (
								texture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthFormat"] &&
								glInternalFormat === _gl.DEPTH_COMPONENT
							) {
								// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
								// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
								// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
								if (
									texture.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShortType"] &&
									texture.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"]
								) {
									console.warn(
										'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
									);

									texture.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShortType"];
									glType = utils.convert(texture.type);
								}
							}

							if (
								texture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthStencilFormat"] &&
								glInternalFormat === _gl.DEPTH_COMPONENT
							) {
								// Depth stencil textures need the DEPTH_STENCIL internal format
								// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
								glInternalFormat = _gl.DEPTH_STENCIL;

								// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
								// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
								// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
								if (texture.type !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"]) {
									console.warn(
										'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
									);

									texture.type = _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"];
									glType = utils.convert(texture.type);
								}
							}

							//

							state.texImage2D(
								_gl.TEXTURE_2D,
								0,
								glInternalFormat,
								image.width,
								image.height,
								0,
								glFormat,
								glType,
								null
							);
						} else if (texture.isDataTexture) {
							// use manually created mipmaps if available
							// if there are no manual mipmaps
							// set 0 level mipmap and then use GL to generate other mipmap levels

							if (mipmaps.length > 0 && supportsMips) {
								for (let i = 0, il = mipmaps.length; i < il; i++) {
									mipmap = mipmaps[i];
									state.texImage2D(
										_gl.TEXTURE_2D,
										i,
										glInternalFormat,
										mipmap.width,
										mipmap.height,
										0,
										glFormat,
										glType,
										mipmap.data
									);
								}

								texture.generateMipmaps = false;
								textureProperties.__maxMipLevel = mipmaps.length - 1;
							} else {
								state.texImage2D(
									_gl.TEXTURE_2D,
									0,
									glInternalFormat,
									image.width,
									image.height,
									0,
									glFormat,
									glType,
									image.data
								);
								textureProperties.__maxMipLevel = 0;
							}
						} else if (texture.isCompressedTexture) {
							for (let i = 0, il = mipmaps.length; i < il; i++) {
								mipmap = mipmaps[i];

								if (texture.format !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] && texture.format !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"]) {
									if (glFormat !== null) {
										state.compressedTexImage2D(
											_gl.TEXTURE_2D,
											i,
											glInternalFormat,
											mipmap.width,
											mipmap.height,
											0,
											mipmap.data
										);
									} else {
										console.warn(
											'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
										);
									}
								} else {
									state.texImage2D(
										_gl.TEXTURE_2D,
										i,
										glInternalFormat,
										mipmap.width,
										mipmap.height,
										0,
										glFormat,
										glType,
										mipmap.data
									);
								}
							}

							textureProperties.__maxMipLevel = mipmaps.length - 1;
						} else if (texture.isDataTexture2DArray) {
							state.texImage3D(
								_gl.TEXTURE_2D_ARRAY,
								0,
								glInternalFormat,
								image.width,
								image.height,
								image.depth,
								0,
								glFormat,
								glType,
								image.data
							);
							textureProperties.__maxMipLevel = 0;
						} else if (texture.isDataTexture3D) {
							state.texImage3D(
								_gl.TEXTURE_3D,
								0,
								glInternalFormat,
								image.width,
								image.height,
								image.depth,
								0,
								glFormat,
								glType,
								image.data
							);
							textureProperties.__maxMipLevel = 0;
						} else {
							// regular Texture (image, video, canvas)

							// use manually created mipmaps if available
							// if there are no manual mipmaps
							// set 0 level mipmap and then use GL to generate other mipmap levels

							if (mipmaps.length > 0 && supportsMips) {
								for (let i = 0, il = mipmaps.length; i < il; i++) {
									mipmap = mipmaps[i];
									state.texImage2D(
										_gl.TEXTURE_2D,
										i,
										glInternalFormat,
										glFormat,
										glType,
										mipmap
									);
								}

								texture.generateMipmaps = false;
								textureProperties.__maxMipLevel = mipmaps.length - 1;
							} else {
								state.texImage2D(
									_gl.TEXTURE_2D,
									0,
									glInternalFormat,
									glFormat,
									glType,
									image
								);
								textureProperties.__maxMipLevel = 0;
							}
						}

						if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
							generateMipmap(textureType, texture, image.width, image.height);
						}

						textureProperties.__version = texture.version;

						if (texture.onUpdate) texture.onUpdate(texture);
					}

					function uploadCubeTexture(textureProperties, texture, slot) {
						if (texture.image.length !== 6) return;

						initTexture(textureProperties, texture);

						state.activeTexture(_gl.TEXTURE0 + slot);
						state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);

						_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
						_gl.pixelStorei(
							_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
							texture.premultiplyAlpha
						);
						_gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
						_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);

						const isCompressed =
							texture &&
							(texture.isCompressedTexture || texture.image[0].isCompressedTexture);
						const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;

						const cubeImage = [];

						for (let i = 0; i < 6; i++) {
							if (!isCompressed && !isDataTexture) {
								cubeImage[i] = resizeImage(
									texture.image[i],
									false,
									true,
									maxCubemapSize
								);
							} else {
								cubeImage[i] = isDataTexture
									? texture.image[i].image
									: texture.image[i];
							}
						}

						const image = cubeImage[0],
							supportsMips = isPowerOfTwo(image) || isWebGL2,
							glFormat = utils.convert(texture.format),
							glType = utils.convert(texture.type),
							glInternalFormat = getInternalFormat(
								texture.internalFormat,
								glFormat,
								glType,
								texture.encoding
							);

						setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);

						let mipmaps;

						if (isCompressed) {
							for (let i = 0; i < 6; i++) {
								mipmaps = cubeImage[i].mipmaps;

								for (let j = 0; j < mipmaps.length; j++) {
									const mipmap = mipmaps[j];

									if (texture.format !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"] && texture.format !== _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"]) {
										if (glFormat !== null) {
											state.compressedTexImage2D(
												_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
												j,
												glInternalFormat,
												mipmap.width,
												mipmap.height,
												0,
												mipmap.data
											);
										} else {
											console.warn(
												'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
											);
										}
									} else {
										state.texImage2D(
											_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
											j,
											glInternalFormat,
											mipmap.width,
											mipmap.height,
											0,
											glFormat,
											glType,
											mipmap.data
										);
									}
								}
							}

							textureProperties.__maxMipLevel = mipmaps.length - 1;
						} else {
							mipmaps = texture.mipmaps;

							for (let i = 0; i < 6; i++) {
								if (isDataTexture) {
									state.texImage2D(
										_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
										0,
										glInternalFormat,
										cubeImage[i].width,
										cubeImage[i].height,
										0,
										glFormat,
										glType,
										cubeImage[i].data
									);

									for (let j = 0; j < mipmaps.length; j++) {
										const mipmap = mipmaps[j];
										const mipmapImage = mipmap.image[i].image;

										state.texImage2D(
											_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
											j + 1,
											glInternalFormat,
											mipmapImage.width,
											mipmapImage.height,
											0,
											glFormat,
											glType,
											mipmapImage.data
										);
									}
								} else {
									state.texImage2D(
										_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
										0,
										glInternalFormat,
										glFormat,
										glType,
										cubeImage[i]
									);

									for (let j = 0; j < mipmaps.length; j++) {
										const mipmap = mipmaps[j];

										state.texImage2D(
											_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,
											j + 1,
											glInternalFormat,
											glFormat,
											glType,
											mipmap.image[i]
										);
									}
								}
							}

							textureProperties.__maxMipLevel = mipmaps.length;
						}

						if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
							// We assume images for cube map have the same size.
							generateMipmap(_gl.TEXTURE_CUBE_MAP, texture, image.width, image.height);
						}

						textureProperties.__version = texture.version;

						if (texture.onUpdate) texture.onUpdate(texture);
					}

					// Render targets

					// Setup storage for target texture and bind it to correct framebuffer
					function setupFrameBufferTexture(
						framebuffer,
						renderTarget,
						texture,
						attachment,
						textureTarget
					) {
						const glFormat = utils.convert(texture.format);
						const glType = utils.convert(texture.type);
						const glInternalFormat = getInternalFormat(
							texture.internalFormat,
							glFormat,
							glType,
							texture.encoding
						);

						if (
							textureTarget === _gl.TEXTURE_3D ||
							textureTarget === _gl.TEXTURE_2D_ARRAY
						) {
							state.texImage3D(
								textureTarget,
								0,
								glInternalFormat,
								renderTarget.width,
								renderTarget.height,
								renderTarget.depth,
								0,
								glFormat,
								glType,
								null
							);
						} else {
							state.texImage2D(
								textureTarget,
								0,
								glInternalFormat,
								renderTarget.width,
								renderTarget.height,
								0,
								glFormat,
								glType,
								null
							);
						}

						state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
						_gl.framebufferTexture2D(
							_gl.FRAMEBUFFER,
							attachment,
							textureTarget,
							properties.get(texture).__webglTexture,
							0
						);
						state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					}

					// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
					function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
						_gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);

						if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
							let glInternalFormat = _gl.DEPTH_COMPONENT16;

							if (isMultisample) {
								const depthTexture = renderTarget.depthTexture;

								if (depthTexture && depthTexture.isDepthTexture) {
									if (depthTexture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"]) {
										glInternalFormat = _gl.DEPTH_COMPONENT32F;
									} else if (depthTexture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"]) {
										glInternalFormat = _gl.DEPTH_COMPONENT24;
									}
								}

								const samples = getRenderTargetSamples(renderTarget);

								_gl.renderbufferStorageMultisample(
									_gl.RENDERBUFFER,
									samples,
									glInternalFormat,
									renderTarget.width,
									renderTarget.height
								);
							} else {
								_gl.renderbufferStorage(
									_gl.RENDERBUFFER,
									glInternalFormat,
									renderTarget.width,
									renderTarget.height
								);
							}

							_gl.framebufferRenderbuffer(
								_gl.FRAMEBUFFER,
								_gl.DEPTH_ATTACHMENT,
								_gl.RENDERBUFFER,
								renderbuffer
							);
						} else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
							if (isMultisample) {
								const samples = getRenderTargetSamples(renderTarget);

								_gl.renderbufferStorageMultisample(
									_gl.RENDERBUFFER,
									samples,
									_gl.DEPTH24_STENCIL8,
									renderTarget.width,
									renderTarget.height
								);
							} else {
								_gl.renderbufferStorage(
									_gl.RENDERBUFFER,
									_gl.DEPTH_STENCIL,
									renderTarget.width,
									renderTarget.height
								);
							}

							_gl.framebufferRenderbuffer(
								_gl.FRAMEBUFFER,
								_gl.DEPTH_STENCIL_ATTACHMENT,
								_gl.RENDERBUFFER,
								renderbuffer
							);
						} else {
							// Use the first texture for MRT so far
							const texture =
								renderTarget.isWebGLMultipleRenderTargets === true
									? renderTarget.texture[0]
									: renderTarget.texture;

							const glFormat = utils.convert(texture.format);
							const glType = utils.convert(texture.type);
							const glInternalFormat = getInternalFormat(
								texture.internalFormat,
								glFormat,
								glType,
								texture.encoding
							);

							if (isMultisample) {
								const samples = getRenderTargetSamples(renderTarget);

								_gl.renderbufferStorageMultisample(
									_gl.RENDERBUFFER,
									samples,
									glInternalFormat,
									renderTarget.width,
									renderTarget.height
								);
							} else {
								_gl.renderbufferStorage(
									_gl.RENDERBUFFER,
									glInternalFormat,
									renderTarget.width,
									renderTarget.height
								);
							}
						}

						_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
					}

					// Setup resources for a Depth Texture for a FBO (needs an extension)
					function setupDepthTexture(framebuffer, renderTarget) {
						const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
						if (isCube)
							throw new Error(
								'Depth Texture with cube render targets is not supported'
							);

						state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);

						if (
							!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)
						) {
							throw new Error(
								'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
							);
						}

						// upload an empty depth texture with framebuffer size
						if (
							!properties.get(renderTarget.depthTexture).__webglTexture ||
							renderTarget.depthTexture.image.width !== renderTarget.width ||
							renderTarget.depthTexture.image.height !== renderTarget.height
						) {
							renderTarget.depthTexture.image.width = renderTarget.width;
							renderTarget.depthTexture.image.height = renderTarget.height;
							renderTarget.depthTexture.needsUpdate = true;
						}

						setTexture2D(renderTarget.depthTexture, 0);

						const webglDepthTexture = properties.get(renderTarget.depthTexture)
							.__webglTexture;

						if (renderTarget.depthTexture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthFormat"]) {
							_gl.framebufferTexture2D(
								_gl.FRAMEBUFFER,
								_gl.DEPTH_ATTACHMENT,
								_gl.TEXTURE_2D,
								webglDepthTexture,
								0
							);
						} else if (renderTarget.depthTexture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthStencilFormat"]) {
							_gl.framebufferTexture2D(
								_gl.FRAMEBUFFER,
								_gl.DEPTH_STENCIL_ATTACHMENT,
								_gl.TEXTURE_2D,
								webglDepthTexture,
								0
							);
						} else {
							throw new Error('Unknown depthTexture format');
						}
					}

					// Setup GL resources for a non-texture depth buffer
					function setupDepthRenderbuffer(renderTarget) {
						const renderTargetProperties = properties.get(renderTarget);

						const isCube = renderTarget.isWebGLCubeRenderTarget === true;

						if (renderTarget.depthTexture) {
							if (isCube)
								throw new Error(
									'target.depthTexture not supported in Cube render targets'
								);

							setupDepthTexture(
								renderTargetProperties.__webglFramebuffer,
								renderTarget
							);
						} else {
							if (isCube) {
								renderTargetProperties.__webglDepthbuffer = [];

								for (let i = 0; i < 6; i++) {
									state.bindFramebuffer(
										_gl.FRAMEBUFFER,
										renderTargetProperties.__webglFramebuffer[i]
									);
									renderTargetProperties.__webglDepthbuffer[
										i
									] = _gl.createRenderbuffer();
									setupRenderBufferStorage(
										renderTargetProperties.__webglDepthbuffer[i],
										renderTarget,
										false
									);
								}
							} else {
								state.bindFramebuffer(
									_gl.FRAMEBUFFER,
									renderTargetProperties.__webglFramebuffer
								);
								renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
								setupRenderBufferStorage(
									renderTargetProperties.__webglDepthbuffer,
									renderTarget,
									false
								);
							}
						}

						state.bindFramebuffer(_gl.FRAMEBUFFER, null);
					}

					// Set up GL resources for the render target
					function setupRenderTarget(renderTarget) {
						const texture = renderTarget.texture;

						const renderTargetProperties = properties.get(renderTarget);
						const textureProperties = properties.get(texture);

						renderTarget.addEventListener('dispose', onRenderTargetDispose);

						if (renderTarget.isWebGLMultipleRenderTargets !== true) {
							textureProperties.__webglTexture = _gl.createTexture();
							textureProperties.__version = texture.version;
							info.memory.textures++;
							console.log(`%c======新增renderTarget======当前texture数：${info.memory.textures}======`, "color:green;")
						}

						const isCube = renderTarget.isWebGLCubeRenderTarget === true;
						const isMultipleRenderTargets =
							renderTarget.isWebGLMultipleRenderTargets === true;
						const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
						const isRenderTarget3D =
							texture.isDataTexture3D || texture.isDataTexture2DArray;
						const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

						// Handles WebGL2 RGBFormat fallback - #18858

						if (
							isWebGL2 &&
							texture.format === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"] &&
							(texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"] || texture.type === _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"])
						) {
							texture.format = _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"];

							console.warn(
								'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.'
							);
						}

						// Setup framebuffer

						if (isCube) {
							renderTargetProperties.__webglFramebuffer = [];

							for (let i = 0; i < 6; i++) {
								renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
							}
						} else {
							renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

							if (isMultipleRenderTargets) {
								if (capabilities.drawBuffers) {
									const textures = renderTarget.texture;

									for (let i = 0, il = textures.length; i < il; i++) {
										const attachmentProperties = properties.get(textures[i]);

										if (attachmentProperties.__webglTexture === undefined) {
											attachmentProperties.__webglTexture = _gl.createTexture();

											info.memory.textures++;
										}
									}
								} else {
									console.warn(
										'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.'
									);
								}
							} else if (isMultisample) {
								if (isWebGL2) {
									renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
									renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

									_gl.bindRenderbuffer(
										_gl.RENDERBUFFER,
										renderTargetProperties.__webglColorRenderbuffer
									);

									const glFormat = utils.convert(texture.format);
									const glType = utils.convert(texture.type);
									const glInternalFormat = getInternalFormat(
										texture.internalFormat,
										glFormat,
										glType,
										texture.encoding
									);
									const samples = getRenderTargetSamples(renderTarget);
									_gl.renderbufferStorageMultisample(
										_gl.RENDERBUFFER,
										samples,
										glInternalFormat,
										renderTarget.width,
										renderTarget.height
									);

									state.bindFramebuffer(
										_gl.FRAMEBUFFER,
										renderTargetProperties.__webglMultisampledFramebuffer
									);
									_gl.framebufferRenderbuffer(
										_gl.FRAMEBUFFER,
										_gl.COLOR_ATTACHMENT0,
										_gl.RENDERBUFFER,
										renderTargetProperties.__webglColorRenderbuffer
									);
									_gl.bindRenderbuffer(_gl.RENDERBUFFER, null);

									if (renderTarget.depthBuffer) {
										renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
										setupRenderBufferStorage(
											renderTargetProperties.__webglDepthRenderbuffer,
											renderTarget,
											true
										);
									}

									state.bindFramebuffer(_gl.FRAMEBUFFER, null);
								} else {
									console.warn(
										'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.'
									);
								}
							}
						}

						// Setup color buffer

						if (isCube) {
							state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
							setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);

							for (let i = 0; i < 6; i++) {
								setupFrameBufferTexture(
									renderTargetProperties.__webglFramebuffer[i],
									renderTarget,
									texture,
									_gl.COLOR_ATTACHMENT0,
									_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i
								);
							}

							if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
								generateMipmap(
									_gl.TEXTURE_CUBE_MAP,
									texture,
									renderTarget.width,
									renderTarget.height
								);
							}

							state.unbindTexture();
						} else if (isMultipleRenderTargets) {
							const textures = renderTarget.texture;

							for (let i = 0, il = textures.length; i < il; i++) {
								const attachment = textures[i];
								const attachmentProperties = properties.get(attachment);

								state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
								setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
								setupFrameBufferTexture(
									renderTargetProperties.__webglFramebuffer,
									renderTarget,
									attachment,
									_gl.COLOR_ATTACHMENT0 + i,
									_gl.TEXTURE_2D
								);

								if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
									generateMipmap(
										_gl.TEXTURE_2D,
										attachment,
										renderTarget.width,
										renderTarget.height
									);
								}
							}

							state.unbindTexture();
						} else {
							let glTextureType = _gl.TEXTURE_2D;

							if (isRenderTarget3D) {
								// Render targets containing layers, i.e: Texture 3D and 2d arrays

								if (isWebGL2) {
									const isTexture3D = texture.isDataTexture3D;
									glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
								} else {
									console.warn(
										'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.'
									);
								}
							}

							state.bindTexture(glTextureType, textureProperties.__webglTexture);
							setTextureParameters(glTextureType, texture, supportsMips);
							setupFrameBufferTexture(
								renderTargetProperties.__webglFramebuffer,
								renderTarget,
								texture,
								_gl.COLOR_ATTACHMENT0,
								glTextureType
							);

							if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
								generateMipmap(
									glTextureType,
									texture,
									renderTarget.width,
									renderTarget.height,
									renderTarget.depth
								);
							}

							state.unbindTexture();
						}

						// Setup depth and stencil buffers

						if (renderTarget.depthBuffer) {
							setupDepthRenderbuffer(renderTarget);
						}
					}

					function updateRenderTargetMipmap(renderTarget) {
						const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;

						const textures =
							renderTarget.isWebGLMultipleRenderTargets === true
								? renderTarget.texture
								: [renderTarget.texture];

						for (let i = 0, il = textures.length; i < il; i++) {
							const texture = textures[i];

							if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
								const target = renderTarget.isWebGLCubeRenderTarget
									? _gl.TEXTURE_CUBE_MAP
									: _gl.TEXTURE_2D;
								const webglTexture = properties.get(texture).__webglTexture;

								state.bindTexture(target, webglTexture);
								generateMipmap(
									target,
									texture,
									renderTarget.width,
									renderTarget.height
								);
								state.unbindTexture();
							}
						}
					}

					function updateMultisampleRenderTarget(renderTarget) {
						if (renderTarget.isWebGLMultisampleRenderTarget) {
							if (isWebGL2) {
								const width = renderTarget.width;
								const height = renderTarget.height;
								let mask = _gl.COLOR_BUFFER_BIT;

								if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
								if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;

								const renderTargetProperties = properties.get(renderTarget);

								state.bindFramebuffer(
									_gl.READ_FRAMEBUFFER,
									renderTargetProperties.__webglMultisampledFramebuffer
								);
								state.bindFramebuffer(
									_gl.DRAW_FRAMEBUFFER,
									renderTargetProperties.__webglFramebuffer
								);

								_gl.blitFramebuffer(
									0,
									0,
									width,
									height,
									0,
									0,
									width,
									height,
									mask,
									_gl.NEAREST
								);

								state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
								state.bindFramebuffer(
									_gl.DRAW_FRAMEBUFFER,
									renderTargetProperties.__webglMultisampledFramebuffer
								);
							} else {
								console.warn(
									'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.'
								);
							}
						}
					}

					function getRenderTargetSamples(renderTarget) {
						return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget
							? Math.min(maxSamples, renderTarget.samples)
							: 0;
					}

					function updateVideoTexture(texture) {
						const frame = info.render.frame;

						// Check the last frame we updated the VideoTexture

						if (_videoTextures.get(texture) !== frame) {
							_videoTextures.set(texture, frame);
							texture.update();
						}
					}

					// backwards compatibility

					let warnedTexture2D = false;
					let warnedTextureCube = false;

					function safeSetTexture2D(texture, slot) {
						if (texture && texture.isWebGLRenderTarget) {
							if (warnedTexture2D === false) {
								console.warn(
									"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
								);
								warnedTexture2D = true;
							}

							texture = texture.texture;
						}

						setTexture2D(texture, slot);
					}

					function safeSetTextureCube(texture, slot) {
						if (texture && texture.isWebGLCubeRenderTarget) {
							if (warnedTextureCube === false) {
								console.warn(
									"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
								);
								warnedTextureCube = true;
							}

							texture = texture.texture;
						}

						setTextureCube(texture, slot);
					}

					//

					this.allocateTextureUnit = allocateTextureUnit;
					this.resetTextureUnits = resetTextureUnits;

					this.setTexture2D = setTexture2D;
					this.setTexture2DArray = setTexture2DArray;
					this.setTexture3D = setTexture3D;
					this.setTextureCube = setTextureCube;
					this.setupRenderTarget = setupRenderTarget;
					this.updateRenderTargetMipmap = updateRenderTargetMipmap;
					this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

					this.safeSetTexture2D = safeSetTexture2D;
					this.safeSetTextureCube = safeSetTextureCube;
				}




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLUniforms.js":
/*!*****************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLUniforms.js ***!
  \*****************************************************/
/*! exports provided: WebGLUniforms */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUniforms", function () { return WebGLUniforms; });
/* harmony import */ var _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../textures/CubeTexture.js */ "./libs/three/textures/CubeTexture.js");
/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../textures/Texture.js */ "./libs/three/textures/Texture.js");
/* harmony import */ var _textures_DataTexture2DArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../textures/DataTexture2DArray.js */ "./libs/three/textures/DataTexture2DArray.js");
/* harmony import */ var _textures_DataTexture3D_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../textures/DataTexture3D.js */ "./libs/three/textures/DataTexture3D.js");
				/**
				 * Uniforms of a program.
				 * Those form a tree structure with a special top-level container for the root,
				 * which you get by calling 'new WebGLUniforms( gl, program )'.
				 *
				 *
				 * Properties of inner nodes including the top-level container:
				 *
				 * .seq - array of nested uniforms
				 * .map - nested uniforms by name
				 *
				 *
				 * Methods of all nodes except the top-level container:
				 *
				 * .setValue( gl, value, [textures] )
				 *
				 * 		uploads a uniform value(s)
				 *  	the 'textures' parameter is needed for sampler uniforms
				 *
				 *
				 * Static methods of the top-level container (textures factorizations):
				 *
				 * .upload( gl, seq, values, textures )
				 *
				 * 		sets uniforms in 'seq' to 'values[id].value'
				 *
				 * .seqWithValue( seq, values ) : filteredSeq
				 *
				 * 		filters 'seq' entries with corresponding entry in values
				 *
				 *
				 * Methods of the top-level container (textures factorizations):
				 *
				 * .setValue( gl, name, value, textures )
				 *
				 * 		sets uniform with  name 'name' to 'value'
				 *
				 * .setOptional( gl, obj, prop )
				 *
				 * 		like .set for an optional property of the object
				 *
				 */






				const emptyTexture = new _textures_Texture_js__WEBPACK_IMPORTED_MODULE_1__["Texture"]();
				const emptyTexture2dArray = new _textures_DataTexture2DArray_js__WEBPACK_IMPORTED_MODULE_2__["DataTexture2DArray"]();
				const emptyTexture3d = new _textures_DataTexture3D_js__WEBPACK_IMPORTED_MODULE_3__["DataTexture3D"]();
				const emptyCubeTexture = new _textures_CubeTexture_js__WEBPACK_IMPORTED_MODULE_0__["CubeTexture"]();

				// --- Utilities ---

				// Array Caches (provide typed arrays for temporary by size)

				const arrayCacheF32 = [];
				const arrayCacheI32 = [];

				// Float32Array caches used for uploading Matrix uniforms

				const mat4array = new Float32Array(16);
				const mat3array = new Float32Array(9);
				const mat2array = new Float32Array(4);

				// Flattening for arrays of vectors and matrices

				function flatten(array, nBlocks, blockSize) {
					const firstElem = array[0];

					if (firstElem <= 0 || firstElem > 0) return array;
					// unoptimized: ! isNaN( firstElem )
					// see http://jacksondunstan.com/articles/983

					const n = nBlocks * blockSize;
					let r = arrayCacheF32[n];

					if (r === undefined) {
						r = new Float32Array(n);
						arrayCacheF32[n] = r;
					}

					if (nBlocks !== 0) {
						firstElem.toArray(r, 0);

						for (let i = 1, offset = 0; i !== nBlocks; ++i) {
							offset += blockSize;
							array[i].toArray(r, offset);
						}
					}

					return r;
				}

				function arraysEqual(a, b) {
					if (a.length !== b.length) return false;

					for (let i = 0, l = a.length; i < l; i++) {
						if (a[i] !== b[i]) return false;
					}

					return true;
				}

				function copyArray(a, b) {
					for (let i = 0, l = b.length; i < l; i++) {
						a[i] = b[i];
					}
				}

				// Texture unit allocation

				function allocTexUnits(textures, n) {
					let r = arrayCacheI32[n];

					if (r === undefined) {
						r = new Int32Array(n);
						arrayCacheI32[n] = r;
					}

					for (let i = 0; i !== n; ++i) {
						r[i] = textures.allocateTextureUnit();
					}

					return r;
				}

				// --- Setters ---

				// Note: Defining these methods externally, because they come in a bunch
				// and this way their names minify.

				// Single scalar

				function setValueV1f(gl, v) {
					const cache = this.cache;

					if (cache[0] === v) return;

					gl.uniform1f(this.addr, v);

					cache[0] = v;
				}

				// Single float vector (from flat array or THREE.VectorN)

				function setValueV2f(gl, v) {
					const cache = this.cache;

					if (v.x !== undefined) {
						if (cache[0] !== v.x || cache[1] !== v.y) {
							gl.uniform2f(this.addr, v.x, v.y);

							cache[0] = v.x;
							cache[1] = v.y;
						}
					} else {
						if (arraysEqual(cache, v)) return;

						gl.uniform2fv(this.addr, v);

						copyArray(cache, v);
					}
				}

				function setValueV3f(gl, v) {
					const cache = this.cache;

					if (v.x !== undefined) {
						if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
							gl.uniform3f(this.addr, v.x, v.y, v.z);

							cache[0] = v.x;
							cache[1] = v.y;
							cache[2] = v.z;
						}
					} else if (v.r !== undefined) {
						if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
							gl.uniform3f(this.addr, v.r, v.g, v.b);

							cache[0] = v.r;
							cache[1] = v.g;
							cache[2] = v.b;
						}
					} else {
						if (arraysEqual(cache, v)) return;

						gl.uniform3fv(this.addr, v);

						copyArray(cache, v);
					}
				}

				function setValueV4f(gl, v) {
					const cache = this.cache;

					if (v.x !== undefined) {
						if (
							cache[0] !== v.x ||
							cache[1] !== v.y ||
							cache[2] !== v.z ||
							cache[3] !== v.w
						) {
							gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);

							cache[0] = v.x;
							cache[1] = v.y;
							cache[2] = v.z;
							cache[3] = v.w;
						}
					} else {
						if (arraysEqual(cache, v)) return;

						gl.uniform4fv(this.addr, v);

						copyArray(cache, v);
					}
				}

				// Single matrix (from flat array or THREE.MatrixN)

				function setValueM2(gl, v) {
					const cache = this.cache;
					const elements = v.elements;

					if (elements === undefined) {
						if (arraysEqual(cache, v)) return;

						gl.uniformMatrix2fv(this.addr, false, v);

						copyArray(cache, v);
					} else {
						if (arraysEqual(cache, elements)) return;

						mat2array.set(elements);

						gl.uniformMatrix2fv(this.addr, false, mat2array);

						copyArray(cache, elements);
					}
				}

				function setValueM3(gl, v) {
					const cache = this.cache;
					const elements = v.elements;

					if (elements === undefined) {
						if (arraysEqual(cache, v)) return;

						gl.uniformMatrix3fv(this.addr, false, v);

						copyArray(cache, v);
					} else {
						if (arraysEqual(cache, elements)) return;

						mat3array.set(elements);

						gl.uniformMatrix3fv(this.addr, false, mat3array);

						copyArray(cache, elements);
					}
				}

				function setValueM4(gl, v) {
					const cache = this.cache;
					const elements = v.elements;

					if (elements === undefined) {
						if (arraysEqual(cache, v)) return;

						gl.uniformMatrix4fv(this.addr, false, v);

						copyArray(cache, v);
					} else {
						if (arraysEqual(cache, elements)) return;

						mat4array.set(elements);

						gl.uniformMatrix4fv(this.addr, false, mat4array);

						copyArray(cache, elements);
					}
				}

				// Single integer / boolean

				function setValueV1i(gl, v) {
					const cache = this.cache;

					if (cache[0] === v) return;

					gl.uniform1i(this.addr, v);

					cache[0] = v;
				}

				// Single integer / boolean vector (from flat array)

				function setValueV2i(gl, v) {
					const cache = this.cache;

					if (arraysEqual(cache, v)) return;

					gl.uniform2iv(this.addr, v);

					copyArray(cache, v);
				}

				function setValueV3i(gl, v) {
					const cache = this.cache;

					if (arraysEqual(cache, v)) return;

					gl.uniform3iv(this.addr, v);

					copyArray(cache, v);
				}

				function setValueV4i(gl, v) {
					const cache = this.cache;

					if (arraysEqual(cache, v)) return;

					gl.uniform4iv(this.addr, v);

					copyArray(cache, v);
				}

				// Single unsigned integer

				function setValueV1ui(gl, v) {
					const cache = this.cache;

					if (cache[0] === v) return;

					gl.uniform1ui(this.addr, v);

					cache[0] = v;
				}

				// Single unsigned integer vector (from flat array)

				function setValueV2ui(gl, v) {
					const cache = this.cache;

					if (arraysEqual(cache, v)) return;

					gl.uniform2uiv(this.addr, v);

					copyArray(cache, v);
				}

				function setValueV3ui(gl, v) {
					const cache = this.cache;

					if (arraysEqual(cache, v)) return;

					gl.uniform3uiv(this.addr, v);

					copyArray(cache, v);
				}

				function setValueV4ui(gl, v) {
					const cache = this.cache;

					if (arraysEqual(cache, v)) return;

					gl.uniform4uiv(this.addr, v);

					copyArray(cache, v);
				}

				// Single texture (2D / Cube)

				function setValueT1(gl, v, textures) {
					const cache = this.cache;
					const unit = textures.allocateTextureUnit();

					if (cache[0] !== unit) {
						gl.uniform1i(this.addr, unit);
						cache[0] = unit;
					}

					textures.safeSetTexture2D(v || emptyTexture, unit);
				}

				function setValueT3D1(gl, v, textures) {
					const cache = this.cache;
					const unit = textures.allocateTextureUnit();

					if (cache[0] !== unit) {
						gl.uniform1i(this.addr, unit);
						cache[0] = unit;
					}

					textures.setTexture3D(v || emptyTexture3d, unit);
				}

				function setValueT6(gl, v, textures) {
					const cache = this.cache;
					const unit = textures.allocateTextureUnit();

					if (cache[0] !== unit) {
						gl.uniform1i(this.addr, unit);
						cache[0] = unit;
					}

					textures.safeSetTextureCube(v || emptyCubeTexture, unit);
				}

				function setValueT2DArray1(gl, v, textures) {
					const cache = this.cache;
					const unit = textures.allocateTextureUnit();

					if (cache[0] !== unit) {
						gl.uniform1i(this.addr, unit);
						cache[0] = unit;
					}

					textures.setTexture2DArray(v || emptyTexture2dArray, unit);
				}

				// Helper to pick the right setter for the singular case

				function getSingularSetter(type) {
					switch (type) {
						case 0x1406:
							return setValueV1f; // FLOAT
						case 0x8b50:
							return setValueV2f; // _VEC2
						case 0x8b51:
							return setValueV3f; // _VEC3
						case 0x8b52:
							return setValueV4f; // _VEC4

						case 0x8b5a:
							return setValueM2; // _MAT2
						case 0x8b5b:
							return setValueM3; // _MAT3
						case 0x8b5c:
							return setValueM4; // _MAT4

						case 0x1404:
						case 0x8b56:
							return setValueV1i; // INT, BOOL
						case 0x8b53:
						case 0x8b57:
							return setValueV2i; // _VEC2
						case 0x8b54:
						case 0x8b58:
							return setValueV3i; // _VEC3
						case 0x8b55:
						case 0x8b59:
							return setValueV4i; // _VEC4

						case 0x1405:
							return setValueV1ui; // UINT
						case 0x8dc6:
							return setValueV2ui; // _VEC2
						case 0x8dc7:
							return setValueV3ui; // _VEC3
						case 0x8dc8:
							return setValueV4ui; // _VEC4

						case 0x8b5e: // SAMPLER_2D
						case 0x8d66: // SAMPLER_EXTERNAL_OES
						case 0x8dca: // INT_SAMPLER_2D
						case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
						case 0x8b62: // SAMPLER_2D_SHADOW
							return setValueT1;

						case 0x8b5f: // SAMPLER_3D
						case 0x8dcb: // INT_SAMPLER_3D
						case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
							return setValueT3D1;

						case 0x8b60: // SAMPLER_CUBE
						case 0x8dcc: // INT_SAMPLER_CUBE
						case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
						case 0x8dc5: // SAMPLER_CUBE_SHADOW
							return setValueT6;

						case 0x8dc1: // SAMPLER_2D_ARRAY
						case 0x8dcf: // INT_SAMPLER_2D_ARRAY
						case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
						case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
							return setValueT2DArray1;
					}
				}

				// Array of scalars

				function setValueV1fArray(gl, v) {
					gl.uniform1fv(this.addr, v);
				}

				// Array of vectors (from flat array or array of THREE.VectorN)

				function setValueV2fArray(gl, v) {
					const data = flatten(v, this.size, 2);

					gl.uniform2fv(this.addr, data);
				}

				function setValueV3fArray(gl, v) {
					const data = flatten(v, this.size, 3);

					gl.uniform3fv(this.addr, data);
				}

				function setValueV4fArray(gl, v) {
					const data = flatten(v, this.size, 4);

					gl.uniform4fv(this.addr, data);
				}

				// Array of matrices (from flat array or array of THREE.MatrixN)

				function setValueM2Array(gl, v) {
					const data = flatten(v, this.size, 4);

					gl.uniformMatrix2fv(this.addr, false, data);
				}

				function setValueM3Array(gl, v) {
					const data = flatten(v, this.size, 9);

					gl.uniformMatrix3fv(this.addr, false, data);
				}

				function setValueM4Array(gl, v) {
					const data = flatten(v, this.size, 16);

					gl.uniformMatrix4fv(this.addr, false, data);
				}

				// Array of integer / boolean

				function setValueV1iArray(gl, v) {
					gl.uniform1iv(this.addr, v);
				}

				// Array of integer / boolean vectors (from flat array)

				function setValueV2iArray(gl, v) {
					gl.uniform2iv(this.addr, v);
				}

				function setValueV3iArray(gl, v) {
					gl.uniform3iv(this.addr, v);
				}

				function setValueV4iArray(gl, v) {
					gl.uniform4iv(this.addr, v);
				}

				// Array of unsigned integer

				function setValueV1uiArray(gl, v) {
					gl.uniform1uiv(this.addr, v);
				}

				// Array of unsigned integer vectors (from flat array)

				function setValueV2uiArray(gl, v) {
					gl.uniform2uiv(this.addr, v);
				}

				function setValueV3uiArray(gl, v) {
					gl.uniform3uiv(this.addr, v);
				}

				function setValueV4uiArray(gl, v) {
					gl.uniform4uiv(this.addr, v);
				}

				// Array of textures (2D / Cube)

				function setValueT1Array(gl, v, textures) {
					const n = v.length;

					const units = allocTexUnits(textures, n);

					gl.uniform1iv(this.addr, units);

					for (let i = 0; i !== n; ++i) {
						textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
					}
				}

				function setValueT6Array(gl, v, textures) {
					const n = v.length;

					const units = allocTexUnits(textures, n);

					gl.uniform1iv(this.addr, units);

					for (let i = 0; i !== n; ++i) {
						textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
					}
				}

				// Helper to pick the right setter for a pure (bottom-level) array

				function getPureArraySetter(type) {
					switch (type) {
						case 0x1406:
							return setValueV1fArray; // FLOAT
						case 0x8b50:
							return setValueV2fArray; // _VEC2
						case 0x8b51:
							return setValueV3fArray; // _VEC3
						case 0x8b52:
							return setValueV4fArray; // _VEC4

						case 0x8b5a:
							return setValueM2Array; // _MAT2
						case 0x8b5b:
							return setValueM3Array; // _MAT3
						case 0x8b5c:
							return setValueM4Array; // _MAT4

						case 0x1404:
						case 0x8b56:
							return setValueV1iArray; // INT, BOOL
						case 0x8b53:
						case 0x8b57:
							return setValueV2iArray; // _VEC2
						case 0x8b54:
						case 0x8b58:
							return setValueV3iArray; // _VEC3
						case 0x8b55:
						case 0x8b59:
							return setValueV4iArray; // _VEC4

						case 0x1405:
							return setValueV1uiArray; // UINT
						case 0x8dc6:
							return setValueV2uiArray; // _VEC2
						case 0x8dc7:
							return setValueV3uiArray; // _VEC3
						case 0x8dc8:
							return setValueV4uiArray; // _VEC4

						case 0x8b5e: // SAMPLER_2D
						case 0x8d66: // SAMPLER_EXTERNAL_OES
						case 0x8dca: // INT_SAMPLER_2D
						case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
						case 0x8b62: // SAMPLER_2D_SHADOW
							return setValueT1Array;

						case 0x8b60: // SAMPLER_CUBE
						case 0x8dcc: // INT_SAMPLER_CUBE
						case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
						case 0x8dc5: // SAMPLER_CUBE_SHADOW
							return setValueT6Array;
					}
				}

				// --- Uniform Classes ---

				function SingleUniform(id, activeInfo, addr) {
					this.id = id;
					this.addr = addr;
					this.cache = [];
					this.setValue = getSingularSetter(activeInfo.type);

					// this.path = activeInfo.name; // DEBUG
				}

				function PureArrayUniform(id, activeInfo, addr) {
					this.id = id;
					this.addr = addr;
					this.cache = [];
					this.size = activeInfo.size;
					this.setValue = getPureArraySetter(activeInfo.type);

					// this.path = activeInfo.name; // DEBUG
				}

				PureArrayUniform.prototype.updateCache = function (data) {
					const cache = this.cache;

					if (data instanceof Float32Array && cache.length !== data.length) {
						this.cache = new Float32Array(data.length);
					}

					copyArray(cache, data);
				};

				function StructuredUniform(id) {
					this.id = id;

					this.seq = [];
					this.map = {};
				}

				StructuredUniform.prototype.setValue = function (gl, value, textures) {
					const seq = this.seq;

					for (let i = 0, n = seq.length; i !== n; ++i) {
						const u = seq[i];
						u.setValue(gl, value[u.id], textures);
					}
				};

				// --- Top-level ---

				// Parser - builds up the property tree from the path strings

				const RePathPart = /(\w+)(\])?(\[|\.)?/g;

				// extracts
				// 	- the identifier (member name or array index)
				//  - followed by an optional right bracket (found when array index)
				//  - followed by an optional left bracket or dot (type of subscript)
				//
				// Note: These portions can be read in a non-overlapping fashion and
				// allow straightforward parsing of the hierarchy that WebGL encodes
				// in the uniform names.

				function addUniform(container, uniformObject) {
					container.seq.push(uniformObject);
					container.map[uniformObject.id] = uniformObject;
				}

				function parseUniform(activeInfo, addr, container) {
					const path = activeInfo.name,
						pathLength = path.length;

					// reset RegExp object, because of the early exit of a previous run
					RePathPart.lastIndex = 0;

					while (true) {
						const match = RePathPart.exec(path),
							matchEnd = RePathPart.lastIndex;

						let id = match[1];
						const idIsIndex = match[2] === ']',
							subscript = match[3];

						if (idIsIndex) id = id | 0; // convert to integer

						if (
							subscript === undefined ||
							(subscript === '[' && matchEnd + 2 === pathLength)
						) {
							// bare name or "pure" bottom-level array "[0]" suffix

							addUniform(
								container,
								subscript === undefined
									? new SingleUniform(id, activeInfo, addr)
									: new PureArrayUniform(id, activeInfo, addr)
							);

							break;
						} else {
							// step into inner node / create it in case it doesn't exist

							const map = container.map;
							let next = map[id];

							if (next === undefined) {
								next = new StructuredUniform(id);
								addUniform(container, next);
							}

							container = next;
						}
					}
				}

				// Root Container

				function WebGLUniforms(gl, program) {
					this.seq = [];
					this.map = {};

					const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);

					for (let i = 0; i < n; ++i) {
						const info = gl.getActiveUniform(program, i),
							addr = gl.getUniformLocation(program, info.name);

						parseUniform(info, addr, this);
					}
				}

				WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
					const u = this.map[name];

					if (u !== undefined) u.setValue(gl, value, textures);
				};

				WebGLUniforms.prototype.setOptional = function (gl, object, name) {
					const v = object[name];

					if (v !== undefined) this.setValue(gl, name, v);
				};

				// Static interface

				WebGLUniforms.upload = function (gl, seq, values, textures) {
					for (let i = 0, n = seq.length; i !== n; ++i) {
						const u = seq[i],
							v = values[u.id];

						if (v.needsUpdate !== false) {
							// note: always updating when .needsUpdate is undefined
							u.setValue(gl, v.value, textures);
						}
					}
				};

				WebGLUniforms.seqWithValue = function (seq, values) {
					const r = [];

					for (let i = 0, n = seq.length; i !== n; ++i) {
						const u = seq[i];
						if (u.id in values) r.push(u);
					}

					return r;
				};




				/***/
}),

/***/ "./libs/three/renderers/webgl/WebGLUtils.js":
/*!**************************************************!*\
  !*** ./libs/three/renderers/webgl/WebGLUtils.js ***!
  \**************************************************/
/*! exports provided: WebGLUtils */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function () { return WebGLUtils; });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./libs/three/constants.js");


				function WebGLUtils(gl, extensions, capabilities) {
					const isWebGL2 = capabilities.isWebGL2;

					function convert(p) {
						let extension;

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedByteType"]) return gl.UNSIGNED_BYTE;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort4444Type"]) return gl.UNSIGNED_SHORT_4_4_4_4;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort5551Type"]) return gl.UNSIGNED_SHORT_5_5_5_1;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShort565Type"]) return gl.UNSIGNED_SHORT_5_6_5;

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["ByteType"]) return gl.BYTE;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["ShortType"]) return gl.SHORT;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedShortType"]) return gl.UNSIGNED_SHORT;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["IntType"]) return gl.INT;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedIntType"]) return gl.UNSIGNED_INT;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["FloatType"]) return gl.FLOAT;

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["HalfFloatType"]) {
							if (isWebGL2) return gl.HALF_FLOAT;

							extension = extensions.get('OES_texture_half_float');

							if (extension !== null) {
								return extension.HALF_FLOAT_OES;
							} else {
								return null;
							}
						}

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["AlphaFormat"]) return gl.ALPHA;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBFormat"]) return gl.RGB;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAFormat"]) return gl.RGBA;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LuminanceFormat"]) return gl.LUMINANCE;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["LuminanceAlphaFormat"]) return gl.LUMINANCE_ALPHA;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthFormat"]) return gl.DEPTH_COMPONENT;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["DepthStencilFormat"]) return gl.DEPTH_STENCIL;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RedFormat"]) return gl.RED;

						// WebGL2 formats.

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RedIntegerFormat"]) return gl.RED_INTEGER;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGFormat"]) return gl.RG;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGIntegerFormat"]) return gl.RG_INTEGER;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBIntegerFormat"]) return gl.RGB_INTEGER;
						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBAIntegerFormat"]) return gl.RGBA_INTEGER;

						if (
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_S3TC_DXT1_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT1_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT3_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT5_Format"]
						) {
							extension = extensions.get('WEBGL_compressed_texture_s3tc');

							if (extension !== null) {
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_S3TC_DXT1_Format"])
									return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT1_Format"])
									return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT3_Format"])
									return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_S3TC_DXT5_Format"])
									return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
							} else {
								return null;
							}
						}

						if (
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_4BPPV1_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_2BPPV1_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_4BPPV1_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_2BPPV1_Format"]
						) {
							extension = extensions.get('WEBGL_compressed_texture_pvrtc');

							if (extension !== null) {
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_4BPPV1_Format"])
									return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_PVRTC_2BPPV1_Format"])
									return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_4BPPV1_Format"])
									return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_PVRTC_2BPPV1_Format"])
									return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
							} else {
								return null;
							}
						}

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_ETC1_Format"]) {
							extension = extensions.get('WEBGL_compressed_texture_etc1');

							if (extension !== null) {
								return extension.COMPRESSED_RGB_ETC1_WEBGL;
							} else {
								return null;
							}
						}

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_ETC2_Format"] || p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ETC2_EAC_Format"]) {
							extension = extensions.get('WEBGL_compressed_texture_etc');

							if (extension !== null) {
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGB_ETC2_Format"]) return extension.COMPRESSED_RGB8_ETC2;
								if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ETC2_EAC_Format"])
									return extension.COMPRESSED_RGBA8_ETC2_EAC;
							}
						}

						if (
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_4x4_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_5x4_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_5x5_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_6x5_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_6x6_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x5_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x6_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_8x8_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x5_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x6_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x8_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_10x10_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_12x10_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_ASTC_12x12_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_4x4_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_5x4_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_5x5_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_6x5_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_6x6_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x5_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x6_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_8x8_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x5_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x6_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x8_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_10x10_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_12x10_Format"] ||
							p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["SRGB8_ALPHA8_ASTC_12x12_Format"]
						) {
							extension = extensions.get('WEBGL_compressed_texture_astc');

							if (extension !== null) {
								// TODO Complete?

								return p;
							} else {
								return null;
							}
						}

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["RGBA_BPTC_Format"]) {
							extension = extensions.get('EXT_texture_compression_bptc');

							if (extension !== null) {
								// TODO Complete?

								return p;
							} else {
								return null;
							}
						}

						if (p === _constants_js__WEBPACK_IMPORTED_MODULE_0__["UnsignedInt248Type"]) {
							if (isWebGL2) return gl.UNSIGNED_INT_24_8;

							extension = extensions.get('WEBGL_depth_texture');

							if (extension !== null) {
								return extension.UNSIGNED_INT_24_8_WEBGL;
							} else {
								return null;
							}
						}
					}

					return { convert: convert };
				}




				/***/
}),

/***/ "./libs/three/scenes/Scene.js":
/*!************************************!*\
  !*** ./libs/three/scenes/Scene.js ***!
  \************************************/
/*! exports provided: Scene */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function () { return Scene; });
/* harmony import */ var _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Object3D.js */ "./libs/three/core/Object3D.js");


				class Scene extends _core_Object3D_js__WEBPACK_IMPORTED_MODULE_0__["Object3D"] {
					constructor() {
						super();

						this.type = 'Scene';

						this.background = null;
						this.environment = null;
						this.fog = null;

						this.overrideMaterial = null;

						this.autoUpdate = true; // checked by the renderer

						if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
							__THREE_DEVTOOLS__.dispatchEvent(
								new CustomEvent('observe', { detail: this })
							); // eslint-disable-line no-undef
						}
					}

					copy(source, recursive) {
						super.copy(source, recursive);

						if (source.background !== null) this.background = source.background.clone();
						if (source.environment !== null)
							this.environment = source.environment.clone();
						if (source.fog !== null) this.fog = source.fog.clone();

						if (source.overrideMaterial !== null)
							this.overrideMaterial = source.overrideMaterial.clone();

						this.autoUpdate = source.autoUpdate;
						this.matrixAutoUpdate = source.matrixAutoUpdate;

						return this;
					}

					toJSON(meta) {
						const data = super.toJSON(meta);

						if (this.fog !== null) data.object.fog = this.fog.toJSON();

						return data;
					}
				}

				Scene.prototype.isScene = true;




				/***/
}),

/***/ "./libs/three/shaders/CopyShader.js":
/*!******************************************!*\
  !*** ./libs/three/shaders/CopyShader.js ***!
  \******************************************/
/*! exports provided: CopyShader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CopyShader", function () { return CopyShader; });
				/**
				 * Full-screen textured quad shader
				 */

				const CopyShader = {

					uniforms: {

						'tDiffuse': { value: null },
						'opacity': { value: 1.0 }

					},

					vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

					fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`

				};




				/***/
}),

/***/ "./libs/three/shaders/FXAAShader.js":
/*!******************************************!*\
  !*** ./libs/three/shaders/FXAAShader.js ***!
  \******************************************/
/*! exports provided: FXAAShader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FXAAShader", function () { return FXAAShader; });
/* harmony import */ var _math_Vector2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Vector2 */ "./libs/three/math/Vector2.js");


				/**
				 * NVIDIA FXAA by Timothy Lottes
				 * https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf
				 * - WebGL port by @supereggbert
				 * http://www.glge.org/demos/fxaa/
				 * Further improved by Daniel Sturk
				 */

				const FXAAShader = {

					uniforms: {

						'tDiffuse': { value: null },
						'resolution': { value: new _math_Vector2__WEBPACK_IMPORTED_MODULE_0__["Vector2"](1 / 1024, 1 / 512) }

					},

					vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

					fragmentShader: `
	precision highp float;

	uniform sampler2D tDiffuse;

	uniform vec2 resolution;

	varying vec2 vUv;

	// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

	//----------------------------------------------------------------------------------
	// File:        es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag
	// SDK Version: v3.00
	// Email:       gameworks@nvidia.com
	// Site:        http://developer.nvidia.com/
	//
	// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions
	// are met:
	//  * Redistributions of source code must retain the above copyright
	//    notice, this list of conditions and the following disclaimer.
	//  * Redistributions in binary form must reproduce the above copyright
	//    notice, this list of conditions and the following disclaimer in the
	//    documentation and/or other materials provided with the distribution.
	//  * Neither the name of NVIDIA CORPORATION nor the names of its
	//    contributors may be used to endorse or promote products derived
	//    from this software without specific prior written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
	// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	//
	//----------------------------------------------------------------------------------

	#ifndef FXAA_DISCARD
			//
			// Only valid for PC OpenGL currently.
			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
			//
			// 1 = Use discard on pixels which don't need AA.
			//     For APIs which enable concurrent TEX+ROP from same surface.
			// 0 = Return unchanged color on pixels which don't need AA.
			//
			#define FXAA_DISCARD 0
	#endif

	/*--------------------------------------------------------------------------*/
	#define FxaaTexTop(t, p) texture2D(t, p, -100.0)
	#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)
	/*--------------------------------------------------------------------------*/

	#define NUM_SAMPLES 5

	// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha
	float contrast( vec4 a, vec4 b ) {
			vec4 diff = abs( a - b );
			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );
	}

	/*============================================================================

									FXAA3 QUALITY - PC

	============================================================================*/

	/*--------------------------------------------------------------------------*/
	vec4 FxaaPixelShader(
			vec2 posM,
			sampler2D tex,
			vec2 fxaaQualityRcpFrame,
			float fxaaQualityEdgeThreshold,
			float fxaaQualityinvEdgeThreshold
	) {
			vec4 rgbaM = FxaaTexTop(tex, posM);
			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);
			// . S .
			// W M E
			// . N .

			bool earlyExit = max( max( max(
					contrast( rgbaM, rgbaN ),
					contrast( rgbaM, rgbaS ) ),
					contrast( rgbaM, rgbaE ) ),
					contrast( rgbaM, rgbaW ) )
					< fxaaQualityEdgeThreshold;
			// . 0 .
			// 0 0 0
			// . 0 .

			#if (FXAA_DISCARD == 1)
					if(earlyExit) FxaaDiscard;
			#else
					if(earlyExit) return rgbaM;
			#endif

			float contrastN = contrast( rgbaM, rgbaN );
			float contrastS = contrast( rgbaM, rgbaS );
			float contrastE = contrast( rgbaM, rgbaE );
			float contrastW = contrast( rgbaM, rgbaW );

			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );
			relativeVContrast *= fxaaQualityinvEdgeThreshold;

			bool horzSpan = relativeVContrast > 0.;
			// . 1 .
			// 0 0 0
			// . 1 .

			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar
			if( abs( relativeVContrast ) < .3 ) {
					// locate the edge
					vec2 dirToEdge;
					dirToEdge.x = contrastE > contrastW ? 1. : -1.;
					dirToEdge.y = contrastS > contrastN ? 1. : -1.;
					// . 2 .      . 1 .
					// 1 0 2  ~=  0 0 1
					// . 1 .      . 0 .

					// tap 2 pixels and see which ones are "outside" the edge, to
					// determine if the edge is vertical or horizontal

					vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);
					float matchAlongH = contrast( rgbaM, rgbaAlongH );
					// . 1 .
					// 0 0 1
					// . 0 H

					vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);
					float matchAlongV = contrast( rgbaM, rgbaAlongV );
					// V 1 .
					// 0 0 1
					// . 0 .

					relativeVContrast = matchAlongV - matchAlongH;
					relativeVContrast *= fxaaQualityinvEdgeThreshold;

					if( abs( relativeVContrast ) < .3 ) { // 45 deg edge
							// 1 1 .
							// 0 0 1
							// . 0 1

							// do a simple blur
							return mix(
									rgbaM,
									(rgbaN + rgbaS + rgbaE + rgbaW) * .25,
									.4
							);
					}

					horzSpan = relativeVContrast > 0.;
			}

			if(!horzSpan) rgbaN = rgbaW;
			if(!horzSpan) rgbaS = rgbaE;
			// . 0 .      1
			// 1 0 1  ->  0
			// . 0 .      1

			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );
			if(!pairN) rgbaN = rgbaS;

			vec2 offNP;
			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;

			bool doneN = false;
			bool doneP = false;

			float nDist = 0.;
			float pDist = 0.;

			vec2 posN = posM;
			vec2 posP = posM;

			int iterationsUsed = 0;
			int iterationsUsedN = 0;
			int iterationsUsedP = 0;
			for( int i = 0; i < NUM_SAMPLES; i++ ) {
					iterationsUsed = i;

					float increment = float(i + 1);

					if(!doneN) {
							nDist += increment;
							posN = posM + offNP * nDist;
							vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);
							doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );
							iterationsUsedN = i;
					}

					if(!doneP) {
							pDist += increment;
							posP = posM - offNP * pDist;
							vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);
							doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );
							iterationsUsedP = i;
					}

					if(doneN || doneP) break;
			}


			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge

			float dist = min(
					doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,
					doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.
			);

			// hacky way of reduces blurriness of mostly diagonal edges
			// but reduces AA quality
			dist = pow(dist, .5);

			dist = 1. - dist;

			return mix(
					rgbaM,
					rgbaN,
					dist * .5
			);
	}

	void main() {
			const float edgeDetectionQuality = .2;
			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;

			gl_FragColor = FxaaPixelShader(
					vUv,
					tDiffuse,
					resolution,
					edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard
					invEdgeDetectionQuality
			);

	}
	`

				};




				/***/
}),

/***/ "./libs/three/textures/CubeTexture.js":
/*!********************************************!*\
  !*** ./libs/three/textures/CubeTexture.js ***!
  \********************************************/
/*! exports provided: CubeTexture */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function () { return CubeTexture; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "./libs/three/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");



				class CubeTexture extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {
					constructor(
						images,
						mapping,
						wrapS,
						wrapT,
						magFilter,
						minFilter,
						format,
						type,
						anisotropy,
						encoding
					) {
						images = images !== undefined ? images : [];
						mapping = mapping !== undefined ? mapping : _constants_js__WEBPACK_IMPORTED_MODULE_1__["CubeReflectionMapping"];

						super(
							images,
							mapping,
							wrapS,
							wrapT,
							magFilter,
							minFilter,
							format,
							type,
							anisotropy,
							encoding
						);

						this.flipY = false;
					}

					get images() {
						return this.image;
					}

					set images(value) {
						this.image = value;
					}
				}

				CubeTexture.prototype.isCubeTexture = true;




				/***/
}),

/***/ "./libs/three/textures/DataTexture.js":
/*!********************************************!*\
  !*** ./libs/three/textures/DataTexture.js ***!
  \********************************************/
/*! exports provided: DataTexture */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function () { return DataTexture; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "./libs/three/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");



				class DataTexture extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {
					constructor(
						data = null,
						width = 1,
						height = 1,
						format,
						type,
						mapping,
						wrapS,
						wrapT,
						magFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"],
						minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"],
						anisotropy,
						encoding
					) {
						super(
							null,
							mapping,
							wrapS,
							wrapT,
							magFilter,
							minFilter,
							format,
							type,
							anisotropy,
							encoding
						);

						this.image = { data: data, width: width, height: height };

						this.magFilter = magFilter;
						this.minFilter = minFilter;

						this.generateMipmaps = false;
						this.flipY = false;
						this.unpackAlignment = 1;

						this.needsUpdate = true;
					}
				}

				DataTexture.prototype.isDataTexture = true;




				/***/
}),

/***/ "./libs/three/textures/DataTexture2DArray.js":
/*!***************************************************!*\
  !*** ./libs/three/textures/DataTexture2DArray.js ***!
  \***************************************************/
/*! exports provided: DataTexture2DArray */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture2DArray", function () { return DataTexture2DArray; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "./libs/three/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");



				class DataTexture2DArray extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {
					constructor(data = null, width = 1, height = 1, depth = 1) {
						super(null);

						this.image = { data, width, height, depth };

						this.magFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];
						this.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];

						this.wrapR = _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"];

						this.generateMipmaps = false;
						this.flipY = false;
						this.unpackAlignment = 1;

						this.needsUpdate = true;
					}
				}

				DataTexture2DArray.prototype.isDataTexture2DArray = true;




				/***/
}),

/***/ "./libs/three/textures/DataTexture3D.js":
/*!**********************************************!*\
  !*** ./libs/three/textures/DataTexture3D.js ***!
  \**********************************************/
/*! exports provided: DataTexture3D */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function () { return DataTexture3D; });
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "./libs/three/textures/Texture.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");



				class DataTexture3D extends _Texture_js__WEBPACK_IMPORTED_MODULE_0__["Texture"] {
					constructor(data = null, width = 1, height = 1, depth = 1) {
						// We're going to add .setXXX() methods for setting properties later.
						// Users can still set in DataTexture3D directly.
						//
						//	const texture = new THREE.DataTexture3D( data, width, height, depth );
						// 	texture.anisotropy = 16;
						//
						// See #14839

						super(null);

						this.image = { data, width, height, depth };

						this.magFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];
						this.minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["NearestFilter"];

						this.wrapR = _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"];

						this.generateMipmaps = false;
						this.flipY = false;
						this.unpackAlignment = 1;

						this.needsUpdate = true;
					}
				}

				DataTexture3D.prototype.isDataTexture3D = true;




				/***/
}),

/***/ "./libs/three/textures/Texture.js":
/*!****************************************!*\
  !*** ./libs/three/textures/Texture.js ***!
  \****************************************/
/*! exports provided: Texture */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function () { return Texture; });
/* harmony import */ var _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/EventDispatcher.js */ "./libs/three/core/EventDispatcher.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants.js */ "./libs/three/constants.js");
/* harmony import */ var _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/MathUtils.js */ "./libs/three/math/MathUtils.js");
/* harmony import */ var _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../math/Vector2.js */ "./libs/three/math/Vector2.js");
/* harmony import */ var _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../math/Matrix3.js */ "./libs/three/math/Matrix3.js");
/* harmony import */ var _extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../extras/ImageUtils.js */ "./libs/three/extras/ImageUtils.js");







				let textureId = 0;

				class Texture extends _core_EventDispatcher_js__WEBPACK_IMPORTED_MODULE_0__["EventDispatcher"] {
					constructor(
						image = Texture.DEFAULT_IMAGE,
						mapping = Texture.DEFAULT_MAPPING,
						wrapS = _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"],
						wrapT = _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"],
						magFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["LinearFilter"],
						minFilter = _constants_js__WEBPACK_IMPORTED_MODULE_1__["LinearMipmapLinearFilter"],
						format = _constants_js__WEBPACK_IMPORTED_MODULE_1__["RGBAFormat"],
						type = _constants_js__WEBPACK_IMPORTED_MODULE_1__["UnsignedByteType"],
						anisotropy = 1,
						encoding = _constants_js__WEBPACK_IMPORTED_MODULE_1__["LinearEncoding"]
					) {
						super();

						Object.defineProperty(this, 'id', { value: textureId++ });

						this.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["generateUUID"]();

						this.name = '';

						this.image = image;
						this.mipmaps = [];

						this.mapping = mapping;

						this.wrapS = wrapS;
						this.wrapT = wrapT;

						this.magFilter = magFilter;
						this.minFilter = minFilter;

						this.anisotropy = anisotropy;

						this.format = format;
						this.internalFormat = null;
						this.type = type;

						this.offset = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"](0, 0);
						this.repeat = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"](1, 1);
						this.center = new _math_Vector2_js__WEBPACK_IMPORTED_MODULE_3__["Vector2"](0, 0);
						this.rotation = 0;

						this.matrixAutoUpdate = true;
						this.matrix = new _math_Matrix3_js__WEBPACK_IMPORTED_MODULE_4__["Matrix3"]();

						this.generateMipmaps = true;
						this.premultiplyAlpha = false;
						this.flipY = true;
						this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

						// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
						//
						// Also changing the encoding after already used by a Material will not automatically make the Material
						// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
						this.encoding = encoding;

						this.userData = {};

						this.version = 0;
						this.onUpdate = null;

						this.isRenderTargetTexture = false;
					}

					updateMatrix() {
						this.matrix.setUvTransform(
							this.offset.x,
							this.offset.y,
							this.repeat.x,
							this.repeat.y,
							this.rotation,
							this.center.x,
							this.center.y
						);
					}

					clone() {
						return new this.constructor().copy(this);
					}

					copy(source) {
						this.name = source.name;

						this.image = source.image;
						this.mipmaps = source.mipmaps.slice(0);

						this.mapping = source.mapping;

						this.wrapS = source.wrapS;
						this.wrapT = source.wrapT;

						this.magFilter = source.magFilter;
						this.minFilter = source.minFilter;

						this.anisotropy = source.anisotropy;

						this.format = source.format;
						this.internalFormat = source.internalFormat;
						this.type = source.type;

						this.offset.copy(source.offset);
						this.repeat.copy(source.repeat);
						this.center.copy(source.center);
						this.rotation = source.rotation;

						this.matrixAutoUpdate = source.matrixAutoUpdate;
						this.matrix.copy(source.matrix);

						this.generateMipmaps = source.generateMipmaps;
						this.premultiplyAlpha = source.premultiplyAlpha;
						this.flipY = source.flipY;
						this.unpackAlignment = source.unpackAlignment;
						this.encoding = source.encoding;

						this.userData = JSON.parse(JSON.stringify(source.userData));

						return this;
					}

					toJSON(meta) {
						const isRootObject = meta === undefined || typeof meta === 'string';

						if (!isRootObject && meta.textures[this.uuid] !== undefined) {
							return meta.textures[this.uuid];
						}

						const output = {
							metadata: {
								version: 4.5,
								type: 'Texture',
								generator: 'Texture.toJSON'
							},

							uuid: this.uuid,
							name: this.name,

							mapping: this.mapping,

							repeat: [this.repeat.x, this.repeat.y],
							offset: [this.offset.x, this.offset.y],
							center: [this.center.x, this.center.y],
							rotation: this.rotation,

							wrap: [this.wrapS, this.wrapT],

							format: this.format,
							type: this.type,
							encoding: this.encoding,

							minFilter: this.minFilter,
							magFilter: this.magFilter,
							anisotropy: this.anisotropy,

							flipY: this.flipY,

							premultiplyAlpha: this.premultiplyAlpha,
							unpackAlignment: this.unpackAlignment
						};

						if (this.image !== undefined) {
							// TODO: Move to THREE.Image

							const { image } = this;

							if (image.uuid === undefined) {
								image.uuid = _math_MathUtils_js__WEBPACK_IMPORTED_MODULE_2__["generateUUID"](); // UGH
							}

							if (!isRootObject && meta.images[image.uuid] === undefined) {
								let url;

								if (Array.isArray(image)) {
									// process array of images e.g. CubeTexture

									url = [];

									for (let i = 0, l = image.length; i < l; i++) {
										// check cube texture with data textures

										if (image[i].isDataTexture) {
											url.push(serializeImage(image[i].image));
										} else {
											url.push(serializeImage(image[i]));
										}
									}
								} else {
									// process single image

									url = serializeImage(image);
								}

								meta.images[image.uuid] = {
									uuid: image.uuid,
									url: url
								};
							}

							output.image = image.uuid;
						}

						if (JSON.stringify(this.userData) !== '{}') output.userData = this.userData;

						if (!isRootObject) {
							meta.textures[this.uuid] = output;
						}

						return output;
					}

					dispose() {
						this.dispatchEvent({ type: 'dispose' });
					}

					transformUv(uv) {
						if (this.mapping !== _constants_js__WEBPACK_IMPORTED_MODULE_1__["UVMapping"]) return uv;

						uv.applyMatrix3(this.matrix);

						if (uv.x < 0 || uv.x > 1) {
							switch (this.wrapS) {
								case _constants_js__WEBPACK_IMPORTED_MODULE_1__["RepeatWrapping"]:
									uv.x = uv.x - Math.floor(uv.x);
									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"]:
									uv.x = uv.x < 0 ? 0 : 1;
									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_1__["MirroredRepeatWrapping"]:
									if (Math.abs(Math.floor(uv.x) % 2) === 1) {
										uv.x = Math.ceil(uv.x) - uv.x;
									} else {
										uv.x = uv.x - Math.floor(uv.x);
									}

									break;
							}
						}

						if (uv.y < 0 || uv.y > 1) {
							switch (this.wrapT) {
								case _constants_js__WEBPACK_IMPORTED_MODULE_1__["RepeatWrapping"]:
									uv.y = uv.y - Math.floor(uv.y);
									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_1__["ClampToEdgeWrapping"]:
									uv.y = uv.y < 0 ? 0 : 1;
									break;

								case _constants_js__WEBPACK_IMPORTED_MODULE_1__["MirroredRepeatWrapping"]:
									if (Math.abs(Math.floor(uv.y) % 2) === 1) {
										uv.y = Math.ceil(uv.y) - uv.y;
									} else {
										uv.y = uv.y - Math.floor(uv.y);
									}

									break;
							}
						}

						if (this.flipY) {
							uv.y = 1 - uv.y;
						}

						return uv;
					}

					set needsUpdate(value) {
						if (value === true) this.version++;
					}
				}

				Texture.DEFAULT_IMAGE = undefined;
				Texture.DEFAULT_MAPPING = _constants_js__WEBPACK_IMPORTED_MODULE_1__["UVMapping"];

				Texture.prototype.isTexture = true;

				function serializeImage(image) {
					if (
						(typeof HTMLImageElement !== 'undefined' &&
							image instanceof HTMLImageElement) ||
						(typeof HTMLCanvasElement !== 'undefined' &&
							image instanceof HTMLCanvasElement) ||
						(typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)
					) {
						// default images

						return _extras_ImageUtils_js__WEBPACK_IMPORTED_MODULE_5__["ImageUtils"].getDataURL(image);
					} else {
						if (image.data) {
							// images of DataTexture

							return {
								data: Array.prototype.slice.call(image.data),
								width: image.width,
								height: image.height,
								type: image.data.constructor.name
							};
						} else {
							console.warn('THREE.Texture: Unable to serialize Texture.');
							return {};
						}
					}
				}




				/***/
}),

/***/ "./libs/three/utils.js":
/*!*****************************!*\
  !*** ./libs/three/utils.js ***!
  \*****************************/
/*! exports provided: arrayMin, arrayMax, getTypedArray, createElementNS, hashString */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMin", function () { return arrayMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMax", function () { return arrayMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypedArray", function () { return getTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createElementNS", function () { return createElementNS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hashString", function () { return hashString; });
				function arrayMin(array) {
					if (array.length === 0) return Infinity;

					let min = array[0];

					for (let i = 1, l = array.length; i < l; ++i) {
						if (array[i] < min) min = array[i];
					}

					return min;
				}

				function arrayMax(array) {
					if (array.length === 0) return -Infinity;

					let max = array[0];

					for (let i = 1, l = array.length; i < l; ++i) {
						if (array[i] > max) max = array[i];
					}

					return max;
				}

				const TYPED_ARRAYS = {
					Int8Array: Int8Array,
					Uint8Array: Uint8Array,
					Uint8ClampedArray: Uint8ClampedArray,
					Int16Array: Int16Array,
					Uint16Array: Uint16Array,
					Int32Array: Int32Array,
					Uint32Array: Uint32Array,
					Float32Array: Float32Array,
					Float64Array: Float64Array
				};

				function getTypedArray(type, buffer) {
					return new TYPED_ARRAYS[type](buffer);
				}

				function createElementNS(name) {
					return my.global.document.createElementNS('http://www.w3.org/1999/xhtml', name);
				}

				/**
				 * cyrb53 hash for string from: https://stackoverflow.com/a/52171480
				 *
				 * Public Domain, @bryc - https://stackoverflow.com/users/815680/bryc
				 *
				 * It is roughly similar to the well-known MurmurHash/xxHash algorithms. It uses a combination
				 * of multiplication and Xorshift to generate the hash, but not as thorough. As a result it's
				 * faster than either would be in JavaScript and significantly simpler to implement. Keep in
				 * mind this is not a secure algorithm, if privacy/security is a concern, this is not for you.
				 *
				 * @param {string} str
				 * @param {number} seed, default 0
				 * @returns number
				 */
				function hashString(str, seed = 0) {
					let h1 = 0xdeadbeef ^ seed,
						h2 = 0x41c6ce57 ^ seed;

					for (let i = 0, ch; i < str.length; i++) {
						ch = str.charCodeAt(i);

						h1 = Math.imul(h1 ^ ch, 2654435761);

						h2 = Math.imul(h2 ^ ch, 1597334677);
					}

					h1 =
						Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^
						Math.imul(h2 ^ (h2 >>> 13), 3266489909);

					h2 =
						Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^
						Math.imul(h1 ^ (h1 >>> 13), 3266489909);

					return 4294967296 * (2097151 & h2) + (h1 >>> 0);
				}




				/***/
}),

/***/ "./libs/tween/Ease.ts":
/*!****************************!*\
  !*** ./libs/tween/Ease.ts ***!
  \****************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.Ease = void 0;
				class Ease {
					/**
					 * @version
					 * @platform Web,Native
					 */
					constructor() {
					}
					/**
					 * get.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static get(amount) {
						if (amount < -1) {
							amount = -1;
						}
						if (amount > 1) {
							amount = 1;
						}
						return function (t) {
							if (amount == 0) {
								return t;
							}
							if (amount < 0) {
								return t * (t * -amount + 1 + amount);
							}
							return t * ((2 - t) * amount + (1 - amount));
						};
					}
					/**
					 * get pow in.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get pow in。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getPowIn(pow) {
						return function (t) {
							return Math.pow(t, pow);
						};
					}
					/**
					 * get pow out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get pow out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getPowOut(pow) {
						return function (t) {
							return 1 - Math.pow(1 - t, pow);
						};
					}
					/**
					 * get pow in out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get pow in out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getPowInOut(pow) {
						return function (t) {
							if ((t *= 2) < 1)
								return 0.5 * Math.pow(t, pow);
							return 1 - 0.5 * Math.abs(Math.pow(2 - t, pow));
						};
					}
					/**
					 * sine in.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * sine in。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static sineIn(t) {
						return 1 - Math.cos(t * Math.PI / 2);
					}
					/**
					 * sine out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * sine out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static sineOut(t) {
						return Math.sin(t * Math.PI / 2);
					}
					/**
					 * sine in out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * sine in out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static sineInOut(t) {
						return -0.5 * (Math.cos(Math.PI * t) - 1);
					}
					/**
					 * get back in.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get back in。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getBackIn(amount) {
						return function (t) {
							return t * t * ((amount + 1) * t - amount);
						};
					}
					/**
					 * get back out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get back out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getBackOut(amount) {
						return function (t) {
							return (--t * t * ((amount + 1) * t + amount) + 1);
						};
					}
					/**
					 * get back in out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get back in out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getBackInOut(amount) {
						amount *= 1.525;
						return function (t) {
							if ((t *= 2) < 1)
								return 0.5 * (t * t * ((amount + 1) * t - amount));
							return 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
						};
					}
					/**
					 * circ in.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * circ in。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static circIn(t) {
						return -(Math.sqrt(1 - t * t) - 1);
					}
					/**
					 * circ out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * circ out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static circOut(t) {
						return Math.sqrt(1 - (--t) * t);
					}
					/**
					 * circ in out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * circ in out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static circInOut(t) {
						if ((t *= 2) < 1) {
							return -0.5 * (Math.sqrt(1 - t * t) - 1);
						}
						return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
					}
					/**
					 * bounce in.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * bounce in。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static bounceIn(t) {
						return 1 - Ease.bounceOut(1 - t);
					}
					/**
					 * bounce out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * bounce out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static bounceOut(t) {
						if (t < 1 / 2.75) {
							return (7.5625 * t * t);
						}
						else if (t < 2 / 2.75) {
							return (7.5625 * (t -= 1.5 / 2.75) * t + 0.75);
						}
						else if (t < 2.5 / 2.75) {
							return (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375);
						}
						else {
							return (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375);
						}
					}
					/**
					 * bounce in out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * bounce in out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static bounceInOut(t) {
						if (t < 0.5)
							return Ease.bounceIn(t * 2) * .5;
						return Ease.bounceOut(t * 2 - 1) * 0.5 + 0.5;
					}
					/**
					 * get elastic in.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get elastic in。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getElasticIn(amplitude, period) {
						let pi2 = Math.PI * 2;
						return function (t) {
							if (t == 0 || t == 1)
								return t;
							let s = period / pi2 * Math.asin(1 / amplitude);
							return -(amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
						};
					}
					/**
					 * get elastic out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get elastic out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getElasticOut(amplitude, period) {
						let pi2 = Math.PI * 2;
						return function (t) {
							if (t == 0 || t == 1)
								return t;
							let s = period / pi2 * Math.asin(1 / amplitude);
							return (amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1);
						};
					}
					/**
					 * get elastic in out.See example.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * get elastic in out。请查看示例
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static getElasticInOut(amplitude, period) {
						let pi2 = Math.PI * 2;
						return function (t) {
							let s = period / pi2 * Math.asin(1 / amplitude);
							if ((t *= 2) < 1)
								return -0.5 * (amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period));
							return amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * 0.5 + 1;
						};
					}
				}
				exports.Ease = Ease;
				/**
				 * quad in.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quad in。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quadIn = Ease.getPowIn(2);
				/**
				 * quad out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quad out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quadOut = Ease.getPowOut(2);
				/**
				 * quad in out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quad in out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quadInOut = Ease.getPowInOut(2);
				/**
				 * cubic in.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * cubic in。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.cubicIn = Ease.getPowIn(3);
				/**
				 * cubic out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * cubic out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.cubicOut = Ease.getPowOut(3);
				/**
				 * cubic in out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * cubic in out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.cubicInOut = Ease.getPowInOut(3);
				/**
				 * quart in.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quart in。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quartIn = Ease.getPowIn(4);
				/**
				 * quart out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quart out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quartOut = Ease.getPowOut(4);
				/**
				 * quart in out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quart in out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quartInOut = Ease.getPowInOut(4);
				/**
				 * quint in.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quint in。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quintIn = Ease.getPowIn(5);
				/**
				 * quint out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quint out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quintOut = Ease.getPowOut(5);
				/**
				 * quint in out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * quint in out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.quintInOut = Ease.getPowInOut(5);
				/**
				 * back in.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * back in。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.backIn = Ease.getBackIn(1.7);
				/**
				 * back out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * back out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.backOut = Ease.getBackOut(1.7);
				/**
				 * back in out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * back in out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.backInOut = Ease.getBackInOut(1.7);
				/**
				 * elastic in.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * elastic in。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.elasticIn = Ease.getElasticIn(1, 0.3);
				/**
				 * elastic out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * elastic out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.elasticOut = Ease.getElasticOut(1, 0.3);
				/**
				 * elastic in out.See example.
				 * @version
				 * @platform Web,Native
				 * @language en_US
				 */
				/**
				 * elastic in out。请查看示例
				 * @version
				 * @platform Web,Native
				 * @language zh_CN
				 */
				Ease.elasticInOut = Ease.getElasticInOut(1, 0.3 * 1.5);


				/***/
}),

/***/ "./libs/tween/Tween.ts":
/*!*****************************!*\
  !*** ./libs/tween/Tween.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				class Tween {
					/**
					 * 创建一个 Tween 对象
					 * @private
					 * @version
					 * @platform Web,Native
					 */
					constructor(target, props, pluginData) {
						/**
						 * @private
						 */
						this._target = null;
						/**
						 * @private
						 */
						this._useTicks = false;
						/**
						 * @private
						 */
						this.ignoreGlobalPause = false;
						/**
						 * @private
						 */
						this.loop = false;
						/**
						 * @private
						 */
						this.pluginData = null;
						/**
						 * @private
						 */
						this.paused = false;
						/**
						 * @private
						 */
						this.duration = 0;
						/**
						 * @private
						 */
						this._prevPos = -1;
						/**
						 * @private
						 */
						this.position = null;
						/**
						 * @private
						 */
						this._prevPosition = 0;
						/**
						 * @private
						 */
						this._stepPosition = 0;
						/**
						 * @private
						 */
						this.passive = false;
						// super();
						this.initialize(target, props, pluginData);
					}
					/**
					 * Activate an object and add a Tween animation to the object
					 * @param target {any} The object to be activated
					 * @param props {any} Parameters, support loop onChange onChangeObj
					 * @param pluginData {any} Write realized
					 * @param override {boolean} Whether to remove the object before adding a tween, the default value false
					 * Not recommended, you can use Tween.removeTweens(target) instead.
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 激活一个对象，对其添加 Tween 动画
					 * @param target {any} 要激活 Tween 的对象
					 * @param props {any} 参数，支持loop(循环播放) onChange(变化函数) onChangeObj(变化函数作用域)
					 * @param pluginData {any} 暂未实现
					 * @param override {boolean} 是否移除对象之前添加的tween，默认值false。
					 * 不建议使用，可使用 Tween.removeTweens(target) 代替。
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static get(target, props, pluginData = null, override = false) {
						if (override) {
							Tween.removeTweens(target);
						}
						return new Tween(target, props, pluginData);
					}
					/**
					 * Delete all Tween animations from an object
					 * @param target The object whose Tween to be deleted
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 删除一个对象上的全部 Tween 动画
					 * @param target  需要移除 Tween 的对象
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static removeTweens(target) {
						if (!target.tween_count) {
							return;
						}
						let tweens = Tween._tweens;
						for (let i = tweens.length - 1; i >= 0; i--) {
							if (tweens[i]._target == target) {
								tweens[i].paused = true;
								tweens.splice(i, 1);
							}
						}
						target.tween_count = 0;
					}
					/**
					 * 移除tween
					 * @param tween get返回的Tween实例
					 */
					static removeTweenSelf(tween) {
						if (!tween || !tween._target || !tween._target.tween_count)
							return;
						tween.paused = true;
						let tweens = Tween._tweens;
						let index = tweens.indexOf(tween);
						if (index > -1)
							tweens.splice(index, 1);
						tween._target.tween_count--;
					}
					/**
					 * Pause all Tween animations of a certain object
					 * @param target The object whose Tween to be paused
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 暂停某个对象的所有 Tween
					 * @param target 要暂停 Tween 的对象
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static pauseTweens(target) {
						if (!target.tween_count) {
							return;
						}
						let tweens = Tween._tweens;
						for (let i = tweens.length - 1; i >= 0; i--) {
							if (tweens[i]._target == target) {
								tweens[i].paused = true;
							}
						}
					}
					/**
					 * Resume playing all easing of a certain object
					 * @param target The object whose Tween to be resumed
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 继续播放某个对象的所有缓动
					 * @param target 要继续播放 Tween 的对象
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static resumeTweens(target) {
						if (!target.tween_count) {
							return;
						}
						let tweens = Tween._tweens;
						for (let i = tweens.length - 1; i >= 0; i--) {
							if (tweens[i]._target == target) {
								tweens[i].paused = false;
							}
						}
					}
					/**
					 * @private
					 *
					 * @param delta
					 * @param paused
					 */
					static tick(timeStamp, paused = false) {
						let delta = timeStamp - Tween._lastTime;
						Tween._lastTime = timeStamp;
						let tweens = Tween._tweens.concat();
						for (let i = tweens.length - 1; i >= 0; i--) {
							let tween = tweens[i];
							if ((paused && !tween.ignoreGlobalPause) || tween.paused) {
								continue;
							}
							tween.$tick(tween._useTicks ? 1 : delta);
						}
						return false;
					}
					/**
					 * flush方法，为了能加入总循环
					 * 默认是锁步的
					 * @param delta
					 * @param paused ,暂时不用，全局禁止
					 */
					static flush( /*paused = false*/) {
						let timeStamp = Date.now();
						let delta = Tween._lastTime ? (timeStamp - Tween._lastTime) : 16.67;
						;
						Tween._lastTime = timeStamp;
						let tweens = Tween._tweens.concat();
						for (let i = tweens.length - 1; i >= 0; i--) {
							let tween = tweens[i];
							if ( /*(paused && !tween.ignoreGlobalPause) ||*/tween.paused) {
								continue;
							}
							tween.$tick(tween._useTicks ? 1 : delta);
						}
					}
					/**
					 * @private
					 *
					 * @param tween
					 * @param value
					 */
					static _register(tween, value) {
						let target = tween._target;
						let tweens = Tween._tweens;
						if (value) {
							if (target) {
								target.tween_count = target.tween_count > 0 ? target.tween_count + 1 : 1;
							}
							tweens.push(tween);
							if (!Tween._inited) {
								// Tween._lastTime = Date.now();
								//开始加入循环暂时从简,最后实际使用，最好加入Stage总循环中
								// let aaa = () => {
								//     Tween.tick(Date.now())
								//     requestAnimationFrame(aaa)
								// }
								//必须做延时
								// setTimeout(aaa, 16.7)
								// aaa();
								// ticker.$startTick(Tween.tick, null);
								Tween._inited = true;
							}
						}
						else {
							if (target) {
								target.tween_count--;
							}
							let i = tweens.length;
							while (i--) {
								if (tweens[i] == tween) {
									tweens.splice(i, 1);
									return;
								}
							}
						}
					}
					/**
					 * Delete all Tween
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 删除所有 Tween
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					static removeAllTweens() {
						let tweens = Tween._tweens;
						for (let i = 0, l = tweens.length; i < l; i++) {
							let tween = tweens[i];
							tween.paused = true;
							tween._target.tween_count = 0;
						}
						tweens.length = 0;
					}
					/**
					 * @private
					 *
					 * @param target
					 * @param props
					 * @param pluginData
					 */
					initialize(target, props, pluginData) {
						this._target = target;
						if (props) {
							this._useTicks = props.useTicks;
							this.ignoreGlobalPause = props.ignoreGlobalPause;
							this.loop = props.loop;
							if (props.onChange) {
								this.onChange = props.onChange.bind(props.onChangeObj);
							}
							else {
								this.onChange = null;
							}
							// && this.addEventListener("change", props.onChange.bind(props.onChangeObj));
							if (props.override) {
								Tween.removeTweens(target);
							}
						}
						this.pluginData = pluginData || {};
						this._curQueueProps = {};
						this._initQueueProps = {};
						this._steps = [];
						if (props && props.paused) {
							this.paused = true;
						}
						else {
							Tween._register(this, true);
						}
						if (props && props.position != null) {
							this.setPosition(props.position, Tween.NONE);
						}
					}
					/**
					 * @private
					 *
					 * @param value
					 * @param actionsMode
					 * @returns
					 */
					setPosition(value, actionsMode = 1) {
						if (value < 0) {
							value = 0;
						}
						//正常化位置
						let t = value;
						let end = false;
						if (t >= this.duration) {
							if (this.loop) {
								var newTime = t % this.duration;
								if (t > 0 && newTime === 0) {
									t = this.duration;
								}
								else {
									t = newTime;
								}
							}
							else {
								t = this.duration;
								end = true;
							}
						}
						if (t == this._prevPos) {
							return end;
						}
						if (end) {
							this.setPaused(true);
						}
						let prevPos = this._prevPos;
						this.position = this._prevPos = t;
						this._prevPosition = value;
						if (this._target && this._steps) {
							if (this._steps.length > 0) {
								// 找到新的tween
								let l = this._steps.length;
								let stepIndex = -1;
								for (let i = 0; i < l; i++) {
									if (this._steps[i].type == "step") {
										stepIndex = i;
										if (this._steps[i].t <= t && this._steps[i].t + this._steps[i].d >= t) {
											break;
										}
									}
								}
								for (let i = 0; i < l; i++) {
									if (this._steps[i].type == "action") {
										//执行actions
										if (actionsMode != 0) {
											if (this._useTicks) {
												this._runAction(this._steps[i], t, t);
											}
											else if (actionsMode == 1 && t < prevPos) {
												if (prevPos != this.duration) {
													this._runAction(this._steps[i], prevPos, this.duration);
												}
												this._runAction(this._steps[i], 0, t, true);
											}
											else {
												this._runAction(this._steps[i], prevPos, t);
											}
										}
									}
									else if (this._steps[i].type == "step") {
										if (stepIndex == i) {
											let step = this._steps[stepIndex];
											this._updateTargetProps(step, Math.min((this._stepPosition = t - step.t) / step.d, 1));
										}
									}
								}
							}
						}
						this.onChange && this.onChange();
						// this.dispatchEvent("change");
						return end;
					}
					/**
					 * @private
					 *
					 * @param startPos
					 * @param endPos
					 * @param includeStart
					 */
					_runAction(action, startPos, endPos, includeStart = false) {
						let sPos = startPos;
						let ePos = endPos;
						if (startPos > endPos) {
							//把所有的倒置
							sPos = endPos;
							ePos = startPos;
						}
						let pos = action.t;
						if (pos == ePos || (pos > sPos && pos < ePos) || (includeStart && pos == startPos)) {
							action.f.apply(action.o, action.p);
						}
					}
					/**
					 * @private
					 *
					 * @param step
					 * @param ratio
					 */
					_updateTargetProps(step, ratio) {
						let p0, p1, v, v0, v1, arr;
						if (!step && ratio == 1) {
							this.passive = false;
							p0 = p1 = this._curQueueProps;
						}
						else {
							this.passive = !!step.v;
							//不更新props.
							if (this.passive) {
								return;
							}
							//使用ease
							if (step.e) {
								ratio = step.e(ratio, 0, 1, 1);
							}
							p0 = step.p0;
							p1 = step.p1;
						}
						for (let n in this._initQueueProps) {
							if ((v0 = p0[n]) == null) {
								p0[n] = v0 = this._initQueueProps[n];
							}
							if ((v1 = p1[n]) == null) {
								p1[n] = v1 = v0;
							}
							if (v0 == v1 || ratio == 0 || ratio == 1 || (typeof (v0) != "number")) {
								v = ratio == 1 ? v1 : v0;
							}
							else {
								v = v0 + (v1 - v0) * ratio;
							}
							let ignore = false;
							if (arr = Tween._plugins[n]) {
								for (let i = 0, l = arr.length; i < l; i++) {
									let v2 = arr[i].tween(this, n, v, p0, p1, ratio, !!step && p0 == p1, !step);
									if (v2 == Tween.IGNORE) {
										ignore = true;
									}
									else {
										v = v2;
									}
								}
							}
							if (!ignore) {
								this._target[n] = v;
							}
						}
					}
					/**
					 * Whether setting is paused
					 * @param value {boolean} Whether to pause
					 * @returns Tween object itself
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 设置是否暂停
					 * @param value {boolean} 是否暂停
					 * @returns Tween对象本身
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					setPaused(value) {
						if (this.paused == value) {
							return this;
						}
						this.paused = value;
						Tween._register(this, !value);
						return this;
					}
					/**
					 * @private
					 *
					 * @param props
					 * @returns
					 */
					_cloneProps(props) {
						let o = {};
						for (let n in props) {
							o[n] = props[n];
						}
						return o;
					}
					/**
					 * @private
					 *
					 * @param o
					 * @returns
					 */
					_addStep(o) {
						if (o.d > 0) {
							o.type = "step";
							this._steps.push(o);
							o.t = this.duration;
							this.duration += o.d;
						}
						return this;
					}
					/**
					 * @private
					 *
					 * @param o
					 * @returns
					 */
					_appendQueueProps(o) {
						let arr, oldValue, i, l, injectProps;
						for (let n in o) {
							if (this._initQueueProps[n] === undefined) {
								oldValue = this._target[n];
								//设置plugins
								if (arr = Tween._plugins[n]) {
									for (i = 0, l = arr.length; i < l; i++) {
										oldValue = arr[i].init(this, n, oldValue);
									}
								}
								this._initQueueProps[n] = this._curQueueProps[n] = (oldValue === undefined) ? null : oldValue;
							}
							else {
								oldValue = this._curQueueProps[n];
							}
						}
						for (let n in o) {
							oldValue = this._curQueueProps[n];
							if (arr = Tween._plugins[n]) {
								injectProps = injectProps || {};
								for (i = 0, l = arr.length; i < l; i++) {
									if (arr[i].step) {
										arr[i].step(this, n, oldValue, o[n], injectProps);
									}
								}
							}
							this._curQueueProps[n] = o[n];
						}
						if (injectProps) {
							this._appendQueueProps(injectProps);
						}
						return this._curQueueProps;
					}
					/**
					 * @private
					 *
					 * @param o
					 * @returns
					 */
					_addAction(o) {
						o.t = this.duration;
						o.type = "action";
						this._steps.push(o);
						return this;
					}
					/**
					 * @private
					 *
					 * @param props
					 * @param o
					 */
					_set(props, o) {
						for (let n in props) {
							o[n] = props[n];
						}
					}
					/**
					 * Wait the specified milliseconds before the execution of the next animation
					 * @param duration {number} Waiting time, in milliseconds
					 * @param passive {boolean} Whether properties are updated during the waiting time
					 * @returns Tween object itself
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 等待指定毫秒后执行下一个动画
					 * @param duration {number} 要等待的时间，以毫秒为单位
					 * @param passive {boolean} 等待期间属性是否会更新
					 * @returns Tween对象本身
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					wait(duration, passive) {
						if (duration == null || duration <= 0) {
							return this;
						}
						let o = this._cloneProps(this._curQueueProps);
						return this._addStep({ d: duration, p0: o, p1: o, v: passive });
					}
					/**
					 * Modify the property of the specified object to a specified value
					 * @param props {Object} Property set of an object
					 * @param duration {number} Duration
					 * @param ease {Ease} Easing algorithm
					 * @returns {Tween} Tween object itself
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 将指定对象的属性修改为指定值
					 * @param props {Object} 对象的属性集合
					 * @param duration {number} 持续时间
					 * @param ease {Ease} 缓动算法
					 * @returns {Tween} Tween对象本身
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					to(props, duration, ease = undefined) {
						if (isNaN(duration) || duration < 0) {
							duration = 0;
						}
						this._addStep({ d: duration || 0, p0: this._cloneProps(this._curQueueProps), e: ease, p1: this._cloneProps(this._appendQueueProps(props)) });
						//加入一步set，防止游戏极其卡顿时候，to后面的call取到的属性值不对
						return this.set(props);
					}
					/**
					 * by
					 * @param props
					 * @param duration
					 * @param ease
					 */
					by(props, duration = 0, ease = undefined) {
						for (let k in props) {
							props[k] += this._curQueueProps[k] || this._target[k];
						}
						return this.to(props, duration, ease);
					}
					/**
					 * Execute callback function
					 * @param callback {Function} Callback method
					 * @param thisObj {any} this action scope of the callback method
					 * @param params {any[]} Parameter of the callback method
					 * @returns {Tween} Tween object itself
					 * @version
					 * @platform Web,Native
					 * @example
					 * <pre>
					 *  Tween.get(display).call(function (a:number, b:string) {
					 *      console.log("a: " + a); // the first parameter passed 233
					 *      console.log("b: " + b); // the second parameter passed “hello”
					 *  }, this, [233, "hello"]);
					 * </pre>
					 * @language en_US
					 */
					/**
					 * 执行回调函数
					 * @param callback {Function} 回调方法
					 * @param thisObj {any} 回调方法this作用域
					 * @param params {any[]} 回调方法参数
					 * @returns {Tween} Tween对象本身
					 * @version
					 * @platform Web,Native
					 * @example
					 * <pre>
					 *  Tween.get(display).call(function (a:number, b:string) {
					 *      console.log("a: " + a); //对应传入的第一个参数 233
					 *      console.log("b: " + b); //对应传入的第二个参数 “hello”
					 *  }, this, [233, "hello"]);
					 * </pre>
					 * @language zh_CN
					 */
					call(callback, thisObj = undefined, params = undefined) {
						return this._addAction({ f: callback, p: params ? params : [], o: thisObj ? thisObj : this._target });
					}
					/**
					 * Now modify the properties of the specified object to the specified value
					 * @param props {Object} Property set of an object
					 * @param target The object whose Tween to be resumed
					 * @returns {Tween} Tween object itself
					 * @version
					 * @platform Web,Native
					 */
					/**
					 * 立即将指定对象的属性修改为指定值
					 * @param props {Object} 对象的属性集合
					 * @param target 要继续播放 Tween 的对象
					 * @returns {Tween} Tween对象本身
					 * @version
					 * @platform Web,Native
					 */
					set(props, target = null) {
						//更新当前数据，保证缓动流畅性
						this._appendQueueProps(props);
						// console.log(this._target.x)
						return this._addAction({ f: this._set, o: this, p: [props, target ? target : this._target] });
					}
					/**
					 * Execute
					 * @param tween {Tween} The Tween object to be operated. Default: this
					 * @returns {Tween} Tween object itself
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 执行
					 * @param tween {Tween} 需要操作的 Tween 对象，默认this
					 * @returns {Tween} Tween对象本身
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					play(tween) {
						if (!tween) {
							tween = this;
						}
						return this.call(tween.setPaused, tween, [false]);
					}
					/**
					 * Pause
					 * @param tween {Tween} The Tween object to be operated. Default: this
					 * @returns {Tween} Tween object itself
					 * @version
					 * @platform Web,Native
					 * @language en_US
					 */
					/**
					 * 暂停
					 * @param tween {Tween} 需要操作的 Tween 对象，默认this
					 * @returns {Tween} Tween对象本身
					 * @version
					 * @platform Web,Native
					 * @language zh_CN
					 */
					pause(tween) {
						if (!tween) {
							tween = this;
						}
						return this.call(tween.setPaused, tween, [true]);
					}
					/**
					 * @method Tween#tick
					 * @param delta {number}
					 * @private
					 * @version
					 * @platform Web,Native
					 */
					$tick(delta) {
						if (this.paused) {
							return;
						}
						this.setPosition(this._prevPosition + delta);
					}
				}
				exports.default = Tween;
				/**
				 * 不做特殊处理
				 * @constant {number} Tween.NONE
				 * @private
				 */
				Tween.NONE = 0;
				/**
				 * 循环
				 * @constant {number} Tween.LOOP
				 * @private
				 */
				Tween.LOOP = 1;
				/**
				 * 倒序
				 * @constant {number} Tween.REVERSE
				 * @private
				 */
				Tween.REVERSE = 2;
				/**
				 * @private
				 */
				Tween._tweens = [];
				/**
				 * @private
				 */
				Tween.IGNORE = {};
				/**
				 * @private
				 */
				Tween._plugins = {};
				/**
				 * @private
				 */
				Tween._inited = false;
				Tween._lastTime = 0;


				/***/
}),

/***/ "./libs/tween/index.ts":
/*!*****************************!*\
  !*** ./libs/tween/index.ts ***!
  \*****************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __createBinding = (this && this.__createBinding) || (Object.create ? (function (o, m, k, k2) {
					if (k2 === undefined) k2 = k;
					Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
				}) : (function (o, m, k, k2) {
					if (k2 === undefined) k2 = k;
					o[k2] = m[k];
				}));
				var __exportStar = (this && this.__exportStar) || function (m, exports) {
					for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				__exportStar(__webpack_require__(/*! ./Ease */ "./libs/tween/Ease.ts"), exports);
				var Tween_1 = __webpack_require__(/*! ./Tween */ "./libs/tween/Tween.ts");
				Object.defineProperty(exports, "Tween", { enumerable: true, get: function () { return Tween_1.default; } });


				/***/
}),

/***/ "./modules/ctrls/Index.ts":
/*!********************************!*\
  !*** ./modules/ctrls/Index.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.showUI = exports.showPanel = exports.changeScene = exports.removeTweens = void 0;
				const UICtrl_1 = __webpack_require__(/*! ./UICtrl */ "./modules/ctrls/UICtrl.ts");
				const tween_1 = __webpack_require__(/*! ../../libs/tween */ "./libs/tween/index.ts");
				const PanelCtrl_1 = __webpack_require__(/*! ./PanelCtrl */ "./modules/ctrls/PanelCtrl.ts");
				const SceneCtrl_1 = __webpack_require__(/*! ./SceneCtrl */ "./modules/ctrls/SceneCtrl.ts");
				/**
				 * 递归清除显示对象里面所有的Tween
				 * @param obj
				 * @param isRecursive 默认true,递归移除子级
				 */
				function removeTweens(obj, isRecursive = true) {
					if (!obj)
						return;
					tween_1.Tween.removeTweens(obj);
					if (!isRecursive || !obj.children || !obj.children.length)
						return;
					obj.children.forEach((child) => {
						removeTweens(child);
					});
				}
				exports.removeTweens = removeTweens;
				/**
				 * 替换场景
				 * @param scene
				 * @param data
				 */
				exports.changeScene = (scene, data) => {
					SceneCtrl_1.SceneCtrl.ins.change(scene, data);
				};
				/**
				 * 展示弹窗
				 * @param panel
				 * @param data
				 */
				exports.showPanel = (panel, data) => {
					PanelCtrl_1.PanelCtrl.ins.show(panel, data);
				};
				exports.showUI = (ui, data) => {
					UICtrl_1.UICtrl.ins.showUI(ui, data);
				};


				/***/
}),

/***/ "./modules/ctrls/PanelCtrl.ts":
/*!************************************!*\
  !*** ./modules/ctrls/PanelCtrl.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.PanelCtrl = void 0;
				const PlaneGeometry_1 = __webpack_require__(/*! ../../libs/three/geometries/PlaneGeometry */ "./libs/three/geometries/PlaneGeometry.js");
				const MeshBasicMaterial_1 = __webpack_require__(/*! ../../libs/three/materials/MeshBasicMaterial */ "./libs/three/materials/MeshBasicMaterial.js");
				const Color_1 = __webpack_require__(/*! ../../libs/three/math/Color */ "./libs/three/math/Color.js");
				const Mesh_1 = __webpack_require__(/*! ../../libs/three/objects/Mesh */ "./libs/three/objects/Mesh.js");
				const tween_1 = __webpack_require__(/*! ../../libs/tween */ "./libs/tween/index.ts");
				class PanelCtrl {
					constructor() {
						this.stacks = [];
					}
					static get ins() {
						return PanelCtrl._instance || (PanelCtrl._instance = new PanelCtrl());
					}
					init(parent) {
						this._parent = parent;
						let bg = new Mesh_1.Mesh(new PlaneGeometry_1.PlaneBufferGeometry(750, 1700, 2, 2), new MeshBasicMaterial_1.MeshBasicMaterial({ color: new Color_1.Color(0, 0, 0), opacity: 0.7 })); //Shape();
						// console.log(bg);
						// bg.rotateX(Math.PI)
						// bg.visible = false;
						this._parent.add(bg);
						this._bg = bg;
					}
					closeAll() {
						this.stacks.forEach((e) => e.hidePanel());
					}
					//<T extends Panel>
					show(cls, data) {
						// showWaiting()
						const panel = new cls(data);
						this.add(panel);
						this.stacks.push(panel);
						panel.onLoaded = () => {
							// hideWaiting();
							// sendTbNet(TbNetName.hideLoading)
							this.updateView(false); //这里更新不显示动画先，自行判断是否显示
							//start只执行一边
							panel.start(data);
							//如果是最后一个才显示动画
							if (panel.visible)
								panel.showAni();
						};
						//资源加载失败时
						panel.onLoadError = () => {
							// hideWaiting();
							// sendTbNet(TbNetName.hideLoading)
							// showToast("资源加载失败")
							panel.removeEventListener("onDestroy", this.onPanelHide, this);
							this.removePanel(panel);
						};
						return panel;
					}
					updateView(showPanelAni = true) {
						//没有弹框的时候
						if (!this.stacks.length) {
							// this._bg.visible = false;
							// this._current = null;
							// this._parent.visible = false;
							if (this._bg.visible) {
								//原先背景存在时，待测试
								this.bgAni = "hide";
								tween_1.Tween.removeTweens(this._bg);
								// Tween.get(this._bg)
								//     .to({ alpha: 0 }, 200, FYGE.Ease.cubicOut)
								//     .call(() => {
								//         this._bg.visible = false;
								//         this._current = null;
								//         this._parent.visible = false;
								//     })
							}
						}
						else {
							//显示弹框层
							this._parent.visible = true;
							if (this.bgAni == "hide") {
								//如果正在执行蒙层消失动画，
								this.bgAni = "show";
								tween_1.Tween.removeTweens(this._bg);
								// this._bg.alpha = 0.7;
							}
							//如果首次出现弹框，加个动画
							if (this._bg.visible === false) {
								this._bg.visible = true;
								// this._bg.alpha = 0;
								// Tween.get(this._bg).to({ alpha: 0.7 }, 200, FYGE.Ease.cubicOut)
							}
						}
						for (let i = 0; i < this.stacks.length; i++) {
							if (i < this.stacks.length - 1) {
								this.stacks[i].visible = false;
							}
							else {
								this.stacks[i].visible = true;
								if (showPanelAni)
									this.stacks[i].showAni();
								this._current = this.stacks[i];
							}
						}
					}
					/**
					 * 添加进父级并添加事件
					 * @param panel
					 */
					add(panel) {
						this._parent.add(panel);
						panel.addEventListener("onDestroy", this.onPanelHide);
					}
					/**
					 * 移除
					 * @param panel
					 */
					removePanel(panel) {
						this._parent.remove(panel);
						this.stacks = this.stacks.filter((e) => e != panel);
					}
					/**
					 * 弹框移除时执行
					 * @param e
					 */
					onPanelHide(e) {
						const panel = e.target;
						panel.removeEventListener("onDestroy", this.onPanelHide, this);
						this.removePanel(panel);
						this.updateView();
					}
					/**
					 * 关闭当前弹框
					 */
					closeCurrent() {
						if (this._current) {
							this._current.hidePanel();
							// this._current.removeEventListener('onDestroy', this.onPanelHide, this);
							// this.remove(this._current);
							// this.updateView();
						}
					}
					destroy() {
						//@ts-ignore
						PanelCtrl._instance = null;
						//@ts-ignore
						this.stacks = null;
						this._current = null;
						//@ts-ignore
						this._parent = null;
						tween_1.Tween.removeTweens(this._bg);
						this._bg = null;
					}
				}
				exports.PanelCtrl = PanelCtrl;


				/***/
}),

/***/ "./modules/ctrls/SceneCtrl.ts":
/*!************************************!*\
  !*** ./modules/ctrls/SceneCtrl.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.SceneCtrl = void 0;
				class SceneCtrl {
					constructor() {
						this._parent = null;
						this._currentScene = null;
					}
					static get ins() {
						return SceneCtrl._instance || (SceneCtrl._instance = new SceneCtrl());
					}
					init(parent) {
						this._parent = parent;
					}
					change(cls, data) {
						//如果是同一个场景，考虑是替换还是return
						// if (this._currentScene && this._currentScene instanceof cls) return;//new一个得了，playScene维护太蛋疼，到时看性能吧
						let scene = new cls(data);
						scene.visible = false;
						// showWaiting();
						//TODO waiting加载
						// sendTbNet(TbNetName.showLoading)
						let preScene = this._currentScene;
						scene.onLoaded = () => {
							// hideWaiting();
							// TODO 隐藏waiting
							// sendTbNet(TbNetName.hideLoading)
							scene.showAni(() => {
								if (preScene)
									preScene.destroy();
							});
							scene.visible = true;
							//start里可能处理资源信息，所以在onLoaded后执行
							scene.start(data);
						};
						//加载失败，继续用之前的场景，移除scene
						scene.onLoadError = () => {
							// hideWaiting();
							// TODO 隐藏waiting
							// sendTbNet(TbNetName.hideLoading)
							// showToast("资源加载失败")
							this._currentScene = preScene || null;
							this._parent && this._parent.remove(scene);
						};
						this._currentScene = scene;
						this._parent && this._parent.add(scene);
						// console.log(scene);
						//TODO  这里只是先拿出来   后面写了资源加载的东西再放到onLoaded里面
						scene.showAni(() => {
							if (preScene)
								preScene.destroy();
						});
						scene.visible = true;
						//start里可能处理资源信息，所以在onLoaded后执行
						scene.start(data);
					}
					get currentScene() {
						return this._currentScene;
					}
					destroy() {
						var _a;
						SceneCtrl._instance = null;
						(_a = this._currentScene) === null || _a === void 0 ? void 0 : _a.destory();
						this._currentScene = null;
						this._parent = null;
					}
				}
				exports.SceneCtrl = SceneCtrl;


				/***/
}),

/***/ "./modules/ctrls/UICtrl.ts":
/*!*********************************!*\
  !*** ./modules/ctrls/UICtrl.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.UICtrl = void 0;
				class UICtrl {
					constructor() {
						this.stacks = [];
					}
					static get ins() {
						return UICtrl._instance || (UICtrl._instance = new UICtrl());
					}
					init(parent) {
						this._parent = parent;
					}
					closeAll() {
						this.stacks.forEach((e) => e.hidePanel());
					}
					//<T extends UI>
					showUI(cls, data) {
						// showWaiting()
						const ui = new cls(data);
						this.add(ui);
						this.stacks.push(ui);
						ui.onLoaded = () => {
							// hideWaiting();
							// sendTbNet(TbNetName.hideLoading)
							this.updateView(); //这里更新不显示动画先，自行判断是否显示
							//start只执行一遍
							ui.start(data);
							//如果是最后一个才显示动画
							if (ui.visible)
								ui.showAni();
						};
						//资源加载失败时
						ui.onLoadError = () => {
							// hideWaiting();
							// sendTbNet(TbNetName.hideLoading)
							// showToast("资源加载失败")
							ui.removeEventListener("onDestroy", this.onUIHide, this);
							this.removeUI(ui);
						};
						return ui;
					}
					updateView() {
						//没有弹框的时候
						if (!this.stacks.length) {
							// this._bg.visible = false;
							this._current = null;
							this._parent.visible = false;
						}
						else {
							//显示弹框层
							this._parent.visible = true;
						}
						for (let i = 0; i < this.stacks.length; i++) {
							if (i < this.stacks.length - 1) {
								this.stacks[i].visible = false;
							}
							else {
								this.stacks[i].visible = true;
								this._current = this.stacks[i];
							}
						}
					}
					/**
					 * 添加进父级并添加事件
					 * @param panel
					 */
					add(ui) {
						this._parent.add(ui);
						ui.addEventListener("onDestroy", this.onUIHide);
					}
					/**
					 * 移除
					 * @param ui
					 */
					removeUI(ui) {
						this._parent.remove(ui);
						this.stacks = this.stacks.filter((e) => e != ui);
					}
					/**
					 * 弹框移除时执行
					 * @param e
					 */
					onUIHide(e) {
						const ui = e.target;
						ui.removeEventListener("onDestroy", this.onUIHide, this);
						this.removeUI(ui);
						this.updateView();
					}
					/**
					 * 关闭当前弹框
					 */
					closeCurrent() {
						if (this._current) {
							this._current.hideUI();
						}
					}
					destroy() {
						//@ts-ignore
						UICtrl._instance = null;
						//@ts-ignore
						this.stacks = null;
						this._current = null;
						//@ts-ignore
						this._parent = null;
					}
				}
				exports.UICtrl = UICtrl;


				/***/
}),

/***/ "./modules/views/Layers.ts":
/*!*********************************!*\
  !*** ./modules/views/Layers.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.layers = exports.Layers = exports.LayerType = void 0;
				const UICtrl_1 = __webpack_require__(/*! ./../ctrls/UICtrl */ "./modules/ctrls/UICtrl.ts");
				const OrthographicCamera_1 = __webpack_require__(/*! ../../libs/three/cameras/OrthographicCamera */ "./libs/three/cameras/OrthographicCamera.js");
				const PerspectiveCamera_1 = __webpack_require__(/*! ../../libs/three/cameras/PerspectiveCamera */ "./libs/three/cameras/PerspectiveCamera.js");
				const SceneCtrl_1 = __webpack_require__(/*! ../ctrls/SceneCtrl */ "./modules/ctrls/SceneCtrl.ts");
				const PanelCtrl_1 = __webpack_require__(/*! ../ctrls/PanelCtrl */ "./modules/ctrls/PanelCtrl.ts");
				const Scene_1 = __webpack_require__(/*! ./Scene */ "./modules/views/Scene.ts");
				/**
				 * 层级类型
				 * 主要逻辑层级放在mainLayer里
				 */
				var LayerType;
				(function (LayerType) {
					LayerType[LayerType["bottomLayer"] = 0] = "bottomLayer";
					LayerType[LayerType["mainLayer"] = 1] = "mainLayer";
					LayerType[LayerType["topLayer"] = 2] = "topLayer";
					LayerType[LayerType["popupLayer"] = 3] = "popupLayer";
					LayerType[LayerType["loadingLayer"] = 4] = "loadingLayer";
				})(LayerType = exports.LayerType || (exports.LayerType = {}));
				// 新增层级的话
				class Layers extends Scene_1.Scene {
					constructor() {
						super(...arguments);
						this.name = "Layers";
						this.isLayers = true;
					}
					get bottomLayerCamera() {
						return this._bottomLayerCamera;
					}
					get mainLayerCamera() {
						return this._mainLayerCamera;
					}
					get topLayerCamera() {
						return this._topLayerCamera;
					}
					get popupLayerCamera() {
						return this._popupLayerCamera;
					}
					get loadingLayerCamera() {
						return this._loadingLayerCamera;
					}
					get bottomLayer() {
						return this._bottomLayer;
					}
					get mainLayer() {
						return this._mainLayer;
					}
					get topLayer() {
						return this._topLayer;
					}
					get popupLayer() {
						return this._popupLayer;
					}
					get loadingLayer() {
						return this._loadingLayer;
					}
					init(stage) {
						if (!stage) {
							throw new Error("初始化Layers失败，需要传入Stage");
						}
						stage.add(this);
						this.stage = stage;
						// 初始化相机和相机层级
						this.initCameras();
						// 初始化layer和对应层级   对应层级的东西加到对应layer上去  render渲染  renderer.render(stage,xxxLayerCamera);
						this.initLayers();
					}
					initCameras() {
						// 2d背景层级的相机  暂定是用正交相机绘制图片 现在有长屏手机 1624不太够暂定 1700
						this._bottomLayerCamera = new OrthographicCamera_1.OrthographicCamera(0, 750, 0, 1700, 0.01, 1000);
						this._bottomLayerCamera.setPosition(0, 0, 100);
						// 放3d场景
						this._mainLayerCamera = new PerspectiveCamera_1.PerspectiveCamera(10, this.stage.canvasWidth / this.stage.canvasHeight, 0.1, 100);
						// 放顶部UI
						this._topLayerCamera = new OrthographicCamera_1.OrthographicCamera(0, 750, 0, 1700, 0.01, 1000);
						this._topLayerCamera.setPosition(0, 0, 100);
						// 放弹窗的相机  暂定弹窗里没有3d部分
						this._popupLayerCamera = new OrthographicCamera_1.OrthographicCamera(0, 750, 0, 1700, 0.01, 1000);
						this._popupLayerCamera.setPosition(0, 0, 100);
						// 放loading的相机
						this._loadingLayerCamera = new OrthographicCamera_1.OrthographicCamera(0, 750, 0, 1700, 0.01, 1000);
						this._loadingLayerCamera.setPosition(0, 0, 100);
						this._bottomLayerCamera.layers.enable(LayerType.bottomLayer);
						this._mainLayerCamera.layers.enable(LayerType.mainLayer);
						this._topLayerCamera.layers.enable(LayerType.topLayer);
						this._popupLayerCamera.layers.enable(LayerType.popupLayer);
						this._loadingLayerCamera.layers.enable(LayerType.loadingLayer);
						// TODO 可加可不加  取决于相机是否需要跟随父级做矩阵变换
						// this.stage.add(this._bottomLayerCamera)
						// this.stage.add(this._mainLayerCamera)
						// this.stage.add(this._topLayerCamera)
						// this.stage.add(this._popupLayerCamera)
						// this.stage.add(this._loadingLayerCamera)
					}
					initLayers() {
						return __awaiter(this, void 0, void 0, function* () {
							this._bottomLayer = new Scene_1.Scene();
							this._mainLayer = new Scene_1.Scene();
							this._topLayer = new Scene_1.Scene();
							this._popupLayer = new Scene_1.Scene();
							this._loadingLayer = new Scene_1.Scene();
							this.bottomLayer.layers.set(LayerType.bottomLayer);
							this.mainLayer.layers.set(LayerType.mainLayer);
							this.topLayer.layers.set(LayerType.topLayer);
							this.popupLayer.layers.set(LayerType.popupLayer);
							this.loadingLayer.layers.set(LayerType.loadingLayer);
							this.bottomLayer["isLayer"] = true;
							this.mainLayer["isLayer"] = true;
							this.topLayer["isLayer"] = true;
							this.popupLayer["isLayer"] = true;
							this.loadingLayer["isLayer"] = true;
							this.bottomLayer["name"] = "BottomLayer";
							this.mainLayer["name"] = "MainLayer";
							this.topLayer["name"] = "TopLayer";
							this.popupLayer["name"] = "PopupLayer";
							this.loadingLayer["name"] = "LoadingLayer";
							this.add(this.bottomLayer);
							this.add(this.mainLayer);
							this.add(this.topLayer);
							this.add(this.popupLayer);
							this.add(this.loadingLayer);
							// 初始化场景层级
							SceneCtrl_1.SceneCtrl.ins.init(this.mainLayer);
							// 初始化上层（用于渲染UI）
							UICtrl_1.UICtrl.ins.init(this.topLayer);
							// 初始化弹框层级
							PanelCtrl_1.PanelCtrl.ins.init(this.popupLayer);
							// TODO 其他层级初始化
						});
					}
					destroy() {
						super.destory();
						this._bottomLayer.clear();
						//@ts-ignore
						this._bottomLayer = null;
						this._mainLayer.clear();
						//@ts-ignore
						this._mainLayer = null;
						this._topLayer.clear();
						//@ts-ignore
						this._topLayer = null;
						this._popupLayer.clear();
						//@ts-ignore
						this._popupLayer = null;
						this._popupLayer.clear();
						//@ts-ignore
						this._popupLayer = null;
						UICtrl_1.UICtrl.ins.destroy;
						PanelCtrl_1.PanelCtrl.ins.destroy();
						this.stage.remove(this);
						//@ts-ignore
						this.stage = null;
					}
				}
				exports.Layers = Layers;
				exports.layers = new Layers();


				/***/
}),

/***/ "./modules/views/Module.ts":
/*!*********************************!*\
  !*** ./modules/views/Module.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.Module = void 0;
				const Object3D_1 = __webpack_require__(/*! ../../libs/three/core/Object3D */ "./libs/three/core/Object3D.js");
				class Module extends Object3D_1.Object3D {
					constructor(data) {
						super();
						this.name = 'Module';
						this.data = data;
						this.initUi(data);
					}
					initUi(data) {
					}
					start(data) {
						this.initEvents();
					}
					initEvents() {
					}
					removeEvents() {
					}
					destory() {
						// 销毁
						this.removeEvents();
					}
				}
				exports.Module = Module;


				/***/
}),

/***/ "./modules/views/Scene.ts":
/*!********************************!*\
  !*** ./modules/views/Scene.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.Scene = void 0;
				const Index_1 = __webpack_require__(/*! ../ctrls/Index */ "./modules/ctrls/Index.ts");
				const Module_1 = __webpack_require__(/*! ./Module */ "./modules/views/Module.ts");
				class Scene extends Module_1.Module {
					// BgLayer = new Object3D()
					// UILayer = new Object3D()
					constructor(data) {
						super(data);
						this.isScene = true;
						this.name = "Scene";
						this.type = "Scene";
						this.background = null;
						this.environment = null;
						this.fog = null;
						this.overrideMaterial = null;
						this.autoUpdate = true; // checked by the renderer
						var __THREE_DEVTOOLS__ = __THREE_DEVTOOLS__;
						if (typeof __THREE_DEVTOOLS__ !== "undefined") {
							__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })); // eslint-disable-line no-undef
						}
					}
					initUi(data) { }
					start(data) {
						super.start(data);
					}
					initEvents() { }
					removeEvents() { }
					// 出现动画 因为是3d的暂时就不要动效了
					showAni(func) {
						func();
					}
					// 会被SceneCtrl重写  加载完成后调用
					onLoaded() { }
					// 加载失败后调用
					onLoadError() { }
					// 移除
					destroy() {
						//以防有些地方用了showAni
						Index_1.removeTweens(this);
						// this.data = null;//看情况吧，有时候hidePanel后用了data，注意，还是先去掉吧
						//派发销毁事件，主要用于场景及弹框控制
						this.dispatchEvent("onDestroy", {});
						// layers.bottomLayer.remove(this.BgLayer);
						// layers.topLayer.remove(this.UILayer);
						super.destory();
					}
					copy(source, recursive) {
						super.copy(source, recursive);
						if (source.background !== null)
							this.background = source.background.clone();
						if (source.environment !== null)
							this.environment = source.environment.clone();
						if (source.fog !== null)
							this.fog = source.fog.clone();
						if (source.overrideMaterial !== null)
							this.overrideMaterial = source.overrideMaterial.clone();
						this.autoUpdate = source.autoUpdate;
						this.matrixAutoUpdate = source.matrixAutoUpdate;
						return this;
					}
					toJSON(meta) {
						const data = super.toJSON(meta);
						if (this.fog !== null)
							data.object.fog = this.fog.toJSON();
						return data;
					}
				}
				exports.Scene = Scene;


				/***/
}),

/***/ "./modules/views/Stage.ts":
/*!********************************!*\
  !*** ./modules/views/Stage.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.Stage = void 0;
				const constants_1 = __webpack_require__(/*! ../../libs/three/constants */ "./libs/three/constants.js");
				const WebGL1Renderer_1 = __webpack_require__(/*! ../../libs/three/renderers/WebGL1Renderer */ "./libs/three/renderers/WebGL1Renderer.js");
				const Scene_1 = __webpack_require__(/*! ../../libs/three/scenes/Scene */ "./libs/three/scenes/Scene.js");
				const Layers_1 = __webpack_require__(/*! ./Layers */ "./modules/views/Layers.ts");
				const EventDispatcher_1 = __webpack_require__(/*! ../../libs/three/core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
				// 舞台
				// 结构为 stage → layers → scene|panel
				// render里 按顺序分别渲染
				class Stage extends Scene_1.Scene {
					constructor(canvas, canvasWidth, canvasHeight, resolution) {
						super();
						this.name = "Stage";
						this.canvas = canvas;
						this.canvasWidth = canvasWidth;
						this.canvasHeight = canvasHeight;
						let antialias = false;
						if (window) {
							antialias = true;
						}
						const renderer = new WebGL1Renderer_1.WebGL1Renderer({ canvas, antialias, alpha: true });
						// renderer.gammaFactor = 2.2;
						// renderer.outputEncoding = sRGBEncoding;
						// 用gamma会更亮，效果更好
						renderer.gammaFactor = 2.3;
						renderer.outputEncoding = constants_1.GammaEncoding;
						// turn on the physically correct lighting model
						renderer.physicallyCorrectLights = true;
						//@ts-ignore
						renderer.setPixelRatio(resolution);
						renderer.setSize(canvasWidth, canvasHeight);
						//@ts-ignore
						renderer.shadowMap.enabled = true;
						//@ts-ignore
						renderer.shadowMap.type = constants_1.PCFSoftShadowMap;
						// 取消自动更新
						renderer.autoClear = false;
						this.renderer = renderer;
						//监听下上下文丢失的情况
						// if (getEnv() == "web") {
						//     canvas.addEventListener(
						//         'webglcontextlost',
						//         this.renderer.onContextLost,
						//         false
						//     );
						//     canvas.addEventListener(
						//         'webglcontextrestored',
						//         this.renderer.onContextRestored,
						//         false
						//     );
						// }
					}
					flush() {
						var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
						this.renderer.autoClear = false;
						this.renderer.clear(undefined, undefined, undefined);
						// 更新数据
						this.traverse((o) => {
							o.dispatchEvent({ type: EventDispatcher_1.EventType.ENTERFRAME });
						});
						// 渲染各个层级
						((_b = (_a = Layers_1.layers === null || Layers_1.layers === void 0 ? void 0 : Layers_1.layers.bottomLayer) === null || _a === void 0 ? void 0 : _a.children) === null || _b === void 0 ? void 0 : _b.length) > 0 && this.renderer.render(Layers_1.layers.bottomLayer, Layers_1.layers.bottomLayerCamera);
						((_d = (_c = Layers_1.layers === null || Layers_1.layers === void 0 ? void 0 : Layers_1.layers.mainLayer) === null || _c === void 0 ? void 0 : _c.children) === null || _d === void 0 ? void 0 : _d.length) > 0 && this.renderer.render(Layers_1.layers.mainLayer, Layers_1.layers.mainLayerCamera);
						((_f = (_e = Layers_1.layers === null || Layers_1.layers === void 0 ? void 0 : Layers_1.layers.topLayer) === null || _e === void 0 ? void 0 : _e.children) === null || _f === void 0 ? void 0 : _f.length) > 0 && this.renderer.render(Layers_1.layers.topLayer, Layers_1.layers.topLayerCamera);
						((_h = (_g = Layers_1.layers === null || Layers_1.layers === void 0 ? void 0 : Layers_1.layers.popupLayer) === null || _g === void 0 ? void 0 : _g.children) === null || _h === void 0 ? void 0 : _h.length) > 0 && this.renderer.render(Layers_1.layers.popupLayer, Layers_1.layers.popupLayerCamera);
						((_k = (_j = Layers_1.layers === null || Layers_1.layers === void 0 ? void 0 : Layers_1.layers.loadingLayer) === null || _j === void 0 ? void 0 : _j.children) === null || _k === void 0 ? void 0 : _k.length) > 0 &&
							this.renderer.render(Layers_1.layers.loadingLayer, Layers_1.layers.loadingLayerCamera);
					}
				}
				exports.Stage = Stage;


				/***/
}),

/***/ "./src/Main.ts":
/*!*********************!*\
  !*** ./src/Main.ts ***!
  \*********************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.TWEEN = exports.ModelList = exports.GDispatcher = exports.Main = exports.__compileEnv__ = void 0;
				const ChangeGenderScene_1 = __webpack_require__(/*! ./scenes/ChangeGenderScene/ChangeGenderScene */ "./src/scenes/ChangeGenderScene/ChangeGenderScene.ts");
				const SceneCtrl_1 = __webpack_require__(/*! ./../modules/ctrls/SceneCtrl */ "./modules/ctrls/SceneCtrl.ts");
				const adapter_1 = __webpack_require__(/*! ../libs/adapter/adapter */ "./libs/adapter/adapter.js");
				const Stage_1 = __webpack_require__(/*! ../modules/views/Stage */ "./modules/views/Stage.ts");
				const Layers_1 = __webpack_require__(/*! ../modules/views/Layers */ "./modules/views/Layers.ts");
				const Index_1 = __webpack_require__(/*! ../modules/ctrls/Index */ "./modules/ctrls/Index.ts");
				const MainScene_1 = __webpack_require__(/*! ./scenes/MainScene/MainScene */ "./src/scenes/MainScene/MainScene.ts");
				const EventDispatcher_1 = __webpack_require__(/*! ../libs/three/core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
				const tween_1 = __webpack_require__(/*! ../libs/tween */ "./libs/tween/index.ts");
				const customerAvatarScene_1 = __webpack_require__(/*! ./scenes/CustomerAvatarScene/customerAvatarScene */ "./src/scenes/CustomerAvatarScene/customerAvatarScene.ts");
				const CreateImgsScene_1 = __webpack_require__(/*! ./scenes/CreateImgsScene/CreateImgsScene */ "./src/scenes/CreateImgsScene/CreateImgsScene.ts");
				const MiniCardScene_1 = __webpack_require__(/*! ./scenes/MiniCardScene/MiniCardScene */ "./src/scenes/MiniCardScene/MiniCardScene.ts");
				const AthletarConfig_1 = __webpack_require__(/*! ./common/AthletarConfig */ "./src/common/AthletarConfig.ts");
				Object.defineProperty(exports, "ModelList", { enumerable: true, get: function () { return AthletarConfig_1.ModelList; } });
				const BigCardScene_1 = __webpack_require__(/*! ./scenes/BigCardScene/BigCardScene */ "./src/scenes/BigCardScene/BigCardScene.ts");
				// 编译环境  小部件和小程序使用的模型不一样
				// index|customerAvatar|changeGender|createImgsScene|miniCard|bigCard
				//（小部件打包完记得改output里modelPath和小部件解析的代码）
				exports.__compileEnv__ = "createImgsScene";
				// 显示fps，小程序里需要有一个id为fps的canvas组件才能显示
				const showFPS = false;
				// console.log = function () {};
				class Main {
					constructor(canvas, canW = 750, canH = 1624, systemInfo) {
						this._pause = false;
						try {
							this.init(canvas, canW, canH, systemInfo);
						}
						catch (e) {
							console.warn(e);
						}
					}
					init(canvas, canW = 750, canH = 1624, systemInfo) {
						return __awaiter(this, void 0, void 0, function* () {
							//淘宝小程序环境就用canvas初始化
							if (!window) {
								//自行处理吧，这么判断也不保险，万一淘宝小程序加进了window
								this.platForm = new adapter_1.TaobaoPlatform(canvas, canW, canH);
								//@ts-ignore
								my.global = this.platForm.getGlobals();
								//@ts-ignore
								my.global.canvas = canvas;
								this.canvas = canvas;
							}
							else {
								window["mainCanvas"] = canvas;
							}
							console.log("canvasWidth:", canW, "canvasHeight", canH);
							let ratio = exports.__compileEnv__ == "bigCard" ? 1 : (systemInfo && systemInfo.pixelRatio) || window.devicePixelRatio || 1;
							// 创建舞台
							const stage = (this.stage = new Stage_1.Stage(canvas, canW, canH, ratio //分辨率
							));
							// 初始化层级
							Layers_1.layers.init(stage);
							window && (window["stage"] = stage);
							window && (window["camera"] = Layers_1.layers.mainLayerCamera);
							// TODO 获取初始化数据
							// await sendTbNet(TbNetName.itemConfig)
							// 切换场景
							if (exports.__compileEnv__ == "index") {
								Index_1.changeScene(MainScene_1.MainScene);
							}
							else if (exports.__compileEnv__ == "customerAvatar") {
								Index_1.changeScene(customerAvatarScene_1.CustomerAvatarScene);
							}
							else if (exports.__compileEnv__ == "changeGender") {
								Index_1.changeScene(ChangeGenderScene_1.ChangeGenderScene);
							}
							else if (exports.__compileEnv__ == "createImgsScene") {
								Index_1.changeScene(CreateImgsScene_1.CreateImgsScene);
							}
							else if (exports.__compileEnv__ == "miniCard") {
								Index_1.changeScene(MiniCardScene_1.MiniCardScene);
							}
							else if (exports.__compileEnv__ == "bigCard") {
								Index_1.changeScene(BigCardScene_1.BigCardScene);
							}
							let lastCalledTime;
							let fps;
							let fpsCanvas;
							let fpsCtx;
							if (showFPS) {
								try {
									if (window) {
										fpsCanvas = document.getElementById("fps");
										fpsCtx = fpsCanvas.getContext("2d");
									}
									else {
										//@ts-ignore
										my.createCanvas({
											id: "fps",
											success: (c) => {
												fpsCanvas = c;
												fpsCtx = fpsCanvas.getContext("2d");
											},
										});
									}
								}
								catch (e) {
									console.warn("初始化fps的canvas失败");
								}
							}
							const loop = () => {
								if (this.disposing)
									return;
								if (!this._pause) {
									tween_1.Tween.flush();
									stage.flush();
									if (showFPS) {
										let now = Date.now();
										if (!lastCalledTime) {
											lastCalledTime = now;
											fps = 999;
										}
										else {
											let delta = (now - lastCalledTime) / 1000;
											lastCalledTime = now;
											fps = 1 / delta;
										}
										fpsCanvas && (fpsCanvas.height = fpsCanvas.height);
										fpsCtx && (fpsCtx.font = "30px serif");
										fpsCtx && fpsCtx.fillText(Math.floor(fps) + " fps", 20, 50);
									}
								}
								// @ts-ignore
								this.requestID = this.canvas && this.canvas.requestAnimationFrame ? this.canvas.requestAnimationFrame(loop) : requestAnimationFrame(loop);
							};
							loop();
						});
					}
					// 运行
					run() {
						console.log("运行");
						this._pause = false;
					}
					// 暂停
					pause() {
						console.log("暂停");
						this._pause = true;
					}
					// 销毁
					destory() {
						try {
							tween_1.Tween.removeAllTweens();
							//@ts-ignore
							this.canvas && this.canvas.cancelAnimationFrame ? this.canvas.cancelAnimationFrame(this.requestID) : cancelAnimationFrame(this.requestID);
							SceneCtrl_1.SceneCtrl.ins.destroy();
							Layers_1.layers.destory();
							this.stage.clear();
							//@ts-ignore
							this.stage = null;
							exports.GDispatcher.removeAllEvent();
						}
						catch (e) {
							console.log("Main destory Error===>", e);
						}
					}
				}
				exports.Main = Main;
				// 全局事件派发器
				exports.GDispatcher = new EventDispatcher_1.EventDispatcher();
				exports.TWEEN = tween_1.Tween;


				/***/
}),

/***/ "./src/Tools.ts":
/*!**********************!*\
  !*** ./src/Tools.ts ***!
  \**********************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.getEnv = exports.Tools = void 0;
				const Layers_1 = __webpack_require__(/*! ../modules/views/Layers */ "./modules/views/Layers.ts");
				const GLTFLoader_1 = __webpack_require__(/*! ../libs/three/loaders/GLTFLoader */ "./libs/three/loaders/GLTFLoader.js");
				const meshopt_decoder_asm_module_1 = __webpack_require__(/*! ../libs/three/loaders/meshopt_decoder.asm.module */ "./libs/three/loaders/meshopt_decoder.asm.module.js");
				const Main_1 = __webpack_require__(/*! ./Main */ "./src/Main.ts");
				exports.Tools = {
					/**
					 * 获取gltf模型加载器
					 * @param {*} path
					 * @returns
					 */
					getLoader: function (path) {
						let loader = new GLTFLoader_1.GLTFLoader();
						// let ktx2Loader = new KTX2Loader()
						// 	.setTranscoderPath("js/libs/basis/")
						// 	.detectSupport(renderer);
						// loader.setKTX2Loader(ktx2Loader);
						loader.setComplieEnv(Main_1.__compileEnv__);
						loader.setMeshoptDecoder(meshopt_decoder_asm_module_1.MeshoptDecoder);
						loader.setPath(path);
						return loader;
					},
					wait(time = 500) {
						return __awaiter(this, void 0, void 0, function* () {
							return new Promise((r) => {
								setTimeout(r, time);
							});
						});
					},
					cutImg(type, name) {
						// 截图大小配置
						//TODO 看模型精细度不行就把画布再放大
						let a = {
							left: [0, 0, 2248, 2248, 0, 0, 1124, 1124],
							right: [0, 0, 2248, 2248, 0, 0, 1124, 1124],
							front: [0, 0, 2248, 2248, 0, 0, 1124, 1124],
							avatar: [0, 0, 2248, 2248, 0, 0, 240, 240],
							shareImg: [0, 0, 2248, 2248, 0, 0, 562, 562],
						};
						let { 0: beginX, 1: beginY, 2: beginW, 3: beginH, 4: endX, 5: endY, 6: endW, 7: endH } = a[type];
						return new Promise((r, j) => {
							try {
								let image = new Image();
								image.setAttribute("crossOrigin", "anonymous");
								document.body.appendChild(image);
								//renderer为three.js里的渲染器，scene为场景 camera为相机
								Layers_1.layers.stage.renderer.render(Layers_1.layers.mainLayer, Layers_1.layers.mainLayerCamera);
								// 这里是3d小人的画布
								let canvas = document.getElementById("canvas");
								//这里可以选择png格式jpeg格式
								// @ts-ignore
								let imgData = canvas.toDataURL("image/png");
								image.onload = () => {
									// 处理图像的画布
									let canvas2 = document.getElementById("cc");
									// 重置canvas大小为截图目标大小
									// @ts-ignore
									canvas2.width = endW;
									// @ts-ignore
									canvas2.height = endH;
									// @ts-ignore
									let ctx = canvas2.getContext("2d");
									// 头像需要截圆图
									if (type == "avatar") {
										let diameter = endW;
										let radius = endW / 2;
										ctx.clearRect(0, 0, diameter, diameter);
										// 截圆形图
										ctx.save();
										ctx.beginPath();
										ctx.arc(radius, radius, radius, 0, Math.PI * 2);
										ctx.clip();
										ctx.drawImage(image, beginX, beginY, beginW, beginH, endX, endY, diameter, diameter);
										ctx.restore();
									}
									else {
										ctx.clearRect(0, 0, endW, endH);
										ctx.drawImage(image, beginX, beginY, beginW, beginH, endX, endY, endW, endH);
									}
									// 将绘制的图片转换为base64
									// @ts-ignore
									let url = canvas2.toDataURL("image/png");
									// 生成一个a标签
									let aa = document.createElement("a");
									// 创建一个单击事件
									var event = new MouseEvent("click");
									// 将a的download属性设置为我们想要下载的图片名称，若name不存在则使用‘下载图片名称’作为默认名称
									aa.download = name || "下载图片名称";
									// 将生成的URL设置为a.href属性
									aa.href = url;
									// 触发a的单击事件
									aa.dispatchEvent(event);
									setTimeout(() => {
										document.body.removeChild(image);
										//@ts-ignore
										image = null;
										//@ts-ignore
										aa = null;
										//@ts-ignore
										imgData = null;
										//@ts-ignore
										url = null;
									}, 0);
									r();
								};
								image.src = imgData;
							}
							catch (err) {
								j(err);
							}
						});
					},
					/**
					 * 加载模型
					 */
					loadGltf(path, uri) {
						return new Promise((resolve, reject) => {
							let loader = this.getLoader(path);
							loader.load(uri + "?_t=" + Date.now(), resolve, () => { }, reject);
						});
					},
					// 将传入节点及所有子节点的castShadow设置为true
					castShadow: function (node) {
						node.traverse((child) => {
							if (child.isMesh || child.isSkinMesh) {
								child.castShadow = true;
							}
						});
					},
					// 将传入节点及所有子节点的receiveShadow设置为true
					receiveShadow: function (node) {
						node.traverse((child) => {
							if (child.isMesh || child.isSkinMesh) {
								//child.type.indexOf("Mesh")>0
								child.receiveShadow = true;
							}
						});
					},
					// 将小程序点击事件适配到Three
					adaptEvent: function (e) {
						if (window) {
							let { data } = e;
							if (data.touches) {
								for (let i = 0; i < data.touches.length; i++) {
									let t = data.touches[i];
									t.x = t.pageX;
									t.y = t.pageY;
								}
								for (let i = 0; i < data.changedTouches.length; i++) {
									let t = data.changedTouches[i];
									t.x = t.pageX;
									t.y = t.pageY;
								}
							}
							else {
								data.changedTouches = [
									{
										x: data.pageX,
										y: data.pageY,
										pageX: data.pageX,
										pageY: data.pageY,
										identifier: 0,
									},
								];
								data.touches = [
									{
										x: data.pageX,
										y: data.pageY,
										pageX: data.pageX,
										pageY: data.pageY,
										identifier: 0,
									},
								];
							}
						}
						else {
							let { data } = e;
							data.touches.forEach((t) => {
								t.pageX = t.x;
								t.pageY = t.y;
							});
							if (data.changedTouches && data.changedTouches.length > 0) {
								data.changedTouches.forEach((t) => {
									t.pageX = t.x;
									t.pageY = t.y;
								});
							}
							else {
								data.changedTouches = data.touches;
							}
						}
						return e;
					},
					// 销毁节点下所有material，map，geometry
					// TODO bitmapImage待销毁  使用close()
					disposeObj(node) {
						try {
							// let count = 0;
							// TODO 改成后序遍历
							node.traverse((child) => {
								var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
								if ((_a = child.geometry) === null || _a === void 0 ? void 0 : _a.dispose) {
									child.geometry.dispose(); //删除几何体
								}
								if ((_c = (_b = child.material) === null || _b === void 0 ? void 0 : _b.map) === null || _c === void 0 ? void 0 : _c.dispose) {
									console.log(`%c======开始销毁Map======`, "color:orange;");
									console.log((_d = child.material.map.image) === null || _d === void 0 ? void 0 : _d.src);
									child.material.map.dispose();
								}
								if ((_f = (_e = child.material) === null || _e === void 0 ? void 0 : _e.normalMap) === null || _f === void 0 ? void 0 : _f.dispose) {
									console.log(`%c======开始销毁NormalMap======`, "color:orange;");
									console.log((_g = child.material.normalMap.image) === null || _g === void 0 ? void 0 : _g.src);
									child.material.normalMap.dispose();
								}
								if ((_h = child.material) === null || _h === void 0 ? void 0 : _h.dispose) {
									child.material.dispose(); //删除材质
								}
								if ((_k = (_j = child.skeleton) === null || _j === void 0 ? void 0 : _j.boneTexture) === null || _k === void 0 ? void 0 : _k.dispose) {
									console.log(`%c======开始销毁BoneTexture======`, "color:orange;");
									(_m = (_l = child.skeleton) === null || _l === void 0 ? void 0 : _l.boneTexture) === null || _m === void 0 ? void 0 : _m.dispose();
								}
								if ((_o = child.skeleton) === null || _o === void 0 ? void 0 : _o.dispose) {
									child.skeleton.dispose();
								}
							});
						}
						catch (err) {
							console.warn("disposeErr:", err);
						}
					},
					disposeChild(mesh) {
						var _a, _b, _c, _d;
						if ((_a = mesh.geometry) === null || _a === void 0 ? void 0 : _a.dispose) {
							mesh.geometry.dispose(); //删除几何体
						}
						if ((_c = (_b = mesh.material) === null || _b === void 0 ? void 0 : _b.map) === null || _c === void 0 ? void 0 : _c.dispose) {
							mesh.material.map.dispose();
						}
						if ((_d = mesh.material) === null || _d === void 0 ? void 0 : _d.dispose) {
							mesh.material.dispose(); //删除材质
						}
						// if (mesh instanceof Group) {
						// 	mesh.clear();
						// }
						// if (mesh instanceof Object3D) {
						// 	mesh.clear();
						// }
					},
					// 材质类型替换  使用相同map,color
					// TODO 后续添加新值
					convertMaterial: function (cls, material) {
						let { map, color } = material;
						let newMaterial = new cls({ map, color });
						return newMaterial;
					},
				};
				exports.getEnv = function () {
					return window ? "web" : "tb";
				};


				/***/
}),

/***/ "./src/common/AthletarConfig.ts":
/*!**************************************!*\
  !*** ./src/common/AthletarConfig.ts ***!
  \**************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.ModelList = exports.MaterialType = exports.ActionType = exports.GenderType = exports.ModelType = exports.ModelPath = void 0;
				// 模型加载路径
				// export const ModelPath = "https://duiba.oss-cn-hangzhou.aliyuncs.com/db_games/activity/nike_avatarchanger_0505/";
				// export const ModelPath = "https://duiba.oss-cn-hangzhou.aliyuncs.com/db_games/activity/nike_avatarchanger_0916/";
				exports.ModelPath = "https://wildwood-test.oss-cn-beijing.aliyuncs.com/avatar/d11/model/";
				// export const ModelPath = "../../../assets/CNYModel1125/";
				// 模型分类
				var ModelType;
				(function (ModelType) {
					ModelType["LOOKBOOK"] = "lookBook";
					ModelType["UPPER"] = "upper";
					ModelType["LOWER"] = "lower";
					ModelType["ONEPIECE"] = "onePiece";
					ModelType["SHOES"] = "shoes";
					ModelType["HEAD"] = "head";
					ModelType["HEADEXT"] = "headExt";
					ModelType["BACKGROUND"] = "background";
					ModelType["COMMON"] = "common";
					ModelType["BASKETBALL"] = "basketball";
				})(ModelType = exports.ModelType || (exports.ModelType = {}));
				// 性别
				var GenderType;
				(function (GenderType) {
					GenderType["MALE"] = "male";
					GenderType["FEMALE"] = "female";
				})(GenderType = exports.GenderType || (exports.GenderType = {}));
				// 动画动作类型
				var ActionType;
				(function (ActionType) {
					ActionType["IDLE"] = "idle";
					ActionType["RUN"] = "run";
					ActionType["BASKETBALL"] = "basketBall";
					ActionType["HIPHOP"] = "hipHop";
					ActionType["WALK"] = "walk";
				})(ActionType = exports.ActionType || (exports.ActionType = {}));
				/*
				 * 可转换的材质类型
				 */
				var MaterialType;
				(function (MaterialType) {
					MaterialType[MaterialType["MeshStandardMaterial"] = 0] = "MeshStandardMaterial";
				})(MaterialType = exports.MaterialType || (exports.MaterialType = {}));
				exports.ModelList = {
					girlBody: {
						name: "body",
						url: "women_body-pack.gltf",
						miniUrl: "women_body-pack.gltf",
						id: "girlBody",
						type: ModelType.COMMON,
						castShadow: true,
						receiveShadow: true,
					},
					boyBody: {
						name: "body",
						url: "men_body-pack.gltf",
						miniUrl: "men_body-pack.gltf",
						id: "boyBody",
						type: ModelType.COMMON,
						castShadow: true,
						receiveShadow: true,
					},
					boyHead: {
						name: "head",
						url: "men_head-pack.gltf",
						miniUrl: "men_head-pack.gltf",
						id: "boyHead",
						type: ModelType.HEADEXT,
						castShadow: true,
						receiveShadow: true,
					},
					// 篮球
					basketball: {
						name: "lanqiu",
						url: "basketball-pack.gltf",
						miniUrl: "basketball-pack.gltf",
						type: ModelType.BASKETBALL,
					},
					// 女
					// Upper
					"010000001": {
						name: "CIF009",
						url: "CIF009-pack.gltf",
						miniUrl: "CIF009-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000002": {
						name: "CIF011",
						url: "CIF011-pack.gltf",
						miniUrl: "CIF011-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000003": {
						name: "CIF013",
						url: "CIF013-pack.gltf",
						miniUrl: "CIF013-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000004": {
						name: "CIF015",
						url: "CIF015-pack.gltf",
						miniUrl: "CIF015-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000005": {
						name: "CIF017",
						url: "CIF017-pack.gltf",
						miniUrl: "CIF017-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000006": {
						name: "CIF019",
						url: "CIF019-pack.gltf",
						miniUrl: "CIF019-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000007": {
						name: "CIF021",
						url: "CIF021-pack.gltf",
						miniUrl: "CIF021-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000008": {
						name: "CIF023",
						url: "CIF023-pack.gltf",
						miniUrl: "CIF023-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000009": {
						name: "CIF025",
						url: "CIF025-pack.gltf",
						miniUrl: "CIF025-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000010": {
						name: "CIF027",
						url: "CIF027-pack.gltf",
						miniUrl: "CIF027-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000011": {
						name: "CIF030",
						url: "CIF030-pack.gltf",
						miniUrl: "CIF030-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000012": {
						name: "CIF033",
						url: "CIF033-pack.gltf",
						miniUrl: "CIF033-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000013": {
						name: "CIF035",
						url: "CIF035-pack.gltf",
						miniUrl: "CIF035-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000014": {
						name: "CIF037",
						url: "CIF037-pack.gltf",
						miniUrl: "CIF037-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000015": {
						name: "CIF039",
						url: "CIF039-pack.gltf",
						miniUrl: "CIF039-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000016": {
						name: "CIF041",
						url: "CIF041-pack.gltf",
						miniUrl: "CIF041-pack.gltf",
						type: ModelType.UPPER,
					},
					// 2023CNY新增模型
					"010000017": {
						name: "WDT003",
						url: "WDT003-pack.gltf",
						miniUrl: "WDT003-pack.gltf",
						type: ModelType.UPPER,
					},
					"010000018": {
						name: "WRT004",
						url: "WRT004-pack.gltf",
						miniUrl: "WRT004-pack.gltf",
						type: ModelType.UPPER,
					},
					//lower
					"020000001": {
						name: "CIF010",
						url: "CIF010-pack.gltf",
						miniUrl: "CIF010-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000002": {
						name: "CIF012",
						url: "CIF012-pack.gltf",
						miniUrl: "CIF012-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000003": {
						name: "CIF014",
						url: "CIF014-pack.gltf",
						miniUrl: "CIF014-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000004": {
						name: "CIF016",
						url: "CIF016-pack.gltf",
						miniUrl: "CIF016-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000005": {
						name: "CIF018",
						url: "CIF018-pack.gltf",
						miniUrl: "CIF018-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000006": {
						name: "CIF020",
						url: "CIF020-pack.gltf",
						miniUrl: "CIF020-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000007": {
						name: "CIF022",
						url: "CIF022-pack.gltf",
						miniUrl: "CIF022-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000008": {
						name: "CIF024",
						url: "CIF024-pack.gltf",
						miniUrl: "CIF024-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000009": {
						name: "CIF026",
						url: "CIF026-pack.gltf",
						miniUrl: "CIF026-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000010": {
						name: "CIF028",
						url: "CIF028-pack.gltf",
						miniUrl: "CIF028-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000011": {
						name: "CIF031",
						url: "CIF031-pack.gltf",
						miniUrl: "CIF031-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000012": {
						name: "CIF034",
						url: "CIF034-pack.gltf",
						miniUrl: "CIF034-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000013": {
						name: "CIF036",
						url: "CIF036-pack.gltf",
						miniUrl: "CIF036-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000014": {
						name: "CIF038",
						url: "CIF038-pack.gltf",
						miniUrl: "CIF038-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000015": {
						name: "CIF040",
						url: "CIF040-pack.gltf",
						miniUrl: "CIF040-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000016": {
						name: "CIF042",
						url: "CIF042-pack.gltf",
						miniUrl: "CIF042-pack.gltf",
						type: ModelType.LOWER,
					},
					// 2023CNY新增模型
					"020000017": {
						name: "WDL007",
						url: "WDL007-pack.gltf",
						miniUrl: "WDL007-pack.gltf",
						type: ModelType.LOWER,
					},
					"020000018": {
						name: "WRL008",
						url: "WRL008-pack.gltf",
						miniUrl: "WRL008-pack.gltf",
						type: ModelType.LOWER,
					},
					// onePiece
					// "030000001": {
					// 	name: "AAA",
					// 	url: "",
					// 	miniUrl: "",
					// 	type: ModelType.ONEPIECE,
					// },
					// shoes
					"040000001": {
						name: "SS1002",
						url: "SS1002-pack.gltf",
						miniUrl: "SS1002-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000002": {
						name: "SS1008",
						url: "SS1008-pack.gltf",
						miniUrl: "SS1008-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000003": {
						name: "SS1012",
						url: "SS1012-pack.gltf",
						miniUrl: "SS1012-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000004": {
						name: "SS2014",
						url: "SS2014-pack.gltf",
						miniUrl: "SS2014-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000005": {
						name: "SS2015",
						url: "SS2015-pack.gltf",
						miniUrl: "SS2015-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000006": {
						name: "SS2016",
						url: "SS2016-pack.gltf",
						miniUrl: "SS2016-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000007": {
						name: "SS2017",
						url: "SS2017-pack.gltf",
						miniUrl: "SS2017-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000008": {
						name: "SS1018",
						url: "SS1018-pack.gltf",
						miniUrl: "SS1018-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000009": {
						name: "SS2019",
						url: "SS2019-pack.gltf",
						miniUrl: "SS2019-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000010": {
						name: "SS2020",
						url: "SS2020-pack.gltf",
						miniUrl: "SS2020-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000011": {
						name: "SS2021",
						url: "SS2021-pack.gltf",
						miniUrl: "SS2021-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000012": {
						name: "SS2022",
						url: "SS2022-pack.gltf",
						miniUrl: "SS2022-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000013": {
						name: "SS2023",
						url: "SS2023-pack.gltf",
						miniUrl: "SS2023-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000014": {
						name: "SS2024",
						url: "SS2024-pack.gltf",
						miniUrl: "SS2024-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000015": {
						name: "SS2025",
						url: "SS2025-pack.gltf",
						miniUrl: "SS2025-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000016": {
						name: "SS2026",
						url: "SS2026-pack.gltf",
						miniUrl: "SS2026-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000017": {
						name: "SS2027",
						url: "SS2027-pack.gltf",
						miniUrl: "SS2027-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000018": {
						name: "SS2028",
						url: "SS2028-pack.gltf",
						miniUrl: "SS2028-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000019": {
						name: "SS2029",
						url: "SS2029-pack.gltf",
						miniUrl: "SS2029-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000020": {
						name: "SS2030",
						url: "SS2030-pack.gltf",
						miniUrl: "SS2030-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000021": {
						name: "SS2031",
						url: "SS2031-pack.gltf",
						miniUrl: "SS2031-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000022": {
						name: "SS2032",
						url: "SS2032-pack.gltf",
						miniUrl: "SS2032-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000023": {
						name: "SS2033",
						url: "SS2033-pack.gltf",
						miniUrl: "SS2033-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000024": {
						name: "SS2034",
						url: "SS2034-pack.gltf",
						miniUrl: "SS2034-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000025": {
						name: "SS2035",
						url: "SS2035-pack.gltf",
						miniUrl: "SS2035-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000026": {
						name: "SS2036",
						url: "SS2036-pack.gltf",
						miniUrl: "SS2036-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000027": {
						name: "SS2037",
						url: "SS2037-pack.gltf",
						miniUrl: "SS2037-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000028": {
						name: "SS2038",
						url: "SS2038-pack.gltf",
						miniUrl: "SS2038-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000029": {
						name: "SS2039",
						url: "SS2039-pack.gltf",
						miniUrl: "SS2039-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000030": {
						name: "SS2040",
						url: "SS2040-pack.gltf",
						miniUrl: "SS2040-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000031": {
						name: "SS2041",
						url: "SS2041-pack.gltf",
						miniUrl: "SS2041-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000032": {
						name: "SS2042",
						url: "SS2042-pack.gltf",
						miniUrl: "SS2042-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000033": {
						name: "SS2043",
						url: "SS2043-pack.gltf",
						miniUrl: "SS2043-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000034": {
						name: "SS2044",
						url: "SS2044-pack.gltf",
						miniUrl: "SS2044-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000035": {
						name: "SS2045",
						url: "SS2045-pack.gltf",
						miniUrl: "SS2045-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000036": {
						name: "SS2046",
						url: "SS2046-pack.gltf",
						miniUrl: "SS2046-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000037": {
						name: "SS2047",
						url: "SS2047-pack.gltf",
						miniUrl: "SS2047-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000038": {
						name: "SS2048",
						url: "SS2048-pack.gltf",
						miniUrl: "SS2048-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000039": {
						name: "SS2049",
						url: "SS2049-pack.gltf",
						miniUrl: "SS2049-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000040": {
						name: "SS2050",
						url: "SS2050-pack.gltf",
						miniUrl: "SS2050-pack.gltf",
						type: ModelType.SHOES,
					},
					// 2023CNY新增模型
					"040000041": {
						name: "MBS009",
						url: "MBS009-pack.gltf",
						miniUrl: "MBS009-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000042": {
						name: "MDS010",
						url: "MDS010-pack.gltf",
						miniUrl: "MDS010-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000043": {
						name: "WRS011",
						url: "WRS011-pack.gltf",
						miniUrl: "WRS011-pack.gltf",
						type: ModelType.SHOES,
					},
					"040000044": {
						name: "WDS012",
						url: "WDS012-pack.gltf",
						miniUrl: "WDS012-pack.gltf",
						type: ModelType.SHOES,
					},
					// head
					"050000001": {
						name: "HAIR0001",
						url: "HAIR0001-pack.gltf",
						miniUrl: "HAIR0001-pack.gltf",
						type: ModelType.HEAD,
					},
					"050000002": {
						name: "HAIR0002",
						url: "women_hair-pack.gltf",
						miniUrl: "women_hair-pack.gltf",
						type: ModelType.HEAD,
					},
					"050000003": {
						name: "HAIR0003",
						url: "HAIR0003-pack.gltf",
						miniUrl: "HAIR0003-pack.gltf",
						type: ModelType.HEAD,
					},
					// 男
					// Upper
					"011000001": {
						name: "CIM011",
						url: "CIM011-pack.gltf",
						miniUrl: "CIM011-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000002": {
						name: "CIM013",
						url: "CIM013-pack.gltf",
						miniUrl: "CIM013-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000003": {
						name: "CIM015",
						url: "CIM015-pack.gltf",
						miniUrl: "CIM015-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000004": {
						name: "CIM017",
						url: "CIM017-pack.gltf",
						miniUrl: "CIM017-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000005": {
						name: "CIM019",
						url: "CIM019-pack.gltf",
						miniUrl: "CIM019-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000006": {
						name: "CIM021",
						url: "CIM021-pack.gltf",
						miniUrl: "CIM021-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000007": {
						name: "CIM023",
						url: "CIM023-pack.gltf",
						miniUrl: "CIM023-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000008": {
						name: "CIM025",
						url: "CIM025-pack.gltf",
						miniUrl: "CIM025-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000009": {
						name: "CIM027",
						url: "CIM027-pack.gltf",
						miniUrl: "CIM027-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000010": {
						name: "CIM029",
						url: "CIM029-pack.gltf",
						miniUrl: "CIM029-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000011": {
						name: "CIM031",
						url: "CIM031-pack.gltf",
						miniUrl: "CIM031-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000012": {
						name: "CIM033",
						url: "CIM033-pack.gltf",
						miniUrl: "CIM033-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000013": {
						name: "CIM035",
						url: "CIM035-pack.gltf",
						miniUrl: "CIM035-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000014": {
						name: "CIM037",
						url: "CIM037-pack.gltf",
						miniUrl: "CIM037-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000015": {
						name: "CIM039",
						url: "CIM039-pack.gltf",
						miniUrl: "CIM039-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000016": {
						name: "CIM041",
						url: "CIM041-pack.gltf",
						miniUrl: "CIM041-pack.gltf",
						type: ModelType.UPPER,
					},
					// 2023CNY新增模型
					"011000017": {
						name: "MBT001",
						url: "MBT001-pack.gltf",
						miniUrl: "MBT001-pack.gltf",
						type: ModelType.UPPER,
					},
					"011000018": {
						name: "MDT002",
						url: "MDT002-pack.gltf",
						miniUrl: "MDT002-pack.gltf",
						type: ModelType.UPPER,
					},
					//lower
					"021000001": {
						name: "CIM012",
						url: "CIM012-pack.gltf",
						miniUrl: "CIM012-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000002": {
						name: "CIM014",
						url: "CIM014-pack.gltf",
						miniUrl: "CIM014-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000003": {
						name: "CIM016",
						url: "CIM016-pack.gltf",
						miniUrl: "CIM016-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000004": {
						name: "CIM018",
						url: "CIM018-pack.gltf",
						miniUrl: "CIM018-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000005": {
						name: "CIM020",
						url: "CIM020-pack.gltf",
						miniUrl: "CIM020-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000006": {
						name: "CIM022",
						url: "CIM022-pack.gltf",
						miniUrl: "CIM022-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000007": {
						name: "CIM024",
						url: "CIM024-pack.gltf",
						miniUrl: "CIM024-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000008": {
						name: "CIM026",
						url: "CIM026-pack.gltf",
						miniUrl: "CIM026-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000009": {
						name: "CIM028",
						url: "CIM028-pack.gltf",
						miniUrl: "CIM028-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000010": {
						name: "CIM030",
						url: "CIM030-pack.gltf",
						miniUrl: "CIM030-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000011": {
						name: "CIM032",
						url: "CIM032-pack.gltf",
						miniUrl: "CIM032-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000012": {
						name: "CIM034",
						url: "CIM034-pack.gltf",
						miniUrl: "CIM034-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000013": {
						name: "CIM036",
						url: "CIM036-pack.gltf",
						miniUrl: "CIM036-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000014": {
						name: "CIM038",
						url: "CIM038-pack.gltf",
						miniUrl: "CIM038-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000015": {
						name: "CIM040",
						url: "CIM040-pack.gltf",
						miniUrl: "CIM040-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000016": {
						name: "CIM042",
						url: "CIM042-pack.gltf",
						miniUrl: "CIM042-pack.gltf",
						type: ModelType.LOWER,
					},
					// 2023CNY新增模型
					"021000017": {
						name: "MDL005",
						url: "MDL005-pack.gltf",
						miniUrl: "MDL005-pack.gltf",
						type: ModelType.LOWER,
					},
					"021000018": {
						name: "MBL006",
						url: "MBL006-pack.gltf",
						miniUrl: "MBL006-pack.gltf",
						type: ModelType.LOWER,
					},
					// onePiece
					// "031000001": {
					// 	name: "AAA",
					// 	url: "QQQ",
					// 	miniUrl: "body-pack.gltf",
					// 	type: ModelType.ONEPIECE,
					// },
					// shoes
					"041000001": {
						name: "SS1002",
						url: "SS1002-pack.gltf",
						miniUrl: "SS1002-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000002": {
						name: "SS1008",
						url: "SS1008-pack.gltf",
						miniUrl: "SS1008-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000003": {
						name: "SS1012",
						url: "SS1012-pack.gltf",
						miniUrl: "SS1012-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000004": {
						name: "SS2014",
						url: "SS2014-pack.gltf",
						miniUrl: "SS2014-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000005": {
						name: "SS2015",
						url: "SS2015-pack.gltf",
						miniUrl: "SS2015-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000006": {
						name: "SS2016",
						url: "SS2016-pack.gltf",
						miniUrl: "SS2016-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000007": {
						name: "SS2017",
						url: "SS2017-pack.gltf",
						miniUrl: "SS2017-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000008": {
						name: "SS1018",
						url: "SS1018-pack.gltf",
						miniUrl: "SS1018-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000009": {
						name: "SS2019",
						url: "SS2019-pack.gltf",
						miniUrl: "SS2019-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000010": {
						name: "SS2020",
						url: "SS2020-pack.gltf",
						miniUrl: "SS2020-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000011": {
						name: "SS2021",
						url: "SS2021-pack.gltf",
						miniUrl: "SS2021-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000012": {
						name: "SS2022",
						url: "SS2022-pack.gltf",
						miniUrl: "SS2022-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000013": {
						name: "SS2023",
						url: "SS2023-pack.gltf",
						miniUrl: "SS2023-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000014": {
						name: "SS2024",
						url: "SS2024-pack.gltf",
						miniUrl: "SS2024-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000015": {
						name: "SS2025",
						url: "SS2025-pack.gltf",
						miniUrl: "SS2025-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000016": {
						name: "SS2026",
						url: "SS2026-pack.gltf",
						miniUrl: "SS2026-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000017": {
						name: "SS2027",
						url: "SS2027-pack.gltf",
						miniUrl: "SS2027-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000018": {
						name: "SS2028",
						url: "SS2028-pack.gltf",
						miniUrl: "SS2028-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000019": {
						name: "SS2029",
						url: "SS2029-pack.gltf",
						miniUrl: "SS2029-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000020": {
						name: "SS2030",
						url: "SS2030-pack.gltf",
						miniUrl: "SS2030-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000021": {
						name: "SS2031",
						url: "SS2031-pack.gltf",
						miniUrl: "SS2031-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000022": {
						name: "SS2032",
						url: "SS2032-pack.gltf",
						miniUrl: "SS2032-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000023": {
						name: "SS2033",
						url: "SS2033-pack.gltf",
						miniUrl: "SS2033-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000024": {
						name: "SS2034",
						url: "SS2034-pack.gltf",
						miniUrl: "SS2034-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000025": {
						name: "SS2035",
						url: "SS2035-pack.gltf",
						miniUrl: "SS2035-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000026": {
						name: "SS2036",
						url: "SS2036-pack.gltf",
						miniUrl: "SS2036-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000027": {
						name: "SS2037",
						url: "SS2037-pack.gltf",
						miniUrl: "SS2037-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000028": {
						name: "SS2038",
						url: "SS2038-pack.gltf",
						miniUrl: "SS2038-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000029": {
						name: "SS2039",
						url: "SS2039-pack.gltf",
						miniUrl: "SS2039-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000030": {
						name: "SS2040",
						url: "SS2040-pack.gltf",
						miniUrl: "SS2040-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000031": {
						name: "SS2041",
						url: "SS2041-pack.gltf",
						miniUrl: "SS2041-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000032": {
						name: "SS2042",
						url: "SS2042-pack.gltf",
						miniUrl: "SS2042-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000033": {
						name: "SS2043",
						url: "SS2043-pack.gltf",
						miniUrl: "SS2043-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000034": {
						name: "SS2044",
						url: "SS2044-pack.gltf",
						miniUrl: "SS2044-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000035": {
						name: "SS2045",
						url: "SS2045-pack.gltf",
						miniUrl: "SS2045-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000036": {
						name: "SS2046",
						url: "SS2046-pack.gltf",
						miniUrl: "SS2046-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000037": {
						name: "SS2047",
						url: "SS2047-pack.gltf",
						miniUrl: "SS2047-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000038": {
						name: "SS2048",
						url: "SS2048-pack.gltf",
						miniUrl: "SS2048-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000039": {
						name: "SS2049",
						url: "SS2049-pack.gltf",
						miniUrl: "SS2049-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000040": {
						name: "SS2050",
						url: "SS2050-pack.gltf",
						miniUrl: "SS2050-pack.gltf",
						type: ModelType.SHOES,
					},
					// 2023CNY新增模型
					"041000041": {
						name: "MBS009",
						url: "MBS009-pack.gltf",
						miniUrl: "MBS009-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000042": {
						name: "MDS010",
						url: "MDS010-pack.gltf",
						miniUrl: "MDS010-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000043": {
						name: "WRS011",
						url: "WRS011-pack.gltf",
						miniUrl: "WRS011-pack.gltf",
						type: ModelType.SHOES,
					},
					"041000044": {
						name: "WDS012",
						url: "WDS012-pack.gltf",
						miniUrl: "WDS012-pack.gltf",
						type: ModelType.SHOES,
					},
					// head
					"051000001": {
						name: "HAIR1001",
						url: "HAIR1001-pack.gltf",
						miniUrl: "HAIR1001-pack.gltf",
						type: ModelType.HEAD,
					},
					"051000002": {
						name: "HAIR1002",
						url: "HAIR1002-pack.gltf",
						miniUrl: "HAIR1002-pack.gltf",
						type: ModelType.HEAD,
					},
					"051000003": {
						name: "HAIR1003",
						url: "HAIR1003-pack.gltf",
						miniUrl: "HAIR1003-pack.gltf",
						type: ModelType.HEAD,
					},
					// 2023CNY新增模型
					"051000004": {
						name: "MBAC013",
						url: "MBAC013-pack.gltf",
						miniUrl: "MBAC013-pack.gltf",
						hideHead: true,
						type: ModelType.HEAD,
					},
					"051000005": {
						name: "MDAC014",
						url: "MDAC014-pack.gltf",
						miniUrl: "MDAC014-pack.gltf",
						type: ModelType.HEAD,
					},
				};


				/***/
}),

/***/ "./src/common/AthletarCtrl.ts":
/*!************************************!*\
  !*** ./src/common/AthletarCtrl.ts ***!
  \************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				var __importDefault = (this && this.__importDefault) || function (mod) {
					return (mod && mod.__esModule) ? mod : { "default": mod };
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.AthletarCtrl = void 0;
				const MeshBasicMaterial_1 = __webpack_require__(/*! ../../libs/three/materials/MeshBasicMaterial */ "./libs/three/materials/MeshBasicMaterial.js");
				const Tools_1 = __webpack_require__(/*! ../Tools */ "./src/Tools.ts");
				const AthletarConfig_1 = __webpack_require__(/*! ./AthletarConfig */ "./src/common/AthletarConfig.ts");
				const AnimationMixer_1 = __webpack_require__(/*! ../../libs/three/animation/AnimationMixer */ "./libs/three/animation/AnimationMixer.js");
				const Tween_1 = __importDefault(__webpack_require__(/*! ../../libs/tween/Tween */ "./libs/tween/Tween.ts"));
				const Group_1 = __webpack_require__(/*! ../../libs/three/objects/Group */ "./libs/three/objects/Group.js");
				const Main_1 = __webpack_require__(/*! ../../src/Main */ "./src/Main.ts");
				const Vector3_1 = __webpack_require__(/*! ../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const GltfPool_1 = __webpack_require__(/*! ./GltfPool */ "./src/common/GltfPool.ts");
				const Layers_1 = __webpack_require__(/*! ../../modules/views/Layers */ "./modules/views/Layers.ts");
				const MeshStandardMaterial_1 = __webpack_require__(/*! ../../libs/three/materials/MeshStandardMaterial */ "./libs/three/materials/MeshStandardMaterial.js");
				/**
				 * 换装控制器
				 * 不会改变相机和背景
				 * 仅控制模型和动效
				 */
				class AthletarCtrl {
					constructor(scene) {
						this.mixerPool = {};
						this.actionPool = new Map();
						this.isPlayAction = true;
						// 用于优化多页面canvas切换后parse太慢
						this.parseFlag = Date.now();
						this.waitingFlag = false;
						this.actionsList = {
							"060000001": AthletarConfig_1.ActionType.WALK,
							"060000002": AthletarConfig_1.ActionType.RUN,
							"060000003": AthletarConfig_1.ActionType.BASKETBALL,
							"060000004": AthletarConfig_1.ActionType.HIPHOP,
							"061000001": AthletarConfig_1.ActionType.WALK,
							"061000002": AthletarConfig_1.ActionType.RUN,
							"061000003": AthletarConfig_1.ActionType.BASKETBALL,
							"061000004": AthletarConfig_1.ActionType.HIPHOP,
						};
						this.currAction = AthletarConfig_1.ActionType.WALK;
						this.currGender = "";
						this.actionWeights = {
							idle: 0,
							walk: 1,
							basketball: 0,
							hiphop: 0,
							run: 0,
						};
						this._currInfo = {
							upper: "0",
							lower: "0",
							onePiece: "0",
							shoes: "0",
							head: "0",
							move: "0",
							bg: "0",
						};
						// 上一个显示的模型
						this._currGltfMap = new Map();
						// 切换模型的时候临时存放
						this._tempGltfMap = new Map();
						//切换动作
						this.basketballTween = {};
						// 所有模型切换到某一帧的动作并停止
						this.isSeekStop = false;
						// 动画更新
						this.lastTime = Date.now();
						/**
						 * 判断当前模型是否需要改变
						 * 类别：01-99 upper lower onepeace shoes head move bg
						 * 性别：女 0 男 1
						 * 序号：000001-999999
						 * id示例（类别+性别+序号）：011000001
						 * str 示例1：0_0_031000002_041000002_051000002_061000001_071000001
						 * 	   示例2: 010000001_020000002_0_040000002_050000002_060000001_07000001
						 */
						this.changeState = "";
						this.scene = scene;
						this.athletarBox = new Group_1.Group();
						this.athletarBox.name = "AthletarBox";
						this.scene.add(this.athletarBox);
						this.athletarBox.setRotationFromAxisAngle(new Vector3_1.Vector3(0, 1, 0), Math.PI * -0.2);
						// this.athletarBox.rotateY(5);
					}
					// 当前身体动画时间
					get currBodyTime() {
						return (this.mixerPool && this.mixerPool["body"] && this.mixerPool["body"].time) || 0;
					}
					startAction() {
						this.isPlayAction = true;
						let action = this.actionsList[this._currInfo.move];
						this.changeAction(action);
					}
					//直接切换动画片段
					updateAction() {
						this.actionPool.forEach((action) => {
							this.setActionWeight(action[0], this.actionWeights.idle);
							this.setActionWeight(action[1], this.actionWeights.walk);
							this.setActionWeight(action[2], this.actionWeights.run);
							this.setActionWeight(action[3], this.actionWeights.basketball);
							this.setActionWeight(action[4], this.actionWeights.hiphop);
						});
					}
					changeAction(type) {
						// if (!this.isPlayAction) return;
						if (type !== this.currAction) {
							// 切换了动作重新开始播放
							Object.keys(this.mixerPool).forEach((name) => {
								this.updateAction();
								this.mixerPool[name].setTime(0);
							});
						}
						this.currAction = type;
						let actionTween = Tween_1.default.get(this.actionWeights, {
							onChange: () => {
								this.updateAction();
							},
						});
						Tween_1.default.removeTweens(this.basketballTween);
						switch (type) {
							default:
							case AthletarConfig_1.ActionType.IDLE:
								GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.BASKETBALL]["basketball"].scene.scale.multiplyScalar(0);
								// actionTween.to({ idle: 1, walk: 0, basketball: 0, hiphop: 0, run: 0 }, 0);
								this.actionWeights = { idle: 1, walk: 0, basketball: 0, hiphop: 0, run: 0 };
								break;
							case AthletarConfig_1.ActionType.WALK:
								GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.BASKETBALL]["basketball"].scene.scale.multiplyScalar(0);
								// actionTween.to({ idle: 0, walk: 1, basketball: 0, hiphop: 0, run: 0 }, 0);
								this.actionWeights = { idle: 0, walk: 1, basketball: 0, hiphop: 0, run: 0 };
								break;
							case AthletarConfig_1.ActionType.BASKETBALL:
								Tween_1.default.get(this.basketballTween)
									.wait(100)
									.call(() => {
										let scale = GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.BASKETBALL]["basketball"].scene.scale;
										scale.x = 1;
										scale.y = 1;
										scale.z = 1;
									});
								// actionTween.to({ idle: 0, walk: 0, basketball: 1, hiphop: 0, run: 0 }, 0);
								this.actionWeights = { idle: 0, walk: 0, basketball: 1, hiphop: 0, run: 0 };
								break;
							case AthletarConfig_1.ActionType.HIPHOP:
								GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.BASKETBALL]["basketball"].scene.scale.multiplyScalar(0);
								// actionTween.to({ idle: 0, walk: 0, basketball: 0, hiphop: 1, run: 0 }, 0);
								this.actionWeights = { idle: 0, walk: 0, basketball: 0, hiphop: 1, run: 0 };
								break;
							case AthletarConfig_1.ActionType.RUN:
								GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.BASKETBALL]["basketball"].scene.scale.multiplyScalar(0);
								// actionTween.to({ idle: 0, walk: 0, basketball: 0, hiphop: 0, run: 1 }, 0);
								this.actionWeights = { idle: 0, walk: 0, basketball: 0, hiphop: 0, run: 1 };
								break;
						}
						this.updateAction();
					}
					// 设置动作权重
					setActionWeight(action, weight) {
						if (!action)
							return;
						action.enabled = true;
						action.setEffectiveTimeScale(1);
						action.setEffectiveWeight(weight);
					}
					seekStop(data) {
						let time = data.time;
						this.isSeekStop = true;
						Object.keys(this.mixerPool).forEach((name) => {
							var _a;
							this.updateAction();
							this.mixerPool[name].setTime(time);
							(_a = this.mixerPool[name]) === null || _a === void 0 ? void 0 : _a.update(1 / 1000);
						});
					}
					stopAction() {
						this.isPlayAction = false;
						this.changeAction(AthletarConfig_1.ActionType.IDLE);
					}
					updateParseFlag() {
						this.parseFlag = Date.now();
						console.log("刷新parseFlag：", this.parseFlag);
					}
					update() {
						let now = Date.now();
						let dt = now - this.lastTime;
						if (dt > 1000) {
							dt = 16.7;
						}
						this.lastTime = now;
						!this.waitingFlag &&
							!this.isSeekStop &&
							this.mixerPool &&
							Object.keys(this.mixerPool).forEach((mixer) => {
								// 只更新当前模型的动画
								this._currGltfMap.forEach((val) => {
									var _a;
									if (val.modelId == mixer) {
										(_a = this.mixerPool[mixer]) === null || _a === void 0 ? void 0 : _a.update(dt / 1000);
									}
								});
							});
					}
					checkChangePart(data, isIdle = false) {
						return __awaiter(this, void 0, void 0, function* () {
							let startCheck = Date.now();
							let { ids } = data.data;
							this.changeState = ids;
							// 切换前暂时隐藏小人 换完成后再显示 要是换性别换了男女可能会有瞬间的穿模现象
							let arr = ids.split("_");
							let info = {
								upper: arr[0],
								lower: arr[1],
								onePiece: arr[2],
								shoes: arr[3],
								head: arr[4],
								move: arr[5],
								bg: arr[6],
							};
							//@ts-ignore
							console.log(`切换前：\ntexture--${Layers_1.layers.stage.renderer.info.memory.textures}`);
							//@ts-ignore
							console.log(`geometries--${Layers_1.layers.stage.renderer.info.memory.geometries}`);
							if (Main_1.__compileEnv__ == "miniCard") {
								if (info.onePiece !== "0") {
									// 有连体衣取连体衣的id上的性别
									yield this.checkBody(info.onePiece);
									this._currInfo.onePiece = info.onePiece;
									yield this.checkModelMap(AthletarConfig_1.ModelType.ONEPIECE, info.onePiece);
								}
								else {
									yield this.checkBody(info.upper);
									if (info.upper != "0") {
										this._currInfo.upper = info.upper;
										yield this.checkModelMap(AthletarConfig_1.ModelType.UPPER, info.upper);
									}
									if (info.lower != "0") {
										this._currInfo.lower = info.lower;
										yield this.checkModelMap(AthletarConfig_1.ModelType.LOWER, info.lower);
									}
								}
								if (info.head != "0") {
									this._currInfo.head = info.head;
									yield this.checkModelMap(AthletarConfig_1.ModelType.HEAD, info.head);
								}
								if (info.shoes != "0") {
									this._currInfo.shoes = info.shoes;
									yield this.checkModelMap(AthletarConfig_1.ModelType.SHOES, info.shoes);
								}
							}
							else {
								let promiseArr = [];
								if (info.onePiece !== "0") {
									// 有连体衣取连体衣的id上的性别
									yield this.checkBody(info.onePiece);
									this._currInfo.onePiece = info.onePiece;
									promiseArr.push(this.checkModelMap(AthletarConfig_1.ModelType.ONEPIECE, info.onePiece));
								}
								else {
									yield this.checkBody(info.upper);
									if (info.upper != "0") {
										this._currInfo.upper = info.upper;
										promiseArr.push(this.checkModelMap(AthletarConfig_1.ModelType.UPPER, info.upper));
									}
									if (info.lower != "0") {
										this._currInfo.lower = info.lower;
										promiseArr.push(this.checkModelMap(AthletarConfig_1.ModelType.LOWER, info.lower));
									}
								}
								if (info.head != "0") {
									this._currInfo.head = info.head;
									promiseArr.push(this.checkModelMap(AthletarConfig_1.ModelType.HEAD, info.head));
								}
								if (info.shoes != "0") {
									this._currInfo.shoes = info.shoes;
									promiseArr.push(this.checkModelMap(AthletarConfig_1.ModelType.SHOES, info.shoes));
								}
								yield Promise.all(promiseArr);
							}
							// 1125 为了适配部分帽子会压住耳朵的情况将头部拆分出来单独加载
							let gender = info.upper.split("")[2];
							if (gender == "1") {
								//暂时只有男性需要额外加载头部
								let boyHeadGltf = yield this.checkModelMap(AthletarConfig_1.ModelType.HEADEXT, "boyHead");
								let { hideHead } = AthletarConfig_1.ModelList[info.head];
								if (hideHead) {
									boyHeadGltf.scene.visible = false;
								}
								else {
									boyHeadGltf.scene.visible = true;
								}
							}
							else {
								// 女生就把男头隐藏
								let boyHeadGltf = GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.HEADEXT]["boyHead"];
								if (boyHeadGltf) {
									boyHeadGltf.scene.visible = false;
								}
							}
							let basketballGltf = yield this.checkModelMap(AthletarConfig_1.ModelType.BASKETBALL, "basketball");
							let action = this.actionsList[info.move];
							if (action !== AthletarConfig_1.ActionType.BASKETBALL || action !== this.currAction) {
								basketballGltf.scene.scale.set(0, 0, 0);
							}
							if (info.move != "0") {
								let action = this.actionsList[info.move];
								if (!this.isPlayAction || isIdle) {
									yield this.changeAction(AthletarConfig_1.ActionType.IDLE);
								}
								else {
									yield this.changeAction(action);
								}
								this._currInfo.move = info.move;
							}
							this.athletarBox.visible = false;
							this.addAllParts();
							this.athletarBox.visible = true;
							let endCheck = Date.now();
							let useTime = endCheck - startCheck;
							console.log("本次切换耗时：", useTime, "ms");
							setTimeout(() => {
								//@ts-ignore
								console.log(`切换后：\ntextures--${Layers_1.layers.stage.renderer.info.memory.textures}`);
								//@ts-ignore
								console.log(`geometries--${Layers_1.layers.stage.renderer.info.memory.geometries}`);
							}, 50);
						});
					}
					playAnimations(mixer, animations, id) {
						if (!animations || animations.length < 1) {
							return { clipAction: undefined };
						}
						let idleAction = mixer.clipAction(animations[0]);
						let walkAction = mixer.clipAction(animations[1]);
						let runAction = mixer.clipAction(animations[2]);
						let basketballAction = mixer.clipAction(animations[3]);
						let hiphopAction = mixer.clipAction(animations[4]);
						let actions = [idleAction, walkAction, runAction, basketballAction, hiphopAction];
						actions.forEach((action) => {
							action && action.play();
						});
						// 之前如果对应id有就覆盖之前的，如果没有就赋值
						this.actionPool.set(id, actions);
						return actions;
					}
					addAllParts() {
						// 清空小人存放对象组
						this.athletarBox.clear();
						this.mixerPool["body"] = this.tempBodyMixer;
						// 将加载的模型动画全都切换成常驻模型的动画时间开始播放
						// 新创建的动画都需要同步一下
						// 切换成当前动作
						this._tempGltfMap.forEach((gltf, type) => {
							let { scene, animations, id } = gltf;
							let mixer = new AnimationMixer_1.AnimationMixer(scene);
							// 播放当前需要显示的所有动作
							this.playAnimations(mixer, animations, id);
							// 更新动作
							this.updateAction();
							// 以身体动作时间为基准同步
							mixer.setTime(this.currBodyTime);
							this.mixerPool[id] = mixer;
							this._currGltfMap.set(type, gltf);
						});
						this._tempGltfMap.clear();
						// console.log(this.mixerPool);
						// 同步所有模型的动作
						Object.keys(this.mixerPool).forEach((mixer) => {
							var _a;
							(_a = this.mixerPool[mixer]) === null || _a === void 0 ? void 0 : _a.update(1 / 1000);
						});
						// 添加进小人存放对象组
						// 加到场景里，进到渲染以后会初始化texture
						this._currGltfMap.forEach((val) => {
							this.athletarBox.add(val.scene);
						});
					}
					checkModelMap(type, id) {
						return __awaiter(this, void 0, void 0, function* () {
							let currGltf = GltfPool_1.GltfPool.ins[type][id];
							if (!currGltf) {
								// 超出限制
								this.gltfTest(10);
								// 从配置里读取模型配置信息
								let info = AthletarConfig_1.ModelList[id];
								let url = Main_1.__compileEnv__ == "miniCard" ? info.miniUrl : info.url;
								if (url == "") {
									return;
								}
								currGltf = (yield Tools_1.Tools.loadGltf(AthletarConfig_1.ModelPath, url));
								currGltf.id = id;
							}
							else {
								// if (currGltf.parseFlag !== this.parseFlag) {
								// 如果切换回当前页面以后没有parse过，就重新parse一遍防止纹理错乱
								console.log("reparse:", id);
								// 销毁原先场景
								Tools_1.Tools.disposeObj(currGltf.scene);
								// 重新parse一遍gltf
								// currGltf = (await this.reparse(currGltf.parser)) as any;
								currGltf.scene.traverse((child) => {
									if (child.material) {
										let lastMat = child.material;
										if (child.material.type == "MeshStandardMaterial") {
											child.material = new MeshStandardMaterial_1.MeshStandardMaterial().copy(child.material);
										}
										else {
											child.material = new MeshBasicMaterial_1.MeshBasicMaterial().copy(child.material);
										}
										lastMat.dispose();
									}
								});
								// let info = ModelList[id];
								// let url = __compileEnv__ == "miniCard" ? info.miniUrl : info.url;
								// currGltf = (await Tools.loadGltf(ModelPath, url)) as any;
								// console.log(currGltf.parser.json.materials.length, currGltf.parser.json.textures.length);
								currGltf.id = id;
								// layers.stage.renderer.dispose();
								// layers.stage.renderer.forceContextLoss();
								// }
							}
							// currGltf.scene.traverse((child) => {
							// 	if (child.material?.map) {
							// 		console.log(child.material?.map);
							// 		child.material.map.needsUpdate = false;
							// 	}
							// });
							// 加载完统一显示 临时存放
							this._tempGltfMap.set(type, currGltf);
							// 赋值重新解析标记 一致则不再解析
							currGltf.parseFlag = this.parseFlag;
							GltfPool_1.GltfPool.ins[type][id] = currGltf;
							currGltf.modelId = id;
							return currGltf;
						});
					}
					checkBody(id) {
						return __awaiter(this, void 0, void 0, function* () {
							// 切换性别
							if (id == "0") {
								return;
							}
							let gender = id.split("")[2];
							let changeFlag = false;
							if (this.currGender !== gender) {
								changeFlag = true;
							}
							if (gender == "0") {
								// 女
								if (this.currGender !== "0") {
									// 女body没有加载过
									if (!GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["girlBody"]) {
										let url = Main_1.__compileEnv__ == "miniCard" ? AthletarConfig_1.ModelList["girlBody"].miniUrl : AthletarConfig_1.ModelList["girlBody"].url;
										this.body = yield Tools_1.Tools.loadGltf(AthletarConfig_1.ModelPath, url);
									}
									else {
										if (!this.body || this.body.parseFlag !== this.parseFlag) {
											this.body = yield this.reparse(GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["girlBody"].parser);
											this.body.parseFlag = this.parseFlag;
										}
										else {
											this.body = GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["girlBody"];
											this.body.scene.traverse((child) => {
												if (child.material) {
													let lastMat = child.material;
													child.material = new MeshBasicMaterial_1.MeshBasicMaterial().copy(child.material);
													lastMat.dispose();
												}
											});
										}
									}
								}
								else {
									this.body = GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["girlBody"];
									this.body.scene.traverse((child) => {
										if (child.material) {
											let lastMat = child.material;
											child.material = new MeshBasicMaterial_1.MeshBasicMaterial().copy(child.material);
											lastMat.dispose();
										}
									});
								}
								GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["girlBody"] = this.body;
								this.currGender = "0";
							}
							else {
								// 男
								if (this.currGender !== "1") {
									if (!GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["boyBody"]) {
										let url = Main_1.__compileEnv__ == "miniCard" ? AthletarConfig_1.ModelList["boyBody"].miniUrl : AthletarConfig_1.ModelList["boyBody"].url;
										this.body = yield Tools_1.Tools.loadGltf(AthletarConfig_1.ModelPath, url);
									}
									else {
										if (!this.body || this.body.parseFlag !== this.parseFlag) {
											this.body = yield this.reparse(GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["boyBody"].parser);
										}
										else {
											this.body = GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["boyBody"];
											this.body.scene.traverse((child) => {
												if (child.material) {
													let lastMat = child.material;
													child.material = new MeshBasicMaterial_1.MeshBasicMaterial().copy(child.material);
													lastMat.dispose();
												}
											});
										}
									}
								}
								else {
									this.body = GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["boyBody"];
									this.body.scene.traverse((child) => {
										if (child.material) {
											let lastMat = child.material;
											child.material = new MeshBasicMaterial_1.MeshBasicMaterial().copy(child.material);
											lastMat.dispose();
										}
									});
								}
								GltfPool_1.GltfPool.ins[AthletarConfig_1.ModelType.COMMON]["boyBody"] = this.body;
								this.currGender = "1";
							}
							let bodyTime = this.currBodyTime;
							// 首次和更换性别才需要重新设置动画
							if (!this._currGltfMap.get(AthletarConfig_1.ModelType.COMMON) || changeFlag) {
								let { scene: bodyModel, animations: bodyAnimations } = this.body;
								let bodyMixer = new AnimationMixer_1.AnimationMixer(bodyModel);
								this.playAnimations(bodyMixer, bodyAnimations, "body");
								this.updateAction();
								bodyMixer.setTime(bodyTime);
								this.tempBodyMixer = bodyMixer;
								// 暂存身体模型，在后面统一添加
								this._currGltfMap.set(AthletarConfig_1.ModelType.COMMON, this.body);
							}
							this.body.modelId = "body";
						});
					}
					gltfTest(limitNum) {
						// TODO 模型超了删除多余的
						// if (modelList.length >= 10) {
						// 	//先删除 释放内存
						// 	let deleteModel = modelList[0];
						// 	deleteModel.scene.visible = false;
						// 	deleteModel.scene.removeFromParent();
						// 	Tools.disposeObj(deleteModel);
						// 	modelList.splice(0, 1);
						// }
					}
					disposeTextures() {
						Object.keys(GltfPool_1.GltfPool.ins).forEach((keys) => {
							Object.keys(GltfPool_1.GltfPool.ins[keys]).forEach((modelId) => {
								let gltf = GltfPool_1.GltfPool.ins[keys][modelId];
								let model = gltf.scene;
								Tools_1.Tools.disposeObj(model);
							});
						});
					}
					reparse(parser) {
						return __awaiter(this, void 0, void 0, function* () {
							return new Promise((r, j) => {
								parser.parse(r, j);
							});
						});
					}
				}
				exports.AthletarCtrl = AthletarCtrl;


				/***/
}),

/***/ "./src/common/BgConfigs.ts":
/*!*********************************!*\
  !*** ./src/common/BgConfigs.ts ***!
  \*********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.BGList = void 0;
				const Color_1 = __webpack_require__(/*! ../../libs/three/math/Color */ "./libs/three/math/Color.js");
				const Vector3_1 = __webpack_require__(/*! ../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const AthletarConfig_1 = __webpack_require__(/*! ./AthletarConfig */ "./src/common/AthletarConfig.ts");
				/**
				 * 米色背景配置
				 */
				const White = {
					// groundVisible: true,
					// groundY: 0,
					// isClearBgObjs: true,
					// isResetCamera: true,
					// backgroundColor: new Color(0xf1ebdd),
					groundVisible: false,
					isClearBgObjs: true,
					// backgroundColor: new Color(0xf1ebdd),
					models: [
						{
							id: "ydhw",
							name: "ydhw",
							url: "YDHW-pack.gltf",
							miniUrl: "YDHW-processed.gltf",
							type: AthletarConfig_1.ModelType.BACKGROUND,
							position: new Vector3_1.Vector3(0, -0.37, 0),
							scale: [1.3, 1.3, 1.3],
							receiveShadow: true,
						},
					],
				};
				/**
				 * 方凹背景配置
				 */
				const FangAo = {
					groundVisible: false,
					isClearBgObjs: true,
					backgroundColor: new Color_1.Color(0xf1ebdd),
					models: [
						{
							id: "fangao",
							name: "fangao",
							url: "fangao.gltf",
							miniUrl: "fangao.gltf",
							type: AthletarConfig_1.ModelType.BACKGROUND,
							position: new Vector3_1.Vector3(0, -0.37, 0),
							scale: [1.3, 1.3, 1.3],
							receiveShadow: true,
						},
						{
							id: "fangground",
							name: "fangground",
							url: "ground2.gltf",
							miniUrl: "ground2.gltf",
							type: AthletarConfig_1.ModelType.BACKGROUND,
							position: new Vector3_1.Vector3(0, -0.36, 0),
							scale: [1.45, 1.45, 1.45],
							side: 2,
							blending: 4,
						},
					],
				};
				/**
				 * XX背景配置
				 */
				const YDHW = {
					groundVisible: false,
					isClearBgObjs: true,
					backgroundColor: new Color_1.Color(0xf1ebdd),
					models: [
						{
							id: "ydhw",
							name: "ydhw",
							url: "YDHW-pack.gltf",
							miniUrl: "YDHW-processed.gltf",
							type: AthletarConfig_1.ModelType.BACKGROUND,
							position: new Vector3_1.Vector3(0, -0.37, 0),
							scale: [1.3, 1.3, 1.3],
							receiveShadow: true,
						},
					],
				};
				//TODO 背景列表配置
				exports.BGList = {
					"0": White,
					"070000001": White,
					"070000002": YDHW,
				};


				/***/
}),

/***/ "./src/common/BgCtrl.ts":
/*!******************************!*\
  !*** ./src/common/BgCtrl.ts ***!
  \******************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.BgCtrl = void 0;
				const Main_1 = __webpack_require__(/*! ./../Main */ "./src/Main.ts");
				const PlaneGeometry_1 = __webpack_require__(/*! ../../libs/three/geometries/PlaneGeometry */ "./libs/three/geometries/PlaneGeometry.js");
				const Vector3_1 = __webpack_require__(/*! ../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const Tools_1 = __webpack_require__(/*! ../Tools */ "./src/Tools.ts");
				const GltfPool_1 = __webpack_require__(/*! ./GltfPool */ "./src/common/GltfPool.ts");
				const AthletarConfig_1 = __webpack_require__(/*! ./AthletarConfig */ "./src/common/AthletarConfig.ts");
				const Mesh_1 = __webpack_require__(/*! ../../libs/three/objects/Mesh */ "./libs/three/objects/Mesh.js");
				const Layers_1 = __webpack_require__(/*! ../../modules/views/Layers */ "./modules/views/Layers.ts");
				const BgConfigs_1 = __webpack_require__(/*! ./BgConfigs */ "./src/common/BgConfigs.ts");
				const ShaderMaterial_1 = __webpack_require__(/*! ../../libs/three/materials/ShaderMaterial */ "./libs/three/materials/ShaderMaterial.js");
				const HorizontalBlurShader_1 = __webpack_require__(/*! ../../src/shaders/HorizontalBlurShader */ "./src/shaders/HorizontalBlurShader.js");
				const VerticalBlurShader_1 = __webpack_require__(/*! ../../src/shaders/VerticalBlurShader */ "./src/shaders/VerticalBlurShader.js");
				const MeshDepthMaterial_1 = __webpack_require__(/*! ../../libs/three/materials/MeshDepthMaterial */ "./libs/three/materials/MeshDepthMaterial.js");
				const OrthographicCamera_1 = __webpack_require__(/*! ../../libs/three/cameras/OrthographicCamera */ "./libs/three/cameras/OrthographicCamera.js");
				const WebGLRenderTarget_1 = __webpack_require__(/*! ../../libs/three/renderers/WebGLRenderTarget */ "./libs/three/renderers/WebGLRenderTarget.js");
				const MeshBasicMaterial_1 = __webpack_require__(/*! ../../libs/three/materials/MeshBasicMaterial */ "./libs/three/materials/MeshBasicMaterial.js");
				const Group_1 = __webpack_require__(/*! ../../libs/three/objects/Group */ "./libs/three/objects/Group.js");
				// 背景控制器
				// 背景有很多参数并且可能有多个模型，所以从AthletarCtrl拆出来更好控制
				class BgCtrl {
					constructor(scene, camera, controler) {
						this.bgPool = {};
						this.defaultCamera = {
							position: new Vector3_1.Vector3(),
							lookAt: new Vector3_1.Vector3(),
						};
						this.groundWidth = 2.5;
						this.groundHeight = 2.5;
						this.cameraHeight = 4;
						this.scene = scene;
						this.camera = camera;
						this.defaultCamera.position = new Vector3_1.Vector3().copy(camera.position);
						this.defaultCamera.lookAt = new Vector3_1.Vector3().copy(camera.lookAt);
						this.controler = controler;
						this.ground = new Group_1.Group();
						this.ground.name = "Ground";
						this.scene.add(this.ground);
						// like MeshDepthMaterial, but goes from black to transparent
						let depthMaterial = (this.depthMaterial = new MeshDepthMaterial_1.MeshDepthMaterial());
						depthMaterial.userData.darkness = { value: 0.9 };
						// @ts-ignore
						depthMaterial.onBeforeCompile = function (shader) {
							shader.uniforms.darkness = depthMaterial.userData.darkness;
							shader.fragmentShader = `
              uniform float darkness;
              ${shader.fragmentShader.replace("gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );", "gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );")}
          `;
						};
						depthMaterial.depthTest = false;
						depthMaterial.depthWrite = false;
						let horizontalBlurMaterial = (this.horizontalBlurMaterial = new ShaderMaterial_1.ShaderMaterial(HorizontalBlurShader_1.HorizontalBlurShader));
						horizontalBlurMaterial.depthTest = false;
						let verticalBlurMaterial = (this.verticalBlurMaterial = new ShaderMaterial_1.ShaderMaterial(VerticalBlurShader_1.VerticalBlurShader));
						verticalBlurMaterial.depthTest = false;
					}
					// 初始化地面
					initGround() {
						let defaultGround = (this.defaultGround = new Group_1.Group());
						defaultGround.name = "DefaultGround";
						this.ground.add(defaultGround);
						// 该渲染对象将要在plane纹理上显示阴影
						let renderTarget = (this.renderTarget = new WebGLRenderTarget_1.WebGLRenderTarget(256, 256));
						renderTarget.texture.needsUpdate = true;
						renderTarget.texture.generateMipmaps = false;
						// 该渲染对象将模糊纹理的阴影
						let renderTargetBlur = (this.renderTargetBlur = new WebGLRenderTarget_1.WebGLRenderTarget(256, 256));
						renderTargetBlur.texture.generateMipmaps = false;
						// 面朝上
						const planeGeometry = new PlaneGeometry_1.PlaneBufferGeometry(this.groundWidth, this.groundHeight).rotateX(Math.PI / 2);
						const planeMaterial = new MeshBasicMaterial_1.MeshBasicMaterial({
							map: renderTarget.texture,
							opacity: 1,
							transparent: true,
							depthWrite: false,
						});
						let plane = (this.renderPlane = new Mesh_1.Mesh(planeGeometry, planeMaterial));
						// make sure it's rendered after the fillPlane
						plane.renderOrder = 1;
						plane.setPosition(0, 0, 0);
						//@ts-ignore
						plane.scale.y = -1;
						defaultGround.add(plane);
						// the plane onto which to blur the texture
						let blurPlane = new Mesh_1.Mesh(planeGeometry);
						blurPlane.visible = false;
						this.blurPlane = blurPlane;
						defaultGround.add(blurPlane);
						// the camera to render the depth material from
						let shadowCamera = (this.shadowCamera = new OrthographicCamera_1.OrthographicCamera(-this.groundWidth / 2, this.groundWidth / 2, this.groundHeight / 2, -this.groundHeight / 2, 0, this.cameraHeight));
						//@ts-ignore
						shadowCamera.rotation.x = Math.PI / 2; // get the camera to look up
						shadowCamera.layers.enable(88);
						defaultGround.add(shadowCamera);
						shadowCamera.setPosition(0, -0.5, 0);
					}
					// 用于处理从衣橱页面返回以后影子消失问题
					reloadGround() {
						var _a, _b, _c, _d, _e, _f, _g, _h, _j;
						// 先移除原先的地面
						(_a = this.defaultGround) === null || _a === void 0 ? void 0 : _a.removeFromParent();
						let defaultGround = (this.defaultGround = new Group_1.Group());
						defaultGround.name = "DefaultGround";
						this.ground.add(defaultGround);
						// 该渲染对象将要在plane纹理上显示阴影
						// console.log("======renderTarget======", this.renderTarget);
						(_c = (_b = this.renderTarget) === null || _b === void 0 ? void 0 : _b.texture) === null || _c === void 0 ? void 0 : _c.dispose();
						(_d = this.renderTarget) === null || _d === void 0 ? void 0 : _d.dispose();
						let renderTarget = (this.renderTarget = new WebGLRenderTarget_1.WebGLRenderTarget(256, 256));
						renderTarget.texture.generateMipmaps = false;
						// 该渲染对象将模糊纹理的阴影
						(_f = (_e = this.renderTargetBlur) === null || _e === void 0 ? void 0 : _e.texture) === null || _f === void 0 ? void 0 : _f.dispose();
						(_g = this.renderTargetBlur) === null || _g === void 0 ? void 0 : _g.dispose();
						let renderTargetBlur = (this.renderTargetBlur = new WebGLRenderTarget_1.WebGLRenderTarget(256, 256));
						renderTargetBlur.texture.generateMipmaps = false;
						// 面朝上
						(_j = (_h = this.renderPlane) === null || _h === void 0 ? void 0 : _h.geometry) === null || _j === void 0 ? void 0 : _j.dispose();
						const planeGeometry = new PlaneGeometry_1.PlaneBufferGeometry(this.groundWidth, this.groundHeight).rotateX(Math.PI / 2);
						const planeMaterial = new MeshBasicMaterial_1.MeshBasicMaterial({
							map: renderTarget.texture,
							opacity: 0.5,
							transparent: true,
							depthWrite: false,
						});
						let plane = (this.renderPlane = new Mesh_1.Mesh(planeGeometry, planeMaterial));
						// make sure it's rendered after the fillPlane
						plane.renderOrder = 1;
						plane.setPosition(0, 0, 0);
						//@ts-ignore
						plane.scale.y = -1;
						defaultGround.add(plane);
						// the plane onto which to blur the texture
						let blurPlane = new Mesh_1.Mesh(planeGeometry);
						blurPlane.visible = false;
						this.blurPlane = blurPlane;
						defaultGround.add(blurPlane);
					}
					// 切换
					change(data) {
						return __awaiter(this, void 0, void 0, function* () {
							let { ids, success, fail } = data.data;
							try {
								let bgId = ids.split("_")[6];
								if (!data || this.currBgId == bgId) {
									success && success();
									return;
								}
								let config = BgConfigs_1.BGList[bgId];
								if (!config) {
									config = BgConfigs_1.BGList["0"];
								}
								this.currConfig = config;
								let { groundVisible, groundY, isClearBgObjs, isResetCamera, backgroundColor, models } = config;
								if (this.ground) {
									this.defaultGround.visible = groundVisible || false;
									// 不用切换背景暂时就不要新建地面的纹理了
									// if (groundVisible) {
									// 	this.renderTarget?.dispose();
									// 	let renderTarget = (this.renderTarget = new WebGLRenderTarget(256, 256));
									// 	renderTarget.texture.generateMipmaps = false;
									// 	this.renderPlane.material.map = renderTarget.texture;
									// }
									if (groundY !== undefined || groundY === 0) {
										this.ground.position.setY(groundY);
									}
								}
								if (isClearBgObjs) {
									//是否清除背景
									this.clearBgObjs();
								}
								if (isResetCamera) {
									// 是否重置相机
									console.log(this.defaultCamera);
									this.camera.position.set(this.defaultCamera.position);
									this.camera.lookAt = this.defaultCamera.lookAt;
								}
								if (backgroundColor) {
									// 设置场景背景颜色
									Layers_1.layers.mainLayer.background = backgroundColor;
								}
								// 模型设置
								if (models && models.length > 0) {
									models.forEach((modelConfig) => __awaiter(this, void 0, void 0, function* () {
										let { name, url, miniUrl, position, scale, side, receiveShadow, convertMaterial, emissive, blending, } = modelConfig;
										if (this.bgPool[name]) {
											this.bgPool[name].visible = true;
										}
										else {
											// TODO 加载模型的loading
											let _url = Main_1.__compileEnv__ == "miniCard" ? miniUrl : url;
											let gltf = yield Tools_1.Tools.loadGltf(AthletarConfig_1.ModelPath, _url);
											let model = gltf.scene;
											GltfPool_1.GltfPool.ins[name] = model;
											this.bgPool[name] = model;
											// TODO children 看有几层
											// console.log(name,position);
											// model
											// !model.material&& (model.material = new MeshBasicMaterial())
											convertMaterial && (model.material = Tools_1.Tools.convertMaterial(convertMaterial, model.material));
											// emissive && (model.material.emissive = emissive)
											receiveShadow && Tools_1.Tools.receiveShadow(model);
											position && model.position.copy(position);
											scale && model.scale.set(...scale);
											side && model.material && (model.material.side = side);
											blending && (model.children[0].children[0].material.blending = 4);
											this.ground.add(model);
										}
									}));
								}
								// success && success();
							}
							catch (err) {
								// fail && fail(err);
							}
						});
					}
					update() {
						if (!this.shadowCamera)
							return;
						let { renderer } = Layers_1.layers.stage;
						// remove the background
						const initialBackground = this.scene.background;
						this.scene.background = null;
						this.scene.overrideMaterial = this.depthMaterial;
						// set renderer clear alpha
						const initialClearAlpha = renderer.getClearAlpha();
						renderer.setClearAlpha(0);
						// render to the render target to get the depths
						renderer.setRenderTarget(this.renderTarget);
						//@ts-ignore
						renderer.clear();
						renderer.render(this.scene, this.shadowCamera);
						// and reset the override material
						this.scene.overrideMaterial = null;
						this.blurShadow(4.1);
						// a second pass to reduce the artifacts
						// (0.4 is the minimum blur amout so that the artifacts are gone)
						this.blurShadow(4.1 * 0.4);
						// reset and render the normal scene
						renderer.setRenderTarget(null);
						// renderer.render(this.scene, this.shadowCamera);
						renderer.setClearAlpha(initialClearAlpha);
						this.scene.background = initialBackground;
					}
					// renderTarget --> blurPlane (horizontalBlur) --> renderTargetBlur --> blurPlane (verticalBlur) --> renderTarget
					blurShadow(amount) {
						if (!this.blurPlane)
							return;
						this.blurPlane.visible = true;
						// blur horizontally and draw in the renderTargetBlur
						this.blurPlane.material = this.horizontalBlurMaterial;
						this.blurPlane.material.uniforms.tDiffuse.value = this.renderTarget.texture;
						this.horizontalBlurMaterial.uniforms.h.value = (amount * 1) / 256;
						Layers_1.layers.stage.renderer.setRenderTarget(this.renderTargetBlur);
						Layers_1.layers.stage.renderer.render(this.blurPlane, this.shadowCamera);
						// blur vertically and draw in the main renderTarget
						this.blurPlane.material = this.verticalBlurMaterial;
						this.blurPlane.material.uniforms.tDiffuse.value = this.renderTargetBlur.texture;
						this.verticalBlurMaterial.uniforms.v.value = (amount * 1) / 256;
						Layers_1.layers.stage.renderer.setRenderTarget(this.renderTarget);
						Layers_1.layers.stage.renderer.render(this.blurPlane, this.shadowCamera);
						this.blurPlane.visible = false;
					}
					// 暂时隐藏所有背景模型
					clearBgObjs() {
						Object.keys(this.bgPool).forEach((key) => {
							this.bgPool[key].visible = false;
							// this.bgPool[key].removeFromParent();
						});
					}
				}
				exports.BgCtrl = BgCtrl;


				/***/
}),

/***/ "./src/common/GltfPool.ts":
/*!********************************!*\
  !*** ./src/common/GltfPool.ts ***!
  \********************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				Object.defineProperty(exports, "__esModule", { value: true });
				exports.GltfPool = void 0;
				const Tools_1 = __webpack_require__(/*! ../../src/Tools */ "./src/Tools.ts");
				/**
				 * 用来储存所有模型
				 * 存放在全局变量里  其他页面能取到就复用
				 */
				class GltfPool {
					static create() {
						// @ts-ignore
						let global = window || $global || my;
						let target;
						// 默认为淘宝环境 小程序缓存只有5m限制所以不用缓存
						//@ts-ignore
						if (!global.AthletarGltfCache) {
							//@ts-ignore
							global.AthletarGltfCache = {
								common: {},
								upper: {},
								lower: {},
								onePiece: {},
								shoes: {},
								head: {},
								headExt: {},
								background: {},
								basketball: {},
							};
						}
						//@ts-ignore
						target = global.AthletarGltfCache;
						return target;
					}
					//  保持name唯一
					static getGltf(type, name) {
						if (GltfPool.ins[type][name]) {
							return GltfPool.ins[type][name];
						}
						return null;
					}
					static delGltf(type, name) {
						if (GltfPool.ins[type][name]) {
							let target = GltfPool.ins[type][name];
							target.scene.removeFromParent();
							Tools_1.Tools.disposeObj(target.scene);
							target = null;
							GltfPool.ins[type][name] = null;
						}
					}
					static getModel(type, name) {
						var _a;
						if ((_a = GltfPool.ins[type][name]) === null || _a === void 0 ? void 0 : _a.scene) {
							return GltfPool.ins[type][name].scene;
						}
						return null;
					}
					static clear() {
						if (Object.keys(GltfPool.ins).length <= 0) {
							return;
						}
						for (let i = 0; i < Object.keys(GltfPool.ins).length; i++) {
							let type = Object.keys(GltfPool.ins)[i];
							for (let j = 0; j < Object.keys(GltfPool.ins[type]).length; j++) {
								let name = Object.keys(GltfPool.ins[type])[j];
								GltfPool.delGltf(type, name);
							}
						}
					}
				}
				exports.GltfPool = GltfPool;
				GltfPool.ins = GltfPool.create();


				/***/
}),

/***/ "./src/scenes/BigCardScene/BigCardScene.ts":
/*!*************************************************!*\
  !*** ./src/scenes/BigCardScene/BigCardScene.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.BigCardScene = void 0;
				const BgCtrl_1 = __webpack_require__(/*! ../../common/BgCtrl */ "./src/common/BgCtrl.ts");
				const Main_1 = __webpack_require__(/*! ../../Main */ "./src/Main.ts");
				const AthletarCtrl_1 = __webpack_require__(/*! ../../common/AthletarCtrl */ "./src/common/AthletarCtrl.ts");
				const AmbientLight_1 = __webpack_require__(/*! ../../../libs/three/lights/AmbientLight */ "./libs/three/lights/AmbientLight.js");
				const DirectionalLight_1 = __webpack_require__(/*! ../../../libs/three/lights/DirectionalLight */ "./libs/three/lights/DirectionalLight.js");
				const Vector3_1 = __webpack_require__(/*! ../../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const Layers_1 = __webpack_require__(/*! ../../../modules/views/Layers */ "./modules/views/Layers.ts");
				const Scene_1 = __webpack_require__(/*! ../../../modules/views/Scene */ "./modules/views/Scene.ts");
				const OrbitControls_1 = __webpack_require__(/*! ../../../libs/three/controls/OrbitControls */ "./libs/three/controls/OrbitControls.js");
				const EventDispatcher_1 = __webpack_require__(/*! ../../../libs/three/core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
				const Tools_1 = __webpack_require__(/*! ../../Tools */ "./src/Tools.ts");
				const tween_1 = __webpack_require__(/*! ../../../libs/tween */ "./libs/tween/index.ts");
				class BigCardScene extends Scene_1.Scene {
					constructor() {
						super();
						this.name = "BigCardScene";
					}
					start(data) {
						const _super = Object.create(null, {
							start: { get: () => super.start }
						});
						return __awaiter(this, void 0, void 0, function* () {
							_super.start.call(this);
							// 暂时隐藏  加载完成后一起出现
							this.visible = false;
							// 初始化灯光
							this.initLights();
							// 初始化相机  每个layer都有自己的相机 这里是初始化这个scene里camera的坐标车朝向
							this.initCamera();
							// 这个是业务维度的  分为化身控制器（AthletarCtrl）和背景控制器（BgCtrl） 并优先加载身体部分
							yield this.initControls();
							// 这个是控制维度的  OrbitControl  用来旋转缩放场景模型
							// this.initControler();
							// layers.mainLayer.background = new Color(0xf1ebdd);
							// 初始化完成显示
							this.visible = true;
						});
					}
					initLights() {
						// 环境光
						let al = new AmbientLight_1.AmbientLight();
						this.add(al);
						// 直射光
						let dl = new DirectionalLight_1.DirectionalLight();
						dl.setPosition(0, 1.7, 0.5);
						dl.castShadow = false;
						this.add(dl);
					}
					initCamera() {
						let camera = Layers_1.layers.mainLayerCamera;
						camera.setPosition(-0.3, 0.52, 3.1 * 4.9);
						camera.lookAt(-0.3, 0.52, 0);
					}
					initControler(center) {
						!this.controler && (this.controler = new OrbitControls_1.OrbitControls(Layers_1.layers.mainLayerCamera));
						// this.controler.setMaxVerticalRotationAngle(Math.PI / 8, Math.PI / 8);
						if (center) {
							this.controler.center.set(center.x, center.y, center.z);
						}
						else {
							this.controler.center.set(0, 0.6, 0);
						}
						this.controler.minPolarAngle = (Math.PI * 3) / 8;
						this.controler.maxPolarAngle = (Math.PI * 4) / 8;
						//@ts-ignore
						this.defaultDistance = new Vector3_1.Vector3().distanceTo(Layers_1.layers.mainLayerCamera.position);
						//@ts-ignore
						this.controler.maxDistance = this.defaultDistance * 1.2;
						//@ts-ignore
						this.controler.minDistance = this.defaultDistance;
						this.controler.update(this.defaultDistance);
					}
					initControls() {
						return __awaiter(this, void 0, void 0, function* () {
							// 仅仅初始化 外面告知换装后再换
							this.athletarCtrl = new AthletarCtrl_1.AthletarCtrl(this);
							this.athletarCtrl.athletarBox.setRotationFromAxisAngle(new Vector3_1.Vector3(0, 1, 0), Math.PI * -0.2);
							// scene.scale.set(2,2,2)
							this.bgCtrl = new BgCtrl_1.BgCtrl(this, Layers_1.layers.topLayerCamera, this.controler);
						});
					}
					initEvents() {
						this.addEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.addEventListener("onResize", this.onResize.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseDown", this.onMouseDown.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseMove", this.onMouseMove.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseUp", this.onMouseUp.bind(this));
						Main_1.GDispatcher.addEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.addEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.addEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.addEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.addEventListener("fadeIn", this.onFadeIn.bind(this));
						Main_1.GDispatcher.addEventListener("fadeOut", this.onFadeOut.bind(this));
						Main_1.GDispatcher.addEventListener("resetCamera", this.onResetCamera.bind(this));
						Main_1.GDispatcher.addEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.addEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
					}
					onTouchStart(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onTouchMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onTouchEnd(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(data);
					}
					onMouseDown(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onMouseMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onMouseUp(e) {
						var _a;
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(e);
					}
					onEnterFrame() {
						var _a, _b;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.update();
						(_b = this.bgCtrl) === null || _b === void 0 ? void 0 : _b.update();
					}
					onZoomIn(e) {
						let a = { tRadius: this.defaultDistance };
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a;
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.update(a.tRadius);
							},
						})
							.to({ tRadius: this.defaultDistance * 0.6 }, 1000)
							.wait(200)
							.call(() => {
								// let { rotateOnce } = e.data;
								// if (rotateOnce) {
								// 	let target = { rotation: Math.PI * -0.2 };
								// 	Tween.get(target, {
								// 		onChange: () => {
								// 			// @ts-ignore
								// 			this.athletarCtrl.athletarBox.rotation.y = target.rotation;
								// 		},
								// 	})
								// 		.to({ rotation: Math.PI * 2 + Math.PI * -0.2 }, 1000)
								// 		.call(() => {
								// 			// @ts-ignore
								// 			this.athletarCtrl.athletarBox.rotation.y = Math.PI * -0.2;
								// 		});
								// }
							});
					}
					onZoomOut() {
						let a = { tRadius: this.defaultDistance * 0.5 };
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a;
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.update(a.tRadius);
							},
						}).to({ tRadius: this.defaultDistance }, 1000);
						// this.controler?.zoomOut();
					}
					onFadeOut() {
						let a = { opacity: 1 };
						tween_1.Tween.get(a, {
							onChange: () => {
								Layers_1.layers.stage.canvas.style.opacity = a.opacity;
							},
						}).to({ opacity: 0 }, 1000);
					}
					onFadeIn() {
						let a = { opacity: 0 };
						tween_1.Tween.get(a, {
							onChange: () => {
								Layers_1.layers.stage.canvas.style.opacity = a.opacity;
							},
						}).to({ opacity: 1 }, 1000);
					}
					onResetCamera(data) {
						let { sceneType } = data.data;
						let camera = Layers_1.layers.mainLayerCamera;
						if (sceneType == "status") {
							camera.setPosition(-1.1 * 5.2, 1.25, 3.1 * 5.2);
							camera.lookAt(0, 1.25, 0);
							this.initControler({ x: 0, y: 1.25, z: 0 });
						}
						else if (sceneType == "avatar") {
							camera.setPosition(-1.1 * 5.5, 0.6, 3.1 * 5.5);
							camera.lookAt(0, 0.6, 0);
							this.initControler({ x: 0, y: 0.6, z: 0 });
						}
					}
					// TODO 自适应功能
					onResize(e) {
						let { w, h } = e.data;
						let camera = Layers_1.layers.mainLayerCamera;
						if (w && h) {
							camera.updateProjectionMatrix();
							Layers_1.layers.stage.renderer.setSize(w, h);
							return;
						}
						let targetWidth = window ? window.innerWidth : Layers_1.layers.stage.canvasWidth;
						let targetHeight = window ? window.innerHeight : Layers_1.layers.stage.canvasHeight;
						camera.aspect = targetWidth / targetHeight;
						camera.updateProjectionMatrix();
						Layers_1.layers.stage.renderer.setSize(targetWidth, targetHeight);
					}
					onStartAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.startAction();
					}
					onStopAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.stopAction();
					}
					onUpdateAthletar(data, errCount) {
						var _a;
						return __awaiter(this, void 0, void 0, function* () {
							// 不存在模型和背景同时切换的情况
							let { success, fail } = data.data;
							try {
								yield ((_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.checkChangePart(data));
								if (this.bgCtrl && !this.bgCtrl.shadowCamera) {
									this.bgCtrl.initGround();
								}
								// await this.bgCtrl?.change(data);
								success && success();
							}
							catch (err) {
								console.log("??????", err);
								if (!errCount) {
									errCount = 0;
								}
								errCount++;
								if (errCount > 3) {
									fail && fail(err);
								}
								else {
									console.log("重试次数：", errCount, "次");
									yield this.onUpdateAthletar(data, errCount);
								}
							}
						});
					}
					onDisposeTextures() {
						this.athletarCtrl.disposeTextures();
					}
					removeEvents() {
						this.removeEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.removeEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.removeEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.removeEventListener("fadeIn", this.onFadeIn.bind(this));
						Main_1.GDispatcher.removeEventListener("fadeOut", this.onFadeOut.bind(this));
						Main_1.GDispatcher.removeEventListener("resetCamera", this.onResetCamera.bind(this));
						Main_1.GDispatcher.removeEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.removeEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
					}
					destory() {
						// @ts-ignore
						this.athletarCtrl = null;
						// @ts-ignore
						this.bgCtrl = null;
						super.destory();
					}
				}
				exports.BigCardScene = BigCardScene;


				/***/
}),

/***/ "./src/scenes/ChangeGenderScene/ChangeGenderScene.ts":
/*!***********************************************************!*\
  !*** ./src/scenes/ChangeGenderScene/ChangeGenderScene.ts ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.ChangeGenderScene = void 0;
				const BgCtrl_1 = __webpack_require__(/*! ./../../common/BgCtrl */ "./src/common/BgCtrl.ts");
				const Main_1 = __webpack_require__(/*! ./../../Main */ "./src/Main.ts");
				const AthletarCtrl_1 = __webpack_require__(/*! ./../../common/AthletarCtrl */ "./src/common/AthletarCtrl.ts");
				const AmbientLight_1 = __webpack_require__(/*! ../../../libs/three/lights/AmbientLight */ "./libs/three/lights/AmbientLight.js");
				const DirectionalLight_1 = __webpack_require__(/*! ../../../libs/three/lights/DirectionalLight */ "./libs/three/lights/DirectionalLight.js");
				const Vector3_1 = __webpack_require__(/*! ../../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const Layers_1 = __webpack_require__(/*! ../../../modules/views/Layers */ "./modules/views/Layers.ts");
				const Scene_1 = __webpack_require__(/*! ../../../modules/views/Scene */ "./modules/views/Scene.ts");
				const OrbitControls_1 = __webpack_require__(/*! ../../../libs/three/controls/OrbitControls */ "./libs/three/controls/OrbitControls.js");
				const EventDispatcher_1 = __webpack_require__(/*! ../../../libs/three/core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
				const Tools_1 = __webpack_require__(/*! ../../Tools */ "./src/Tools.ts");
				const tween_1 = __webpack_require__(/*! ../../../libs/tween */ "./libs/tween/index.ts");
				const Color_1 = __webpack_require__(/*! ../../../libs/three/math/Color */ "./libs/three/math/Color.js");
				class ChangeGenderScene extends Scene_1.Scene {
					constructor() {
						super();
						this.name = "MainScene";
						this.initConfig = { rotation: Math.PI * 0.2, tY: 0.9, tRadius: 10, aniFlag: true };
					}
					start(data) {
						const _super = Object.create(null, {
							start: { get: () => super.start }
						});
						return __awaiter(this, void 0, void 0, function* () {
							_super.start.call(this);
							// 暂时隐藏  加载完成后一起出现
							this.visible = false;
							// 初始化灯光
							this.initLights();
							// 初始化相机  每个layer都有自己的相机 这里是初始化这个scene里camera的坐标车朝向
							this.initCamera();
							// 这个是业务维度的  分为化身控制器（AthletarCtrl）和背景控制器（BgCtrl） 并优先加载身体部分
							yield this.initControls();
							// 这个是控制维度的  OrbitControl  用来旋转缩放场景模型
							this.initControler();
							Layers_1.layers.mainLayer.background = new Color_1.Color(0xf1ebdd);
							this.visible = true;
						});
					}
					initLights() {
						// 环境光
						let al = new AmbientLight_1.AmbientLight();
						this.add(al);
						// 直射光
						let dl = new DirectionalLight_1.DirectionalLight();
						dl.setPosition(0, 1.7, 0.5);
						dl.castShadow = false;
						this.add(dl);
					}
					initCamera() {
						let camera = Layers_1.layers.mainLayerCamera;
						camera.setPosition(-1.1 * 5.9, 1.8, 3.1 * 5.9);
						camera.lookAt(0, 0.8, 0);
					}
					initControler() {
						this.controler = new OrbitControls_1.OrbitControls(Layers_1.layers.mainLayerCamera);
						this.controler.center.set(0, 1.41, 0);
						this.controler.minPolarAngle = Math.PI / 2;
						this.controler.maxPolarAngle = Math.PI / 2;
						//@ts-ignore
						this.defaultDistance = new Vector3_1.Vector3().distanceTo(Layers_1.layers.mainLayerCamera.position);
						this.initConfig.tRadius = this.defaultDistance * 0.6;
						this.controler.maxDistance = this.defaultDistance * 1.2;
						this.controler.minDistance = this.defaultDistance;
						// this.controler.update();
					}
					initControls() {
						return __awaiter(this, void 0, void 0, function* () {
							// 仅仅初始化 外面告知换装后再换
							this.athletarCtrl = new AthletarCtrl_1.AthletarCtrl(this);
							// 初始化的时候都初始角度
							this.athletarCtrl.athletarBox.setRotationFromAxisAngle(new Vector3_1.Vector3(0, 1, 0), this.initConfig.rotation);
							// scene.scale.set(2,2,2)
							this.bgCtrl = new BgCtrl_1.BgCtrl(this, Layers_1.layers.topLayerCamera, this.controler);
						});
					}
					initEvents() {
						this.addEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.addEventListener("onResize", this.onResize.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseDown", this.onMouseDown.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseMove", this.onMouseMove.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseUp", this.onMouseUp.bind(this));
						Main_1.GDispatcher.addEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.addEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.addEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.addEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.addEventListener("fadeIn", this.onFadeIn.bind(this));
						Main_1.GDispatcher.addEventListener("fadeOut", this.onFadeOut.bind(this));
						Main_1.GDispatcher.addEventListener("cheerUp", this.onCheerUp.bind(this));
						Main_1.GDispatcher.addEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.addEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
						Main_1.GDispatcher.addEventListener("updateParseFlag", this.onUpdateParseFlag.bind(this));
					}
					onTouchStart(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onTouchMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onTouchEnd(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(data);
					}
					onMouseDown(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onMouseMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onMouseUp(e) {
						var _a;
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(e);
					}
					onEnterFrame() {
						var _a, _b;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.update();
						(_b = this.bgCtrl) === null || _b === void 0 ? void 0 : _b.update();
					}
					onZoomIn(e) {
						this.controler.maxDistance = this.defaultDistance;
						this.controler.minDistance = this.defaultDistance * 0.8;
						let a = { tRadius: this.defaultDistance, tY: 0.57 };
						this.controler.center.set(0, a.tY, 0);
						this.controler.update(a.tRadius);
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a, _b;
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.center.set(0, a.tY, 0);
								(_b = this.controler) === null || _b === void 0 ? void 0 : _b.update(a.tRadius);
							},
						})
							.to({ tRadius: this.defaultDistance * 0.85, tY: 0.63 }, 500)
							.wait(200)
							.call(() => {
								let { rotateOnce } = e.data;
								if (rotateOnce) {
									// 	let target = { rotation: Math.PI * -0.2 };
									// 	Tween.get(target, {
									// 		onChange: () => {
									// 			// @ts-ignore
									// 			this.athletarCtrl.athletarBox.rotation.y = target.rotation;
									// 		},
									// 	})
									// 		.to({ rotation: -Math.PI * 2 + Math.PI * -0.2 }, 1000)
									// 		.call(() => {
									// 			// @ts-ignore
									// 			this.athletarCtrl.athletarBox.rotation.y = Math.PI * -0.2;
									// 		});
								}
							});
					}
					onZoomOut() {
						let a = { tRadius: this.defaultDistance * 0.5 };
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a;
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.update(a.tRadius);
							},
						}).to({ tRadius: this.defaultDistance }, 1000);
						// this.controler?.zoomOut();
					}
					onFadeOut() {
						let a = { opacity: 1 };
						tween_1.Tween.get(a, {
							onChange: () => {
								console.log(1);
								Layers_1.layers.stage.canvas.style.opacity = a.opacity;
								// this.athletarCtrl.athletarBox.traverse((child) => {
								// 	if (child.type.indexOf("Mesh") > 0 && child.material) {
								// 		child.material.transparent = true;
								// 		child.material.opacity = a.opacity;
								// 	}
								// });
							},
						}).to({ opacity: 0 }, 1000);
					}
					onFadeIn() {
						let a = { opacity: 0 };
						tween_1.Tween.get(a, {
							onChange: () => {
								// this.athletarCtrl.athletarBox.traverse((child) => {
								// 	if (child.material) {
								// 		child.material.transparent = true;
								// 		child.material.opacity = a.opacity;
								// 	}
								// });
								Layers_1.layers.stage.canvas.style.opacity = a.opacity;
							},
						}).to({ opacity: 1 }, 1000);
					}
					// 撒花
					onCheerUp() {
						this.onZoomIn({ data: { rotateOnce: false } });
					}
					// TODO 自适应功能
					onResize(e) {
						let { w, h } = e.data;
						let camera = Layers_1.layers.mainLayerCamera;
						if (w && h) {
							camera.updateProjectionMatrix();
							Layers_1.layers.stage.renderer.setSize(w, h);
							return;
						}
						let targetWidth = window ? window.innerWidth : Layers_1.layers.stage.canvasWidth;
						let targetHeight = window ? window.innerHeight : Layers_1.layers.stage.canvasHeight;
						camera.aspect = targetWidth / targetHeight;
						camera.updateProjectionMatrix();
						Layers_1.layers.stage.renderer.setSize(targetWidth, targetHeight);
					}
					onStartAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.startAction();
					}
					onStopAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.stopAction();
					}
					onUpdateAthletar(data, errCount) {
						var _a, _b, _c;
						return __awaiter(this, void 0, void 0, function* () {
							// 不存在模型和背景同时切换的情况
							let { success, fail, flag, idle, aniComplete } = data.data;
							try {
								// await this.bgCtrl?.change(data);
								if (flag && this.initConfig.aniFlag) {
									yield ((_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.checkChangePart(data, idle));
									if (this.bgCtrl && !this.bgCtrl.shadowCamera) {
										this.bgCtrl.initGround();
									}
									this.initConfig.aniFlag = false;
									this.controler.enabled = false;
									this.initConfig.tRadius = this.defaultDistance * 0.65;
									this.controler.minDistance = this.defaultDistance * 0.2;
									this.controler.maxDistance = this.defaultDistance * 1.5;
									(_b = this.controler) === null || _b === void 0 ? void 0 : _b.update(this.initConfig.tRadius);
									Main_1.TWEEN.get(this.initConfig, {
										onChange: () => {
											var _a, _b;
											this.athletarCtrl.athletarBox.setRotationFromAxisAngle(new Vector3_1.Vector3(0, 1, 0), this.initConfig.rotation);
											(_a = this.controler) === null || _a === void 0 ? void 0 : _a.center.set(0, this.initConfig.tY, 0);
											(_b = this.controler) === null || _b === void 0 ? void 0 : _b.update(this.initConfig.tRadius);
										},
									})
										.wait(1000)
										.to({ rotation: Math.PI * 0.1, tY: 0.88, tRadius: this.defaultDistance * 0.62 }, 800)
										.to({ rotation: Math.PI * -0.2, tY: 0.88, tRadius: this.defaultDistance * 0.62 }, 500)
										// .wait(200)
										.to({ rotation: Math.PI * -0.2, tY: 0.57, tRadius: this.defaultDistance }, 1300)
										.call(() => {
											// TWEEN.get(this.initConfig, {
											// 	onChange: () => {
											// 		this.athletarCtrl.athletarBox.setRotationFromAxisAngle(
											// 			new Vector3(0, 1, 0),
											// 			this.initConfig.rotation
											// 		);
											// 	},
											// })
											// 	.wait(200)
											// 	.to({ rotation: Math.PI * -0.25 + Math.PI * 0.4 }, 1000)
											// 	.to({ rotation: Math.PI * -0.25 }, 1000)
											// 	.to({ rotation: Math.PI * -0.25 + Math.PI * 0.4 }, 1000)
											// 	.to({ rotation: Math.PI * -0.25 }, 1000)
											// 	.call(() => {
											this.controler.enabled = true;
											this.controler.minDistance = this.defaultDistance;
											this.controler.maxDistance = this.defaultDistance;
											// });
											aniComplete && aniComplete();
										});
									success && success();
								}
								else {
									yield ((_c = this.athletarCtrl) === null || _c === void 0 ? void 0 : _c.checkChangePart(data, idle));
									if (this.bgCtrl && !this.bgCtrl.shadowCamera) {
										this.bgCtrl.initGround();
									}
									this.athletarCtrl.athletarBox.setRotationFromAxisAngle(new Vector3_1.Vector3(0, 1, 0), Math.PI * -0.2);
									this.controler.center.set(0, 0.57, 0);
									this.controler.update(this.defaultDistance);
									this.controler.minDistance = this.defaultDistance;
									this.controler.maxDistance = this.defaultDistance;
									success && success();
									setTimeout(() => {
										aniComplete && aniComplete();
									}, 100);
								}
							}
							catch (err) {
								console.log("??????", err);
								if (!errCount) {
									errCount = 0;
								}
								errCount++;
								if (errCount > 3) {
									fail && fail(err);
								}
								else {
									console.log("重试次数：", errCount, "次");
									yield this.onUpdateAthletar(data, errCount);
								}
							}
						});
					}
					onUpdateParseFlag() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.updateParseFlag();
					}
					onDisposeTextures() {
						this.athletarCtrl.disposeTextures();
					}
					removeEvents() {
						this.removeEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.removeEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.removeEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.removeEventListener("fadeIn", this.onFadeIn.bind(this));
						Main_1.GDispatcher.removeEventListener("fadeOut", this.onFadeOut.bind(this));
						Main_1.GDispatcher.removeEventListener("cheerUp", this.onCheerUp.bind(this));
						Main_1.GDispatcher.removeEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.removeEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
						Main_1.GDispatcher.removeEventListener("updateParseFlag", this.onUpdateParseFlag.bind(this));
					}
					destory() {
						// @ts-ignore
						this.athletarCtrl = null;
						// @ts-ignore
						this.bgCtrl = null;
						super.destory();
					}
				}
				exports.ChangeGenderScene = ChangeGenderScene;


				/***/
}),

/***/ "./src/scenes/CreateImgsScene/CreateImgsScene.ts":
/*!*******************************************************!*\
  !*** ./src/scenes/CreateImgsScene/CreateImgsScene.ts ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.CreateImgsScene = void 0;
				const AthletarConfig_1 = __webpack_require__(/*! ./../../common/AthletarConfig */ "./src/common/AthletarConfig.ts");
				const BgCtrl_1 = __webpack_require__(/*! ../../common/BgCtrl */ "./src/common/BgCtrl.ts");
				const Main_1 = __webpack_require__(/*! ../../Main */ "./src/Main.ts");
				const AthletarCtrl_1 = __webpack_require__(/*! ../../common/AthletarCtrl */ "./src/common/AthletarCtrl.ts");
				const AmbientLight_1 = __webpack_require__(/*! ../../../libs/three/lights/AmbientLight */ "./libs/three/lights/AmbientLight.js");
				const DirectionalLight_1 = __webpack_require__(/*! ../../../libs/three/lights/DirectionalLight */ "./libs/three/lights/DirectionalLight.js");
				const Vector3_1 = __webpack_require__(/*! ../../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const Layers_1 = __webpack_require__(/*! ../../../modules/views/Layers */ "./modules/views/Layers.ts");
				const Scene_1 = __webpack_require__(/*! ../../../modules/views/Scene */ "./modules/views/Scene.ts");
				const OrbitControls_1 = __webpack_require__(/*! ../../../libs/three/controls/OrbitControls */ "./libs/three/controls/OrbitControls.js");
				const EventDispatcher_1 = __webpack_require__(/*! ../../../libs/three/core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
				const Tools_1 = __webpack_require__(/*! ../../Tools */ "./src/Tools.ts");
				const EffectComposer_js_1 = __webpack_require__(/*! ../../../libs/three/postprocessing/EffectComposer.js */ "./libs/three/postprocessing/EffectComposer.js");
				const RenderPass_js_1 = __webpack_require__(/*! ../../../libs/three/postprocessing/RenderPass.js */ "./libs/three/postprocessing/RenderPass.js");
				const ShaderPass_js_1 = __webpack_require__(/*! ../../../libs/three/postprocessing/ShaderPass.js */ "./libs/three/postprocessing/ShaderPass.js");
				const CopyShader_js_1 = __webpack_require__(/*! ../../../libs/three/shaders/CopyShader.js */ "./libs/three/shaders/CopyShader.js");
				const FXAAShader_js_1 = __webpack_require__(/*! ../../../libs/three/shaders/FXAAShader.js */ "./libs/three/shaders/FXAAShader.js");
				const Color_1 = __webpack_require__(/*! ../../../libs/three/math/Color */ "./libs/three/math/Color.js");
				const PointLight_1 = __webpack_require__(/*! ../../../libs/three/lights/PointLight */ "./libs/three/lights/PointLight.js");
				class CreateImgsScene extends Scene_1.Scene {
					constructor() {
						super();
						this.name = "CreateImgsScene";
					}
					start(data) {
						const _super = Object.create(null, {
							start: { get: () => super.start }
						});
						return __awaiter(this, void 0, void 0, function* () {
							_super.start.call(this);
							// 暂时隐藏  加载完成后一起出现
							this.visible = false;
							// 初始化灯光
							this.initLights();
							// 初始化相机  每个layer都有自己的相机 这里是初始化这个scene里camera的坐标车朝向
							this.initCamera();
							// 这个是业务维度的  分为化身控制器（AthletarCtrl）和背景控制器（BgCtrl） 并优先加载身体部分
							yield this.initControls();
							// 这个是控制维度的  OrbitControl  用来旋转缩放场景模型
							this.initControler();
							// 整体提亮
							Layers_1.layers.stage.renderer.gammaFactor = 2.6;
							// layers.mainLayer.background = new Color(0xf1ebdd);
							// 使用后处理的fxaa做抗锯齿
							this.visible = true;
							// this.initPass();
						});
					}
					initLights() {
						// 环境光
						let al = new AmbientLight_1.AmbientLight();
						this.add(al);
						// 直射光
						let dl = new DirectionalLight_1.DirectionalLight();
						dl.setPosition(0, 1.7, 0.5);
						dl.castShadow = false;
						this.add(dl);
						let pl = new PointLight_1.PointLight(0xffffff, 2, 10);
						pl.setPosition(0, 2.3, 1);
						this.add(pl);
					}
					initCamera() {
						let camera = Layers_1.layers.mainLayerCamera;
						camera.setPosition(0, 0.8, 14.12);
						camera.lookAt(0, 0.8, 0);
					}
					initControler() {
						this.controler = new OrbitControls_1.OrbitControls(Layers_1.layers.mainLayerCamera);
						// this.controler.setMaxVerticalRotationAngle(Math.PI / 8, Math.PI / 8);
						this.controler.center.set(0, 0.8, 0);
						this.controler.minPolarAngle = Math.PI / 2;
						this.controler.maxPolarAngle = Math.PI / 2;
						//@ts-ignore
						this.defaultDistance = new Vector3_1.Vector3().distanceTo(Layers_1.layers.mainLayerCamera.position);
						//@ts-ignore
						this.controler.maxDistance = this.defaultDistance;
						//@ts-ignore
						this.controler.minDistance = this.defaultDistance * 0.7;
						// this.controler.update();
					}
					initControls() {
						return __awaiter(this, void 0, void 0, function* () {
							// 仅仅初始化 外面告知换装后再换
							this.athletarCtrl = new AthletarCtrl_1.AthletarCtrl(this);
							this.athletarCtrl.athletarBox.setRotationFromAxisAngle(new Vector3_1.Vector3(0, 1, 0), 0);
							// scene.scale.set(2,2,2)
							this.bgCtrl = new BgCtrl_1.BgCtrl(this, Layers_1.layers.topLayerCamera, this.controler);
						});
					}
					initPass() {
						const renderPass = new RenderPass_js_1.RenderPass(this, Layers_1.layers.mainLayerCamera);
						renderPass.clearColor = new Color_1.Color(256, 256, 256);
						renderPass.clearAlpha = 0;
						let fxaaPass;
						fxaaPass = this.fxaaPass = new ShaderPass_js_1.ShaderPass(FXAAShader_js_1.FXAAShader);
						const copyPass = new ShaderPass_js_1.ShaderPass(CopyShader_js_1.CopyShader);
						let composer1 = (this.composer1 = new EffectComposer_js_1.EffectComposer(Layers_1.layers.stage.renderer));
						composer1.addPass(renderPass);
						composer1.addPass(copyPass);
						const pixelRatio = Layers_1.layers.stage.renderer.getPixelRatio();
						fxaaPass.material.uniforms["resolution"].value.x = 1 / (Layers_1.layers.stage.canvasWidth * pixelRatio);
						fxaaPass.material.uniforms["resolution"].value.y = 1 / (Layers_1.layers.stage.canvasHeight * pixelRatio);
					}
					passUpdate() {
						var _a;
						Layers_1.layers.stage.renderer.setScissorTest(true);
						Layers_1.layers.stage.renderer.setScissor(0, 0, Layers_1.layers.stage.canvasWidth, Layers_1.layers.stage.canvasHeight);
						(_a = this.composer1) === null || _a === void 0 ? void 0 : _a.render();
						Layers_1.layers.stage.renderer.setScissorTest(false);
					}
					initEvents() {
						this.addEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						// GDispatcher.addEventListener("onResize", this.onResize.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseDown", this.onMouseDown.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseMove", this.onMouseMove.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseUp", this.onMouseUp.bind(this));
						Main_1.GDispatcher.addEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.addEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.addEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
						Main_1.GDispatcher.addEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.addEventListener("cutImgs", this.onCutImgs.bind(this));
						Main_1.GDispatcher.addEventListener("cutAvatar", this.onCutAvatar.bind(this));
						Main_1.GDispatcher.addEventListener("seekStop", this.onSeekAction.bind(this));
					}
					onTouchStart(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onTouchMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onTouchEnd(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(data);
					}
					onMouseDown(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onMouseMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onMouseUp(e) {
						var _a;
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(e);
					}
					onEnterFrame() {
						var _a, _b;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.update();
						(_b = this.bgCtrl) === null || _b === void 0 ? void 0 : _b.update();
						// this.passUpdate();
					}
					// TODO 自适应功能
					onResize(e) {
						let { w, h } = e.data;
						let camera = Layers_1.layers.mainLayerCamera;
						if (w && h) {
							camera.updateProjectionMatrix();
							Layers_1.layers.stage.renderer.setSize(w, h);
							return;
						}
						let targetWidth = window ? window.innerWidth : Layers_1.layers.stage.canvasWidth;
						let targetHeight = window ? window.innerHeight : Layers_1.layers.stage.canvasHeight;
						camera.aspect = targetWidth / targetHeight;
						camera.updateProjectionMatrix();
						Layers_1.layers.stage.renderer.setSize(targetWidth, targetHeight);
					}
					onStartAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.startAction();
					}
					onStopAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.stopAction();
					}
					onSeekAction(time) {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.seekStop(time);
					}
					onUpdateAthletar(data, errCount) {
						var _a;
						return __awaiter(this, void 0, void 0, function* () {
							// 不存在模型和背景同时切换的情况
							let { success, fail } = data.data;
							try {
								yield ((_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.checkChangePart(data));
								if (this.bgCtrl && !this.bgCtrl.shadowCamera) {
									this.bgCtrl.initGround();
								}
								// await this.bgCtrl?.change(data);
								success && success();
							}
							catch (err) {
								console.log("??????", err);
								if (!errCount) {
									errCount = 0;
								}
								errCount++;
								if (errCount > 3) {
									fail && fail(err);
								}
								else {
									console.log("重试次数：", errCount, "次");
									yield this.onUpdateAthletar(data, errCount);
								}
							}
						});
					}
					onCutImgs(data) {
						return __awaiter(this, void 0, void 0, function* () {
							// console.log("CutImg：", data.data);
							let { imgType, dk, success, fail } = data.data;
							if (imgType == "all") {
							}
							else {
								let direction = {
									left: [6.3, 1, 10.4],
									front: [0, 1, 12.12],
									right: [-7, 1, 12.12],
									avatar: [1.2, 1.7, 3.3],
								};
								let move = dk.split("_")[5];
								let action = this.athletarCtrl.actionsList[move];
								let time = 0;
								if (action == AthletarConfig_1.ActionType.WALK) {
									this.athletarCtrl.athletarBox.setPosition(0, 0, 0);
									if (imgType !== "avatar")
										time = 0.12;
									direction = {
										left: [-7, 0.8, 12.12],
										front: [0, 0.8, 14],
										right: [8.2, 0.8, 11.4],
										avatar: [0.95 * 0.95, 1.43, 3.3 * 0.95],
									};
								}
								else if (action == AthletarConfig_1.ActionType.RUN) {
									this.athletarCtrl.athletarBox.setPosition(0, 0, 0);
									time = 2.83;
									direction = {
										left: [-3.6, 0.8, 13.5],
										front: [0.8, 0.8, 14.12],
										right: [8.2, 0.8, 11.4],
										avatar: [0.95 * 0.95, 1.43, 3.3 * 0.95],
									};
								}
								else if (action == AthletarConfig_1.ActionType.BASKETBALL) {
									this.athletarCtrl.athletarBox.setPosition(-0.1, 0, -0.2);
									time = 5.8;
									direction = {
										left: [-6.6, 0.8, 12.12],
										front: [0, 0.8, 13.8],
										right: [4.27, 0.8, 13.1],
										avatar: [0.95 * 0.95, 1.43, 3.3 * 0.95],
									};
								}
								else if (action == AthletarConfig_1.ActionType.HIPHOP) {
									time = 9.28;
									if (imgType == "left") {
										this.athletarCtrl.athletarBox.setPosition(-0.21, 0, -0.1);
									}
									else if (imgType == "front") {
										this.athletarCtrl.athletarBox.setPosition(-0.48, 0, -0.1);
									}
									else if (imgType == "right") {
										this.athletarCtrl.athletarBox.setPosition(-0.85, 0, -0.1);
									}
									direction = {
										left: [7.875, 0.75, 10.46],
										front: [10.27, 0.75, 7.1],
										right: [11.2 * 1.05, 0.75, 3.42 * 1.05],
										avatar: [0.95 * 0.95, 1.43, 3.3 * 0.95],
									};
								}
								Object.keys(this.athletarCtrl.mixerPool).forEach((name) => {
									this.athletarCtrl.updateAction();
									this.athletarCtrl.mixerPool[name].setTime(time);
								});
								this.bgCtrl.update();
								Layers_1.layers.mainLayerCamera.setPosition(direction[imgType][0] * 0.93, direction[imgType][1], direction[imgType][2] * 0.93);
								let name = "";
								if (imgType == "right" || imgType == "left" || imgType == "front") {
									Layers_1.layers.mainLayerCamera.lookAt(0, direction[imgType][1], 0);
									name = dk + "_" + imgType + "_poster";
									// await Tools.wait(200);
									yield Tools_1.Tools.cutImg(imgType, name);
								}
								else if (imgType == "avatar") {
									Layers_1.layers.mainLayerCamera.lookAt(-0.01, direction[imgType][1] + 0.1, 0);
									name = dk + "_avatar";
									yield Tools_1.Tools.wait(100);
									yield Tools_1.Tools.cutImg(imgType, name);
								}
							}
							success && success();
						});
					}
					onCutAvatar() {
						let direction = [1.5, 1.5, 3.2];
					}
					onDisposeTextures() {
						this.athletarCtrl.disposeTextures();
					}
					removeEvents() {
						this.removeEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.removeEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.removeEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.removeEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
						Main_1.GDispatcher.removeEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.removeEventListener("cutImgs", this.onCutImgs.bind(this));
						Main_1.GDispatcher.removeEventListener("cutAvatar", this.onCutAvatar.bind(this));
						Main_1.GDispatcher.removeEventListener("seekStop", this.onSeekAction.bind(this));
					}
					destory() {
						// @ts-ignore
						this.athletarCtrl = null;
						// @ts-ignore
						this.bgCtrl = null;
						super.destory();
					}
				}
				exports.CreateImgsScene = CreateImgsScene;


				/***/
}),

/***/ "./src/scenes/CustomerAvatarScene/customerAvatarScene.ts":
/*!***************************************************************!*\
  !*** ./src/scenes/CustomerAvatarScene/customerAvatarScene.ts ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.CustomerAvatarScene = void 0;
				const Layers_1 = __webpack_require__(/*! ../../../modules/views/Layers */ "./modules/views/Layers.ts");
				const BgCtrl_1 = __webpack_require__(/*! ../../common/BgCtrl */ "./src/common/BgCtrl.ts");
				const Main_1 = __webpack_require__(/*! ../../Main */ "./src/Main.ts");
				const AthletarCtrl_1 = __webpack_require__(/*! ../../common/AthletarCtrl */ "./src/common/AthletarCtrl.ts");
				const AmbientLight_1 = __webpack_require__(/*! ../../../libs/three/lights/AmbientLight */ "./libs/three/lights/AmbientLight.js");
				const DirectionalLight_1 = __webpack_require__(/*! ../../../libs/three/lights/DirectionalLight */ "./libs/three/lights/DirectionalLight.js");
				const Vector3_1 = __webpack_require__(/*! ../../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const Scene_1 = __webpack_require__(/*! ../../../modules/views/Scene */ "./modules/views/Scene.ts");
				const OrbitControlsForCustomerAvatar_1 = __webpack_require__(/*! ../../../libs/three/controls/OrbitControlsForCustomerAvatar */ "./libs/three/controls/OrbitControlsForCustomerAvatar.js");
				const EventDispatcher_1 = __webpack_require__(/*! ../../../libs/three/core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
				const Tools_1 = __webpack_require__(/*! ../../Tools */ "./src/Tools.ts");
				const tween_1 = __webpack_require__(/*! ../../../libs/tween */ "./libs/tween/index.ts");
				class CustomerAvatarScene extends Scene_1.Scene {
					constructor() {
						super();
						this.name = "CustomerAvatarScene";
					}
					start(data) {
						const _super = Object.create(null, {
							start: { get: () => super.start }
						});
						return __awaiter(this, void 0, void 0, function* () {
							_super.start.call(this);
							// 暂时隐藏  加载完成后一起出现
							this.visible = false;
							// 初始化灯光
							this.initLights();
							// 初始化相机  每个layer都有自己的相机 这里是初始化这个scene里camera的坐标车朝向
							this.initCamera();
							// 这个是业务维度的  分为化身控制器（AthletarCtrl）和背景控制器（BgCtrl） 并优先加载身体部分
							yield this.initControls();
							// 这个是控制维度的  OrbitControl  用来旋转缩放场景模型
							this.initControler();
							// layers.mainLayer.background = new Color(0xf1ebdd);
							// layers.stage.renderer.autoClear = false;
							// let fire = new CheerUpUI();
							// fire.initUi();
							// layers.bottomLayer.add(fire);
							// let cube = new Mesh(new BoxGeometry(2, 2, 2), new MeshBasicMaterial({ color: 0xfff000 }));
							// layers.mainLayer.add(cube);
							this.visible = true;
						});
					}
					initLights() {
						// 环境光
						let al = new AmbientLight_1.AmbientLight();
						this.add(al);
						// 直射光
						let dl = new DirectionalLight_1.DirectionalLight();
						dl.setPosition(0, 1.7, 0.5);
						dl.castShadow = false;
						this.add(dl);
					}
					initCamera() {
						let camera = Layers_1.layers.mainLayerCamera;
						camera.setPosition(0, 1, 12.7);
						camera.lookAt(0, 1, 0);
					}
					initControler() {
						this.controler = new OrbitControlsForCustomerAvatar_1.OrbitControls(Layers_1.layers.mainLayerCamera);
						// this.controler.setMaxVerticalRotationAngle(Math.PI / 8, Math.PI / 8);
						this.controler.center.set(0, 1, 0);
						this.controler.minPolarAngle = Math.PI / 2;
						this.controler.maxPolarAngle = Math.PI / 2;
						//@ts-ignore
						this.defaultDistance = new Vector3_1.Vector3().distanceTo(Layers_1.layers.mainLayerCamera.position);
						//@ts-ignore
						this.controler.maxDistance = this.defaultDistance;
						//@ts-ignore
						this.controler.minDistance = this.defaultDistance * 0.6;
						this.controler.update(this.defaultDistance);
					}
					initControls() {
						return __awaiter(this, void 0, void 0, function* () {
							// 仅仅初始化 外面告知换装后再换
							this.athletarCtrl = new AthletarCtrl_1.AthletarCtrl(this);
							// scene.scale.set(2,2,2)
							this.bgCtrl = new BgCtrl_1.BgCtrl(this, Layers_1.layers.topLayerCamera, this.controler);
							// let pet: any = await Tools.loadGltf(
							// 	"https://wildwood-test.oss-cn-beijing.aliyuncs.com/avatar/d11/model/",
							// 	"pet2-pack.gltf"
							// );
							// console.log("pet:", pet);
							// pet.scene.position.set(0.3, 0, -0.3);
							// this.add(pet.scene);
						});
					}
					initEvents() {
						this.addEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.addEventListener("onResize", this.onResize.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseDown", this.onMouseDown.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseMove", this.onMouseMove.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseUp", this.onMouseUp.bind(this));
						Main_1.GDispatcher.addEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.addEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.addEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.addEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.addEventListener("rotateOnce", this.onRotateOnce.bind(this));
						Main_1.GDispatcher.addEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.addEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
						Main_1.GDispatcher.addEventListener("updateParseFlag", this.onUpdateParseFlag.bind(this));
					}
					onTouchStart(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onTouchMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onTouchEnd(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(data);
					}
					onMouseDown(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onMouseMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onMouseUp(e) {
						var _a;
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(e);
					}
					onEnterFrame() {
						var _a, _b;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.update();
						(_b = this.bgCtrl) === null || _b === void 0 ? void 0 : _b.update();
					}
					onZoomIn(e) {
						let a = { tRadius: this.defaultDistance };
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a;
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.update(a.tRadius);
							},
						})
							.to({ tRadius: this.defaultDistance * 0.6 }, 1000)
							.wait(200)
							.call(() => {
								// let { rotateOnce } = e.data;
								// if (rotateOnce) {
								// 	let target = { rotation: Math.PI * -0.2 };
								// 	Tween.get(target, {
								// 		onChange: () => {
								// 			// @ts-ignore
								// 			this.athletarCtrl.athletarBox.rotation.y = target.rotation;
								// 		},
								// 	})
								// 		.to({ rotation: -Math.PI * 2 + Math.PI * -0.2 }, 1000)
								// 		.call(() => {
								// 			// @ts-ignore
								// 			this.athletarCtrl.athletarBox.rotation.y = Math.PI * -0.2;
								// 		});
								// }
							});
					}
					onZoomOut() {
						let a = { tRadius: this.defaultDistance * 0.5 };
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a;
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.update(a.tRadius);
							},
						}).to({ tRadius: this.defaultDistance }, 1000);
						// this.controler?.zoomOut();
					}
					onRotateOnce(data) {
						let { success, fail } = data.data;
						try {
							let target = { rotation: Math.PI * -0.2 };
							tween_1.Tween.get(target, {
								onChange: () => {
									// @ts-ignore
									this.athletarCtrl.athletarBox.rotation.y = target.rotation;
								},
							})
								.to({ rotation: -Math.PI * 2 + Math.PI * -0.2 }, 1000)
								.call(() => {
									// @ts-ignore
									this.athletarCtrl.athletarBox.rotation.y = Math.PI * -0.2;
									success && success();
								});
						}
						catch (err) {
							fail && fail(err);
						}
					}
					// TODO 自适应功能
					onResize() {
						let camera = Layers_1.layers.mainLayerCamera;
						let targetWidth = window ? window.innerWidth : Layers_1.layers.stage.canvasWidth;
						let targetHeight = window ? window.innerHeight : Layers_1.layers.stage.canvasHeight;
						camera.aspect = targetWidth / targetHeight;
						camera.updateProjectionMatrix();
						Layers_1.layers.stage.renderer.setSize(targetWidth, targetHeight);
					}
					onStartAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.startAction();
					}
					onStopAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.stopAction();
					}
					onUpdateAthletar(data, errCount) {
						var _a;
						return __awaiter(this, void 0, void 0, function* () {
							// 不存在模型和背景同时切换的情况
							let { success, fail } = data.data;
							try {
								yield ((_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.checkChangePart(data));
								if (this.bgCtrl && !this.bgCtrl.shadowCamera) {
									this.bgCtrl.initGround();
								}
								// await this.bgCtrl?.change(data);
								success && success();
							}
							catch (err) {
								console.log("??????", err);
								if (!errCount) {
									errCount = 0;
								}
								errCount++;
								if (errCount > 3) {
									fail && fail(err);
								}
								else {
									console.log("重试次数：", errCount, "次");
									yield this.onUpdateAthletar(data, errCount);
								}
							}
						});
					}
					onUpdateParseFlag() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.updateParseFlag();
					}
					onDisposeTextures() {
						this.athletarCtrl.disposeTextures();
					}
					removeEvents() {
						this.removeEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.removeEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.removeEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.addEventListener("rotateOnce", this.onRotateOnce.bind(this));
						Main_1.GDispatcher.removeEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.removeEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
						Main_1.GDispatcher.removeEventListener("updateParseFlag", this.onUpdateParseFlag.bind(this));
					}
					destory() {
						// @ts-ignore
						this.athletarCtrl = null;
						// @ts-ignore
						this.bgCtrl = null;
						super.destory();
					}
				}
				exports.CustomerAvatarScene = CustomerAvatarScene;


				/***/
}),

/***/ "./src/scenes/MainScene/MainScene.ts":
/*!*******************************************!*\
  !*** ./src/scenes/MainScene/MainScene.ts ***!
  \*******************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.MainScene = void 0;
				const BgCtrl_1 = __webpack_require__(/*! ./../../common/BgCtrl */ "./src/common/BgCtrl.ts");
				const Main_1 = __webpack_require__(/*! ./../../Main */ "./src/Main.ts");
				const AthletarCtrl_1 = __webpack_require__(/*! ./../../common/AthletarCtrl */ "./src/common/AthletarCtrl.ts");
				const AmbientLight_1 = __webpack_require__(/*! ../../../libs/three/lights/AmbientLight */ "./libs/three/lights/AmbientLight.js");
				const DirectionalLight_1 = __webpack_require__(/*! ../../../libs/three/lights/DirectionalLight */ "./libs/three/lights/DirectionalLight.js");
				const Vector3_1 = __webpack_require__(/*! ../../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const Layers_1 = __webpack_require__(/*! ../../../modules/views/Layers */ "./modules/views/Layers.ts");
				const Scene_1 = __webpack_require__(/*! ../../../modules/views/Scene */ "./modules/views/Scene.ts");
				const OrbitControls_1 = __webpack_require__(/*! ../../../libs/three/controls/OrbitControls */ "./libs/three/controls/OrbitControls.js");
				const EventDispatcher_1 = __webpack_require__(/*! ../../../libs/three/core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
				const Tools_1 = __webpack_require__(/*! ../../Tools */ "./src/Tools.ts");
				const tween_1 = __webpack_require__(/*! ../../../libs/tween */ "./libs/tween/index.ts");
				const EffectComposer_js_1 = __webpack_require__(/*! ../../../libs/three/postprocessing/EffectComposer.js */ "./libs/three/postprocessing/EffectComposer.js");
				const RenderPass_js_1 = __webpack_require__(/*! ../../../libs/three/postprocessing/RenderPass.js */ "./libs/three/postprocessing/RenderPass.js");
				const ShaderPass_js_1 = __webpack_require__(/*! ../../../libs/three/postprocessing/ShaderPass.js */ "./libs/three/postprocessing/ShaderPass.js");
				const CopyShader_js_1 = __webpack_require__(/*! ../../../libs/three/shaders/CopyShader.js */ "./libs/three/shaders/CopyShader.js");
				const FXAAShader_js_1 = __webpack_require__(/*! ../../../libs/three/shaders/FXAAShader.js */ "./libs/three/shaders/FXAAShader.js");
				const Color_1 = __webpack_require__(/*! ../../../libs/three/math/Color */ "./libs/three/math/Color.js");
				const Vector2_1 = __webpack_require__(/*! ../../../libs/three/math/Vector2 */ "./libs/three/math/Vector2.js");
				class MainScene extends Scene_1.Scene {
					constructor() {
						super();
						this.name = "MainScene";
						this.rotateStart = new Vector2_1.Vector2();
						this.rotateEnd = new Vector2_1.Vector2();
						this.rotateDelta = new Vector2_1.Vector2();
					}
					start(data) {
						const _super = Object.create(null, {
							start: { get: () => super.start }
						});
						return __awaiter(this, void 0, void 0, function* () {
							_super.start.call(this);
							// 暂时隐藏  加载完成后一起出现
							this.visible = false;
							// 初始化灯光
							this.initLights();
							// 初始化相机  每个layer都有自己的相机 这里是初始化这个scene里camera的坐标车朝向
							this.initCamera();
							// 这个是业务维度的  分为化身控制器（AthletarCtrl）和背景控制器（BgCtrl） 并优先加载身体部分
							yield this.initControls();
							// 这个是控制维度的  OrbitControl  用来旋转缩放场景模型
							this.initControler();
							// 设置背景颜色
							// layers.mainLayer.background = new Color(0xf1ebdd);
							this.visible = true;
							// this.initPass();
							let bgScene = (this.bgScene = new Scene_1.Scene());
							// 环境光
							let al = new AmbientLight_1.AmbientLight();
							al.intensity = 2.1;
							bgScene.add(al);
							let dl = new DirectionalLight_1.DirectionalLight();
							dl.setPosition(0, 1.7, 0.5);
							dl.castShadow = false;
							bgScene.add(dl);
							// let logo: any = (this.logo = await Tools.loadGltf("https://duiba.oss-cn-hangzhou.aliyuncs.com/db_games/activity/nike_avatarchanger_0916/bgTest/", "logoV2-pack.gltf"));
							// logo.scene.scale.set(2.1, 2.1, 2.1);
							// logo.scene.position.set(0, 1.5, 0);
							// // logo.scene.traverse((child) => {
							// // 	child.material && (child.material.depthWrite = false);
							// // });
							// bgScene.add(logo.scene);
							// let cloud: any = (this.cloud = await Tools.loadGltf(
							// 	"https://duiba.oss-cn-hangzhou.aliyuncs.com/db_games/activity/nike_avatarchanger_0916/bgTest/",
							// 	"cloudBlueV2-pack.gltf"
							// ));
							// cloud.scene.scale.set(1.3, 1.3, 1.3);
							// cloud.scene.position.set(-0.1, 2.2, 0);
							// // cloud.scene.traverse((child) => {
							// // 	child.material && (child.material.depthWrite = false);
							// // });
							// bgScene.add(cloud.scene);
							// let cloud2: any = (this.cloud2 = await Tools.loadGltf(
							// 	"https://duiba.oss-cn-hangzhou.aliyuncs.com/db_games/activity/nike_avatarchanger_0916/bgTest/",
							// 	"cloudRedV2-pack.gltf"
							// ));
							// cloud2.scene.scale.set(1.3, 1.3, 1.3);
							// cloud2.scene.position.set(0.45, 1.8, 0);
							// // cloud2.scene.traverse((child) => {
							// // 	child.material && (child.material.depthWrite = false);
							// // });
							// bgScene.add(cloud2.scene);
							// let camera2 = (this.camera2 = new PerspectiveCamera(10, layers.stage.canvasWidth / layers.stage.canvasHeight, 0.001, 100));
							// camera2.setPosition(0, 2.3, 18);
							// camera2.lookAt(0, 2.3, 0.5);
							// this.controler2 = new OrbitControls(camera2);
							// this.controler2.center.set(0, 2.1, 0.5);
							// this.controler2.minPolarAngle = Math.PI / 2;
							// this.controler2.maxPolarAngle = Math.PI / 2;
							// this.controler2.userRotateSpeed = 0.1;
							// this.controler2.maxAzimuthAngle = Math.PI / 28;
							// this.controler2.minAzimuthAngle = -Math.PI / 28;
							//@ts-ignore
							// this.defaultDistance2 = new Vector3().distanceTo(camera2.position);
							//@ts-ignore
							// this.controler2.maxDistance = this.defaultDistance2;
							// //@ts-ignore
							// this.controler2.minDistance = this.defaultDistance2;
							// this.controler2.update(this.defaultDistance2);
							// let logoMixer = (this.logoMixer = new AnimationMixer(logo.scene));
							// let cloudMixer = (this.cloudMixer = new AnimationMixer(cloud.scene));
							// let cloud2Mixer = (this.cloud2Mixer = new AnimationMixer(cloud2.scene));
							// let action3 = logoMixer.clipAction(logo.animations[0]);
							// action3.play();
							// let action = cloudMixer.clipAction(cloud.animations[0]);
							// action.play();
							// let action2 = cloud2Mixer.clipAction(cloud2.animations[0]);
							// action2.play();
						});
					}
					initLights() {
						// 环境光
						let al = new AmbientLight_1.AmbientLight();
						this.add(al);
						// 直射光
						let dl = new DirectionalLight_1.DirectionalLight();
						dl.setPosition(0, 1.7, 0.5);
						dl.castShadow = false;
						this.add(dl);
					}
					initCamera() {
						let camera = Layers_1.layers.mainLayerCamera;
						camera.setPosition(-1.1 * 4.9, 1.15, 3.1 * 4.9);
						camera.lookAt(0, 1.15, 0);
					}
					initControler(center) {
						!this.controler && (this.controler = new OrbitControls_1.OrbitControls(Layers_1.layers.mainLayerCamera));
						// this.controler.setMaxVerticalRotationAngle(Math.PI / 8, Math.PI / 8);
						if (center) {
							this.controler.center.set(center.x, center.y, center.z);
						}
						else {
							this.controler.center.set(0, 1.25, 0);
						}
						this.controler.minPolarAngle = Math.PI / 2;
						this.controler.maxPolarAngle = Math.PI / 2;
						//@ts-ignore
						this.defaultDistance = new Vector3_1.Vector3().distanceTo(Layers_1.layers.mainLayerCamera.position);
						//@ts-ignore
						this.controler.maxDistance = this.defaultDistance;
						//@ts-ignore
						this.controler.minDistance = this.defaultDistance;
						this.controler.update(this.defaultDistance);
					}
					initControls() {
						return __awaiter(this, void 0, void 0, function* () {
							// 仅仅初始化 外面告知换装后再换
							this.athletarCtrl = new AthletarCtrl_1.AthletarCtrl(this);
							// scene.scale.set(2,2,2)
							this.bgCtrl = new BgCtrl_1.BgCtrl(this, Layers_1.layers.topLayerCamera, this.controler);
						});
					}
					initPass() {
						const renderPass = new RenderPass_js_1.RenderPass(this, Layers_1.layers.mainLayerCamera);
						renderPass.clearColor = new Color_1.Color(0, 0, 0);
						renderPass.clearAlpha = 0;
						let fxaaPass;
						fxaaPass = this.fxaaPass = new ShaderPass_js_1.ShaderPass(FXAAShader_js_1.FXAAShader);
						const copyPass = new ShaderPass_js_1.ShaderPass(CopyShader_js_1.CopyShader);
						let composer1 = (this.composer1 = new EffectComposer_js_1.EffectComposer(Layers_1.layers.stage.renderer));
						composer1.addPass(renderPass);
						composer1.addPass(copyPass);
						//
						const pixelRatio = Layers_1.layers.stage.renderer.getPixelRatio();
						fxaaPass.material.uniforms["resolution"].value.x = 1 / (Layers_1.layers.stage.canvasWidth * pixelRatio);
						fxaaPass.material.uniforms["resolution"].value.y = 1 / (Layers_1.layers.stage.canvasHeight * pixelRatio);
					}
					passUpdate() {
						var _a;
						Layers_1.layers.stage.renderer.setScissorTest(true);
						Layers_1.layers.stage.renderer.setScissor(0, 0, Layers_1.layers.stage.canvasWidth, Layers_1.layers.stage.canvasHeight);
						(_a = this.composer1) === null || _a === void 0 ? void 0 : _a.render();
						Layers_1.layers.stage.renderer.setScissorTest(false);
					}
					initEvents() {
						this.addEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.addEventListener("onResize", this.onResize.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseDown", this.onMouseDown.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseMove", this.onMouseMove.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseUp", this.onMouseUp.bind(this));
						Main_1.GDispatcher.addEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.addEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.addEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.addEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.addEventListener("fadeIn", this.onFadeIn.bind(this));
						Main_1.GDispatcher.addEventListener("fadeOut", this.onFadeOut.bind(this));
						Main_1.GDispatcher.addEventListener("resetCamera", this.onResetCamera.bind(this));
						Main_1.GDispatcher.addEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.addEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
						Main_1.GDispatcher.addEventListener("updateParseFlag", this.onUpdateParseFlag.bind(this));
					}
					onTouchStart(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
						// this.controler2?.onTouchStart(data);
						this.rotateStart.set(data.changedTouches[0].x, data.changedTouches[0].y);
					}
					onTouchMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
						// this.controler2?.onTouchMove(data);
						let x = data.changedTouches[0].x;
						let y = data.changedTouches[0].y;
						if (!this.rotateStart.x && !this.rotateStart.y)
							return;
						this.rotateEnd.set(x, y);
						this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
						this.logo.scene.setRotationFromAxisAngle(new Vector3_1.Vector3(0, -1, 0), ((2 * Math.PI * this.rotateDelta.x) / 1800) * -0.4);
						this.cloud.scene.setRotationFromAxisAngle(new Vector3_1.Vector3(0, -1, 0), ((2 * Math.PI * this.rotateDelta.x) / 1800) * -0.4);
						this.cloud2.scene.setRotationFromAxisAngle(new Vector3_1.Vector3(0, -1, 0), ((2 * Math.PI * this.rotateDelta.x) / 1800) * -0.4);
					}
					onTouchEnd(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(data);
						// this.controler2?.onTouchEnd(data);
					}
					onMouseDown(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onMouseMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onMouseUp(e) {
						var _a;
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(e);
					}
					onEnterFrame() {
						var _a, _b;
						// this.cloud?.scene?.rotateOnAxis(new Vector3(0, 1, 0), 0.01);
						// this.logo?.scene?.rotateOnAxis(new Vector3(0, 1, 0), 0.01);
						this.logoMixer && this.logoMixer.update(1 / 60);
						this.cloudMixer && this.cloudMixer.update(1 / 60);
						this.cloud2Mixer && this.cloud2Mixer.update(1 / 60);
						this.bgScene && this.camera2 && Layers_1.layers.stage.renderer.render(this.bgScene, this.camera2);
						// layers.stage.renderer.autoClear = false;
						// layers.stage.renderer.clear();
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.update();
						(_b = this.bgCtrl) === null || _b === void 0 ? void 0 : _b.update();
						// this.passUpdate();
					}
					onZoomIn(e) {
						let a = { tRadius: this.defaultDistance, tY: 0.6 };
						this.controler.maxDistance = this.defaultDistance * 1;
						this.controler.minDistance = this.defaultDistance * 0.7;
						let camera = Layers_1.layers.mainLayerCamera;
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a, _b;
								//@ts-ignore
								camera.position.setY(a.tY);
								camera.lookAt(0, a.tY, 0);
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.center.set(0, a.tY, 0);
								(_b = this.controler) === null || _b === void 0 ? void 0 : _b.update(a.tRadius);
							},
						})
							.to({ tRadius: this.defaultDistance * 0.8, tY: 0.9 }, 1000)
							.wait(200)
							.call(() => {
								this.controler.maxDistance = this.defaultDistance * 0.8;
								this.controler.minDistance = this.defaultDistance * 0.8;
								// let { rotateOnce } = e.data;
								// if (rotateOnce) {
								// 	let target = { rotation: Math.PI * -0.2 };
								// 	Tween.get(target, {
								// 		onChange: () => {
								// 			// @ts-ignore
								// 			this.athletarCtrl.athletarBox.rotation.y = target.rotation;
								// 		},
								// 	})
								// 		.to({ rotation: Math.PI * 2 + Math.PI * -0.2 }, 1000)
								// 		.call(() => {
								// 			// @ts-ignore
								// 			this.athletarCtrl.athletarBox.rotation.y = Math.PI * -0.2;
								// 		});
								// }
							});
					}
					onZoomOut() {
						let a = { tRadius: this.defaultDistance * 0.75, tY: 0.9 };
						this.controler.maxDistance = this.defaultDistance * 1.2;
						this.controler.minDistance = this.defaultDistance * 0.75;
						let camera = Layers_1.layers.mainLayerCamera;
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a, _b;
								//@ts-ignore
								camera.position.setY(a.tY);
								camera.lookAt(0, a.tY, 0);
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.center.set(0, a.tY, 0);
								(_b = this.controler) === null || _b === void 0 ? void 0 : _b.update(a.tRadius);
							},
						})
							.to({ tRadius: this.defaultDistance, tY: 0.6 }, 1000)
							.call(() => {
								this.controler.maxDistance = this.defaultDistance * 1.2;
								this.controler.minDistance = this.defaultDistance;
							});
						// this.controler?.zoomOut();
					}
					//
					onDisposeTextures() {
						this.athletarCtrl.disposeTextures();
					}
					onFadeOut() {
						let a = { opacity: 1 };
						tween_1.Tween.get(a, {
							onChange: () => {
								Layers_1.layers.stage.canvas.style.opacity = a.opacity;
							},
						}).to({ opacity: 0 }, 1000);
					}
					onFadeIn() {
						let a = { opacity: 0 };
						tween_1.Tween.get(a, {
							onChange: () => {
								Layers_1.layers.stage.canvas.style.opacity = a.opacity;
							},
						}).to({ opacity: 1 }, 1000);
					}
					onResetCamera(data) {
						var _a, _b, _c, _d;
						let { sceneType } = data.data;
						let camera = Layers_1.layers.mainLayerCamera;
						if (sceneType == "status") {
							(_a = this.camera2) === null || _a === void 0 ? void 0 : _a.setPosition(0, 2.3, 18);
							(_b = this.camera2) === null || _b === void 0 ? void 0 : _b.lookAt(0, 2.3, 0);
							camera.setPosition(-1.1 * 5.6, 1.5, 3.1 * 5.6);
							camera.lookAt(0, 1.25, 0);
							// this.controler2?.center.set(0, 2.3, 0.5);
							this.initControler({ x: 0, y: 1.5, z: 0 });
						}
						else if (sceneType == "avatar") {
							(_c = this.camera2) === null || _c === void 0 ? void 0 : _c.setPosition(0, 1.25, 18);
							(_d = this.camera2) === null || _d === void 0 ? void 0 : _d.lookAt(0, 1.25, 0.5);
							camera.setPosition(-1.1 * 4.9, 0.55, 3.1 * 4.9);
							camera.lookAt(0, 0.55, 0);
							// this.controler2?.center.set(0, 1.25, 0.5);
							this.initControler({ x: 0, y: 0.55, z: 0 });
						}
					}
					// TODO 自适应功能
					onResize(e) {
						let { w, h } = e.data;
						let camera = Layers_1.layers.mainLayerCamera;
						if (w && h) {
							camera.updateProjectionMatrix();
							Layers_1.layers.stage.renderer.setSize(w, h);
							return;
						}
						let targetWidth = window ? window.innerWidth : Layers_1.layers.stage.canvasWidth;
						let targetHeight = window ? window.innerHeight : Layers_1.layers.stage.canvasHeight;
						camera.aspect = targetWidth / targetHeight;
						camera.updateProjectionMatrix();
						Layers_1.layers.stage.renderer.setSize(targetWidth, targetHeight);
					}
					onStartAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.startAction();
					}
					onStopAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.stopAction();
					}
					onUpdateAthletar(data, errCount) {
						var _a;
						return __awaiter(this, void 0, void 0, function* () {
							// 不存在模型和背景同时切换的情况
							let { success, fail } = data.data;
							try {
								yield ((_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.checkChangePart(data));
								if (this.bgCtrl) {
									if (!this.bgCtrl.shadowCamera) {
										this.bgCtrl.initGround();
									}
									else {
										this.bgCtrl.reloadGround();
									}
								}
								// await this.bgCtrl?.change(data);
								success && success();
							}
							catch (err) {
								console.log("??????", err);
								if (!errCount) {
									errCount = 0;
								}
								errCount++;
								if (errCount > 3) {
									fail && fail(err);
								}
								else {
									console.log("重试次数：", errCount, "次");
									yield this.onUpdateAthletar(data, errCount);
								}
							}
						});
					}
					onUpdateParseFlag() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.updateParseFlag();
					}
					removeEvents() {
						this.removeEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.removeEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.removeEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.removeEventListener("fadeIn", this.onFadeIn.bind(this));
						Main_1.GDispatcher.removeEventListener("fadeOut", this.onFadeOut.bind(this));
						Main_1.GDispatcher.removeEventListener("resetCamera", this.onResetCamera.bind(this));
						Main_1.GDispatcher.removeEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.removeEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
						Main_1.GDispatcher.removeEventListener("updateParseFlag", this.onUpdateParseFlag.bind(this));
					}
					destory() {
						// @ts-ignore
						this.athletarCtrl = null;
						// @ts-ignore
						this.bgCtrl = null;
						super.destory();
					}
				}
				exports.MainScene = MainScene;


				/***/
}),

/***/ "./src/scenes/MiniCardScene/MiniCardScene.ts":
/*!***************************************************!*\
  !*** ./src/scenes/MiniCardScene/MiniCardScene.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function (module, exports, __webpack_require__) {

				"use strict";

				var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
					function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
					return new (P || (P = Promise))(function (resolve, reject) {
						function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
						function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
						function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
						step((generator = generator.apply(thisArg, _arguments || [])).next());
					});
				};
				Object.defineProperty(exports, "__esModule", { value: true });
				exports.MiniCardScene = void 0;
				const BgCtrl_1 = __webpack_require__(/*! ../../common/BgCtrl */ "./src/common/BgCtrl.ts");
				const Main_1 = __webpack_require__(/*! ../../Main */ "./src/Main.ts");
				const AthletarCtrl_1 = __webpack_require__(/*! ../../common/AthletarCtrl */ "./src/common/AthletarCtrl.ts");
				const AmbientLight_1 = __webpack_require__(/*! ../../../libs/three/lights/AmbientLight */ "./libs/three/lights/AmbientLight.js");
				const DirectionalLight_1 = __webpack_require__(/*! ../../../libs/three/lights/DirectionalLight */ "./libs/three/lights/DirectionalLight.js");
				const Vector3_1 = __webpack_require__(/*! ../../../libs/three/math/Vector3 */ "./libs/three/math/Vector3.js");
				const Layers_1 = __webpack_require__(/*! ../../../modules/views/Layers */ "./modules/views/Layers.ts");
				const Scene_1 = __webpack_require__(/*! ../../../modules/views/Scene */ "./modules/views/Scene.ts");
				const OrbitControls_1 = __webpack_require__(/*! ../../../libs/three/controls/OrbitControls */ "./libs/three/controls/OrbitControls.js");
				const EventDispatcher_1 = __webpack_require__(/*! ../../../libs/three/core/EventDispatcher */ "./libs/three/core/EventDispatcher.js");
				const Tools_1 = __webpack_require__(/*! ../../Tools */ "./src/Tools.ts");
				const tween_1 = __webpack_require__(/*! ../../../libs/tween */ "./libs/tween/index.ts");
				class MiniCardScene extends Scene_1.Scene {
					constructor() {
						super();
						this.name = "MiniCardScene";
					}
					start(data) {
						const _super = Object.create(null, {
							start: { get: () => super.start }
						});
						return __awaiter(this, void 0, void 0, function* () {
							_super.start.call(this);
							// 暂时隐藏  加载完成后一起出现
							this.visible = false;
							// 初始化灯光
							this.initLights();
							// 初始化相机  每个layer都有自己的相机 这里是初始化这个scene里camera的坐标车朝向
							this.initCamera();
							// 这个是业务维度的  分为化身控制器（AthletarCtrl）和背景控制器（BgCtrl） 并优先加载身体部分
							yield this.initControls();
							// 这个是控制维度的  OrbitControl  用来旋转缩放场景模型
							// this.initControler();
							// layers.mainLayer.background = new Color(0xf1ebdd);
							// 初始化完成显示
							this.visible = true;
						});
					}
					initLights() {
						// 环境光
						let al = new AmbientLight_1.AmbientLight();
						this.add(al);
						// 直射光
						let dl = new DirectionalLight_1.DirectionalLight();
						dl.setPosition(0, 1.7, 0.5);
						dl.castShadow = false;
						this.add(dl);
					}
					initCamera() {
						let camera = Layers_1.layers.mainLayerCamera;
						camera.setPosition(-0.3, 0.52, 3.1 * 4.9);
						camera.lookAt(-0.3, 0.52, 0);
					}
					initControler(center) {
						!this.controler && (this.controler = new OrbitControls_1.OrbitControls(Layers_1.layers.mainLayerCamera));
						// this.controler.setMaxVerticalRotationAngle(Math.PI / 8, Math.PI / 8);
						if (center) {
							this.controler.center.set(center.x, center.y, center.z);
						}
						else {
							this.controler.center.set(0, 0.6, 0);
						}
						this.controler.minPolarAngle = (Math.PI * 3) / 8;
						this.controler.maxPolarAngle = (Math.PI * 4) / 8;
						//@ts-ignore
						this.defaultDistance = new Vector3_1.Vector3().distanceTo(Layers_1.layers.mainLayerCamera.position);
						//@ts-ignore
						this.controler.maxDistance = this.defaultDistance * 1.2;
						//@ts-ignore
						this.controler.minDistance = this.defaultDistance;
						this.controler.update(this.defaultDistance);
					}
					initControls() {
						return __awaiter(this, void 0, void 0, function* () {
							// 仅仅初始化 外面告知换装后再换
							this.athletarCtrl = new AthletarCtrl_1.AthletarCtrl(this);
							this.athletarCtrl.athletarBox.setRotationFromAxisAngle(new Vector3_1.Vector3(0, 1, 0), Math.PI * -0.2);
							// scene.scale.set(2,2,2)
							this.bgCtrl = new BgCtrl_1.BgCtrl(this, Layers_1.layers.topLayerCamera, this.controler);
						});
					}
					initEvents() {
						this.addEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.addEventListener("onResize", this.onResize.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.addEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseDown", this.onMouseDown.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseMove", this.onMouseMove.bind(this));
						Main_1.GDispatcher.addEventListener("onMouseUp", this.onMouseUp.bind(this));
						Main_1.GDispatcher.addEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.addEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.addEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.addEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.addEventListener("fadeIn", this.onFadeIn.bind(this));
						Main_1.GDispatcher.addEventListener("fadeOut", this.onFadeOut.bind(this));
						Main_1.GDispatcher.addEventListener("resetCamera", this.onResetCamera.bind(this));
						Main_1.GDispatcher.addEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.addEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
					}
					onTouchStart(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onTouchMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onTouchEnd(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(data);
					}
					onMouseDown(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchStart(data);
					}
					onMouseMove(e) {
						var _a;
						let { data } = Tools_1.Tools.adaptEvent(e);
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchMove(data);
					}
					onMouseUp(e) {
						var _a;
						(_a = this.controler) === null || _a === void 0 ? void 0 : _a.onTouchEnd(e);
					}
					onEnterFrame() {
						var _a, _b;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.update();
						(_b = this.bgCtrl) === null || _b === void 0 ? void 0 : _b.update();
					}
					onZoomIn(e) {
						let a = { tRadius: this.defaultDistance };
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a;
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.update(a.tRadius);
							},
						})
							.to({ tRadius: this.defaultDistance * 0.6 }, 1000)
							.wait(200)
							.call(() => {
								// let { rotateOnce } = e.data;
								// if (rotateOnce) {
								// 	let target = { rotation: Math.PI * -0.2 };
								// 	Tween.get(target, {
								// 		onChange: () => {
								// 			// @ts-ignore
								// 			this.athletarCtrl.athletarBox.rotation.y = target.rotation;
								// 		},
								// 	})
								// 		.to({ rotation: Math.PI * 2 + Math.PI * -0.2 }, 1000)
								// 		.call(() => {
								// 			// @ts-ignore
								// 			this.athletarCtrl.athletarBox.rotation.y = Math.PI * -0.2;
								// 		});
								// }
							});
					}
					onZoomOut() {
						let a = { tRadius: this.defaultDistance * 0.5 };
						//@ts-ignore
						tween_1.Tween.get(a, {
							onChange: () => {
								var _a;
								(_a = this.controler) === null || _a === void 0 ? void 0 : _a.update(a.tRadius);
							},
						}).to({ tRadius: this.defaultDistance }, 1000);
						// this.controler?.zoomOut();
					}
					onFadeOut() {
						let a = { opacity: 1 };
						tween_1.Tween.get(a, {
							onChange: () => {
								Layers_1.layers.stage.canvas.style.opacity = a.opacity;
							},
						}).to({ opacity: 0 }, 1000);
					}
					onFadeIn() {
						let a = { opacity: 0 };
						tween_1.Tween.get(a, {
							onChange: () => {
								Layers_1.layers.stage.canvas.style.opacity = a.opacity;
							},
						}).to({ opacity: 1 }, 1000);
					}
					onResetCamera(data) {
						let { sceneType } = data.data;
						let camera = Layers_1.layers.mainLayerCamera;
						if (sceneType == "status") {
							camera.setPosition(-1.1 * 5.2, 1.25, 3.1 * 5.2);
							camera.lookAt(0, 1.25, 0);
							this.initControler({ x: 0, y: 1.25, z: 0 });
						}
						else if (sceneType == "avatar") {
							camera.setPosition(-1.1 * 5.5, 0.6, 3.1 * 5.5);
							camera.lookAt(0, 0.6, 0);
							this.initControler({ x: 0, y: 0.6, z: 0 });
						}
					}
					// TODO 自适应功能
					onResize(e) {
						let { w, h } = e.data;
						let camera = Layers_1.layers.mainLayerCamera;
						if (w && h) {
							camera.updateProjectionMatrix();
							Layers_1.layers.stage.renderer.setSize(w, h);
							return;
						}
						let targetWidth = window ? window.innerWidth : Layers_1.layers.stage.canvasWidth;
						let targetHeight = window ? window.innerHeight : Layers_1.layers.stage.canvasHeight;
						camera.aspect = targetWidth / targetHeight;
						camera.updateProjectionMatrix();
						Layers_1.layers.stage.renderer.setSize(targetWidth, targetHeight);
					}
					onStartAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.startAction();
					}
					onStopAction() {
						var _a;
						(_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.stopAction();
					}
					onUpdateAthletar(data, errCount) {
						var _a;
						return __awaiter(this, void 0, void 0, function* () {
							// 不存在模型和背景同时切换的情况
							let { success, fail } = data.data;
							try {
								yield ((_a = this.athletarCtrl) === null || _a === void 0 ? void 0 : _a.checkChangePart(data));
								if (this.bgCtrl && !this.bgCtrl.shadowCamera) {
									this.bgCtrl.initGround();
								}
								// await this.bgCtrl?.change(data);
								success && success();
							}
							catch (err) {
								console.log("??????", err);
								if (!errCount) {
									errCount = 0;
								}
								errCount++;
								if (errCount > 3) {
									fail && fail(err);
								}
								else {
									console.log("重试次数：", errCount, "次");
									yield this.onUpdateAthletar(data, errCount);
								}
							}
						});
					}
					onDisposeTextures() {
						this.athletarCtrl.disposeTextures();
					}
					removeEvents() {
						this.removeEventListener(EventDispatcher_1.EventType.ENTERFRAME, this.onEnterFrame.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchStart", this.onTouchStart.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchMove", this.onTouchMove.bind(this));
						Main_1.GDispatcher.removeEventListener("onTouchEnd", this.onTouchEnd.bind(this));
						Main_1.GDispatcher.removeEventListener("startAction", this.onStartAction.bind(this));
						Main_1.GDispatcher.removeEventListener("stopAction", this.onStopAction.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomIn", this.onZoomIn.bind(this));
						Main_1.GDispatcher.removeEventListener("zoomOut", this.onZoomOut.bind(this));
						Main_1.GDispatcher.removeEventListener("fadeIn", this.onFadeIn.bind(this));
						Main_1.GDispatcher.removeEventListener("fadeOut", this.onFadeOut.bind(this));
						Main_1.GDispatcher.removeEventListener("resetCamera", this.onResetCamera.bind(this));
						Main_1.GDispatcher.removeEventListener("disposeTextures", this.onDisposeTextures.bind(this));
						Main_1.GDispatcher.removeEventListener("updateAthletar", this.onUpdateAthletar.bind(this));
					}
					destory() {
						// @ts-ignore
						this.athletarCtrl = null;
						// @ts-ignore
						this.bgCtrl = null;
						super.destory();
					}
				}
				exports.MiniCardScene = MiniCardScene;


				/***/
}),

/***/ "./src/shaders/HorizontalBlurShader.js":
/*!*********************************************!*\
  !*** ./src/shaders/HorizontalBlurShader.js ***!
  \*********************************************/
/*! exports provided: HorizontalBlurShader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HorizontalBlurShader", function () { return HorizontalBlurShader; });
				/**
				 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
				 * - see http://www.cake23.de/traveling-wavefronts-lit-up.html
				 *
				 * - 9 samples per pass
				 * - standard deviation 2.7
				 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
				 */

				const HorizontalBlurShader = {

					uniforms: {

						'tDiffuse': { value: null },
						'h': { value: 1.0 / 512.0 }

					},

					vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

					fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform float h;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

			gl_FragColor = sum;

		}`

				};



				/***/
}),

/***/ "./src/shaders/VerticalBlurShader.js":
/*!*******************************************!*\
  !*** ./src/shaders/VerticalBlurShader.js ***!
  \*******************************************/
/*! exports provided: VerticalBlurShader */
/***/ (function (module, __webpack_exports__, __webpack_require__) {

				"use strict";
				__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VerticalBlurShader", function () { return VerticalBlurShader; });
				/**
				 * Two pass Gaussian blur filter (horizontal and vertical blur shaders)
				 * - see http://www.cake23.de/traveling-wavefronts-lit-up.html
				 *
				 * - 9 samples per pass
				 * - standard deviation 2.7
				 * - "h" and "v" parameters should be set to "1 / width" and "1 / height"
				 */

				const VerticalBlurShader = {

					uniforms: {

						'tDiffuse': { value: null },
						'v': { value: 1.0 / 512.0 }

					},

					vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

					fragmentShader: /* glsl */`

		uniform sampler2D tDiffuse;
		uniform float v;

		varying vec2 vUv;

		void main() {

			vec4 sum = vec4( 0.0 );

			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
			sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

			gl_FragColor = sum;

		}`

				};



				/***/
})

		/******/
});
});
//# sourceMappingURL=output.js.map